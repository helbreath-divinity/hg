// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include <direct.h>

#include "..\shared\buffer.h"
#include "..\shared\magicid.h"
#include "HG.h"
#include "mgrs\GuildMgr.h"
#include "mgrs\ObjectMgr.h"
#include "mgrs\PartyMgr.h"
#include "ui\Winmain.h"
#include "map\map.h"
#include "map\DynamicObject.h"
#include "map\DynamicObjectID.h"
#include "map\OccupyFlag.h"
#include "map\Teleport.h"
#include "map\TeleportLoc.h"
#include "map\Tile.h"
#include "map\StrategicPoint.h"
#include "map\TeleportLoc.h"
#include "char\ActionID.h"
#include "char\Crafting.h"
#include "char\combat.h"
#include "char\DelayEvent.h"
#include "char\Guild.h"
#include "char\movement.h"
#include "char\Npc.h"
#include "char\HTNpc.h"
#include "char\Elite.h"
#include "char\Quest.h"
#include "char\Skill.h"
#include "char\item\BuildItem.h"
#include "char\item\Fish.h"
#include "char\item\Mineral.h"
#include "char\item\Potion.h"
#include "net\msg.h"
#include "net\UserMessages.h"
#include "net\MessageIndex.h"
#include "Ini.h"
#include "astoria.h"
#include "DropManager.h"
#include "misc.h"
#include "englishitem.h"
#include "StrTok.h"

CGuildMgr guildMgr;
CPartyMgr partyMgr;
CObjectMgr objMgr;
DropManager	drops;

extern char g_cTxt[512];
extern char g_msg[50];
extern char	G_cData50000[50000];

extern HWND	G_hWnd;

extern class CMap	**	g_mapList;
extern class CClient ** g_clientList;
extern class CNpc **	g_npcList;
extern class CNpc **   g_npcConfigList;
extern class CMagic ** g_magicConfigList;
extern class CItem ** g_itemConfigList;

extern int * g_skillSSNpoint;

extern HashMap<ItemID, uint8> g_socketMap;

extern bool g_updateWeb;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGame::CGame(HWND hWnd) : m_hWnd(hWnd)
{
	int i, x;

	GSID = -1;
	m_bIsGameServerRegistered = false;
	ReceivedAllConfig		= false;
	m_bIsGameStarted = false;
	m_bIsItemAvailable      = false;
	m_bIsBuildItemAvailable = false;
	m_bIsNpcAvailable       = false;
	m_bIsMagicAvailable     = false;
	m_bIsSkillAvailable     = false;
	m_bIsQuestAvailable     = false;
	m_bIsPortionAvailable   = false;
	m_dropsInitiated			= false;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_sForceRecallTime = 0 ;

	g_clientList = m_pClientList;
	for (i = 0; i < MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	g_mapList = m_pMapList;
	for (i = 0; i < MAXMAPS; i++)
		m_pMapList[i] = NULL;

	g_itemConfigList = m_pItemConfigList;
	for (i = 0; i < MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	g_npcConfigList = m_npcConfigList;
	for (i = 0; i < MAXNPCTYPES; i++)
		m_npcConfigList[i] = NULL;

	g_npcList = m_pNpcList;
	for (i = 0; i < MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	g_magicConfigList = m_pMagicConfigList;
	for (i = 0; i < MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

	for (i = 0; i < MAXCRAFTING; i++)
		m_pCraftingConfigList[i] = NULL; 

	for (i = 0; i < MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = false;
		m_bIsSocketConnected[i] = false;
	}

	for (i = 0; i < MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	for ( i = 0; i < MAXGROUNDITEMS; i++ )
	{
		m_stGroundNpcItem[i].bEmpty = true;
		m_stGroundNpcItem[i].cMapIndex = 0;
		m_stGroundNpcItem[i].dropTime = 0;
		m_stGroundNpcItem[i].item = NULL;
		m_stGroundNpcItem[i].sx = m_stGroundNpcItem[i].sy = 0;
	}

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;
	
	for(int i = 0; i < MAXMAPNAMES; i++)
	{
		m_mapNameList[ GetMapName(i) ] = i;
	}

	for(int i = 0; i < SG_MAX; i++)
	{
		g_socketMap[ SocketGems[i] ] = i;
	}

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	for(int i=0; i < MAXSIDES; i++)
	{
		m_stCityStatus[i].iCrimes = 0;
		m_stCityStatus[i].iFunds  = 0;
		m_stCityStatus[i].iWins   = 0;
	}
	m_sSlateSuccessRate		= 0;

	m_iAutoRebootingCount = 0;

	m_pGold = NULL ;

	m_eventsIni = NULL;

	// 2002-09-09 #1
	m_bReceivedItemList = false;
}

CGame::~CGame()
{

}

bool CGame::bAccept(class XSocket * pXSock)
{
	int i;
	class XSocket * pTmpSock;
	char IP[21], charName[12], accName[15], accPass[12];
	bool valid = false;

	pTmpSock = new class XSocket(m_hWnd, CLIENTSOCKETBLOCKLIMIT);

	if ((m_bIsItemAvailable == false)    || (m_bIsNpcAvailable == false)       || 
		(m_bIsMagicAvailable == false)    || (m_bIsSkillAvailable == false)     || 
		(m_bIsPortionAvailable == false)  || (m_bOnExitProcess == true)         || 
		(m_bIsQuestAvailable == false)    || (m_bIsBuildItemAvailable == false) ||
		(m_bIsGameStarted == false)		 || (m_dropsInitiated == false)
		) 
		goto CLOSE_ANYWAY;


	for (i = 1; i < MAXCLIENTS; i++)
	{
		if (m_pClientList[i] == NULL) {
			
			pTmpSock->bInitBufferSize(MSGBUFFERSIZE);
			pXSock->bAccept(pTmpSock, WM_ONCLIENTSOCKETEVENT + i); 

			ZeroMemory(IP, sizeof(IP));
			pTmpSock->iGetPeerAddress(IP);

			for(List<ConfirmedLogin>::iterator it = confirmedLogins.begin(); it != confirmedLogins.end(); ++it)
			{
				if(strcmp(it->ip, IP) == 0){
					valid = true;
					strncpy(accName, it->accName, sizeof(accName));
					strncpy(accPass, it->accPass, sizeof(accPass));
					strncpy(charName, it->playerName, sizeof(charName));
					confirmedLogins.erase(it);
					break;
				}
			}
			
			if(!valid) 
			{
				wsprintf(g_cTxt,"(!!) Non-permitted client: %s", IP);
				PutLogList(g_cTxt);
				
				for(List<ConfirmedLogin>::iterator it = confirmedLogins.begin(); it != confirmedLogins.end(); ++it)
				{
					wsprintf(g_cTxt,"   Logins list: %s %s %s %s", it->ip, it->accName, it->accPass, it->playerName);
					PutLogList(g_cTxt);
				}
				delete pTmpSock;
				return false;
			}

			m_pClientList[i] = new class CClient(i);
			m_pClientList[i]->m_pXSock = pTmpSock;

			bAddClientShortCut(i);

			m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = 
				m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime = 
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime = 
				m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = timeGetTime();
			
			ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
			strcpy(m_pClientList[i]->m_cIPaddress, IP);

			strcpy(m_pClientList[i]->m_cCharName, charName);
			strcpy(m_pClientList[i]->m_cAccountName, accName);
			strcpy(m_pClientList[i]->m_cAccountPassword, accPass);

			wsprintf(g_cTxt,"<%d> New client: %s Character: %s)", i, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName);
			PutLogList(g_cTxt);

			m_iTotalClients++;

			if (m_iTotalClients > m_iMaxClients) {

				m_iMaxClients = m_iTotalClients;
				//wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
				//PutLogFileList(cTxt);
			}

			bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, i);
			return true;
		}
	}

CLOSE_ANYWAY:;
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;

	return false;
}


void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	UINT iTmp;
	int iClientH, iRet;
	uint32 dwTime = timeGetTime();


	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = message - iTmp;

	if (m_pClientList[iClientH] == NULL) return;

	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case XSOCKEVENT_READCOMPLETE:
		OnClientRead(iClientH);
		m_pClientList[iClientH]->m_dwTime = timeGetTime();
		break;

	case XSOCKEVENT_BLOCK:
		PutLogList("Socket BLOCKED!");
		break;

	case XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(g_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(g_cTxt);
		DeleteClient(iClientH, false, true);
		break;

	case XSOCKEVENT_MSGSIZETOOLARGE:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		wsprintf(g_cTxt,"<%d> Client Disconnected! (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(g_cTxt); 
		if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 1000) {
			wsprintf(g_cTxt, "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutLogFileList(g_cTxt);
		}

		DeleteClient(iClientH, true, true);
		break;
	}													    
}


bool CGame::bInit()		   
{
	char * cp;
	uint32 * dwp;
	uint16 * wp;
	int  i;
	SYSTEMTIME SysTime;
	uint32 dwTime = timeGetTime();

	//CMisc::Temp();

	PutLogList("(!) INITIALIZING GAME SERVER...");
	//

	for (i = 0; i < MAXCLIENTS+1; i++)
		m_iClientShortCut[i] = 0;

	for (i = 0; i < MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < MAXNPCTYPES; i++)
		if (m_npcConfigList[i] != NULL) delete m_npcConfigList[i];

	for (i = 0; i < MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < MAXPORTIONTYPES; i++)
		if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

	for (i = 0; i < MAXCRAFTING; i++)
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i]; 

	for (i = 0; i < MAXBUILDITEMS; i++) 
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;

	for (i = 0; i < MAXSCHEDULE; i++) {
		m_schedules[i].iDay = -1;
		m_schedules[i].iHour = -1;
		m_schedules[i].iMinute = -1;
		m_schedules[i].evStatus = ES_ENDED;
		m_schedules[i].evType = ET_NONE;
	}

	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS

	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG

	m_iNpcConstructionPoint[51] = 1500; // Catapult
	//

	m_bIsGameStarted = false;

	m_dropsInitiated			= false;
	m_bIsItemAvailable      = false;
	m_bIsBuildItemAvailable = false;
	m_bIsNpcAvailable       = false;
	m_bIsMagicAvailable     = false;
	m_bIsSkillAvailable     = false;
	m_bIsQuestAvailable     = false;
	m_bIsPortionAvailable   = false;
	ReceivedAllConfig		= false;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	for (i = 0; i < MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	for (i = 0; i < MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < MAXNPCTYPES; i++)
		m_npcConfigList[i] = NULL;

	for (i = 0; i < MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

	for (i = 0; i < MAXCRAFTING; i++)
		m_pCraftingConfigList[i] = NULL; 

	for (i = 0; i < MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = false;
	}

	for (i = 0; i < MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX    = NULL;
		m_stCrusadeStructures[i].dY    = NULL;
	}


	for (i = 0; i < MAXTELEPORTLIST; i++)
		m_pTeleportConfigList[i] = NULL;

	for (i = 0; i < MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = NULL;

	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;
	}
	m_iTotalMiddleCrusadeStructures = 0;

	m_pNoticementData = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iIstriaMapIndex     = -1;
	m_iAstoriaMapIndex    = -1;
	m_iBtFieldMapIndex			= -1;
	m_iRampartMapIndex			= -1;
	m_iGodHMapIndex				= -1;

	ShuffleAstoriaBasePos();
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_eventsIni = new CIni("..\\configs\\stats.ini", "events");

	for(int i=0; i < ET_MAX; i++)
	{
		sstream eventType;
		eventType << i;
		m_eventWinner[i] = (Side)m_eventsIni->ReadInteger(eventType.str().c_str(), NEUTRAL);
	}

	m_iSubLogSockInitIndex   = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	for(int i=0; i < MAXSIDES; i++)
	{
		m_stCityStatus[i].iCrimes = 0;
		m_stCityStatus[i].iFunds  = 0;
		m_stCityStatus[i].iWins   = 0;

		m_iCollectedMana[i] = 0;
		m_mana[i] = 0;
	}

	m_iStrategicStatus = 0;

	m_dwSpecialEventTime = m_dwWeatherTime = m_dwGameTime1 = 
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = false;

	GetLocalTime(&SysTime);

	m_dwCanFightzoneReserveTime =  dwTime -  ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60) *1000 ;


	for(i =0; i < MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;

	m_donateEventHolder = -1;
	m_donateEventPot = -1;
	
	ZeroMemory(m_websiteScriptAddr, sizeof(m_websiteScriptAddr));
	ZeroMemory(m_websiteAddr,sizeof(m_websiteAddr));
	m_websitePort = 0;

	for (i = 1; i < 300; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);

		//testcode
		//		wsprintf(g_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//		PutLogFileList(g_cTxt);

	}

	m_iLimitedUserExp = m_iLevelExpTable[LEVELLIMIT+1]; 
	m_iLevelExp51     = m_iLevelExpTable[51]; 

	m_iGameServerMode = 0;

	if (bReadProgramConfigFile("GServer.cfg") == false) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! config file contents error!");
		return false;
	}

	srand( (unsigned)time( NULL ) );   

	m_bF1pressed = m_bF4pressed = m_bF12pressed = false;

	m_bOnExitProcess = false;


	g_skillSSNpoint = m_iSkillSSNpoint;
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}


	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= NIGHTTIME) 
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;


	bReadNotifyMsgListFile("notice.txt");
	m_dwNoticeTime = m_startTime = dwTime;
	m_onlineCntAdd = 1;

	m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;

	m_pNoticementData      = NULL;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_bIsCrusadeMode = false;
	//GSID = (uint16) dice(1,65535);
	m_bIsApocalypseMode = false;
	m_bIsApocalypseGateOpen	= false; 

	m_iHeldenianType				= 0;
	m_iLastHeldenianType			= 0;
	m_bHeldenianMode				= false;
	m_dwHeldenianGUID				= NULL;
	m_iHeldenianType1Winner			= -1;
	m_iHeldenianType2Winner			= -1;
	m_iHeldenianAresdenLeftTower	= 0;
	m_iHeldenianElvineLeftTower		= 0;
	m_iHeldenianAresdenFlags		= 0;
	m_iHeldenianElvineFlags			= 0;
	m_iHeldenianAresdenDead			= 0;
	m_iHeldenianElvineDead			= 0;
	m_iHeldenianAresdenKill			= 0;
	m_iHeldenianElvineKill			= 0;

	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (uint32 *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (uint16 *)cp;
	*wp = MSGTYPE_CONFIRM;
	cp += 2;

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = NULL;
	m_iCrusadeWinnerSide = NULL;
	m_schedulesCnt = 0;
	m_iFinalShutdownCount = 0;

	m_SoccerMode = false;
	m_SoccerAresdenGoals	= 0;
	m_SoccerElvineGoals		= 0;
	m_SoccerWinner			= -1;
	return true;
}

void CGame::OnClientRead(int iClientH)
{
	char  * pData, cKey;
	uint32  dwMsgSize;

	if (m_pClientList[iClientH] == NULL) return;

	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); 

	if (bPutMsgQuene(MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


void CGame::DisplayInfo(HDC hdc)
{
	char cTxt[80];
	int  i, iLine;

	SelectObject(hdc, GetStockObject(ANSI_VAR_FONT));
	SetTextColor(hdc, clBlack);
	wsprintf(cTxt, "Server-Name: %s", m_cServerName);
	TextOut(hdc, 610, 5, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Max.Level: %d", PLAYERMAXLEVEL);
	TextOut(hdc, 610, 19, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "P: %d/%d + %d | Guilds: %u", 
		m_iTotalGameServerClients, m_iTotalGameServerMaxClients, 
		m_onlineCntAdd, guildMgr.Count());
	TextOut(hdc, 610, 33, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Crusade: %d:%d", m_dwCrusadeGUID, (int)m_bIsCrusadeMode);
	TextOut(hdc, 610, 47, cTxt, strlen(cTxt));
	if(m_astoria.get())
	{
		wsprintf(cTxt, "Astoria: %s", eventName[m_astoria->GetEventType()]);
		TextOut(hdc, 610, 61, cTxt, strlen(cTxt));
	}
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Heldenian: %d:%d", m_dwHeldenianGUID, (int)m_iHeldenianType);
	TextOut(hdc, 610, 75, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "SLSock: %d:%d   Web: %s", m_iSubLogSockActiveCount, m_iSubLogSockFailCount, GetBoolText(g_updateWeb));
	TextOut(hdc, 610, 90, cTxt, strlen(cTxt));
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "Auto-reboot count: %d", m_iAutoRebootingCount);
	TextOut(hdc, 610, 105, cTxt, strlen(cTxt));
	TextOut(hdc, 602, 111, "________________________________", 32);
	TextOut(hdc, 615, 125, "[MAP]         [OBJECTS]", 23);

	iLine = 0;
	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {

			ZeroMemory(g_cTxt, sizeof(g_cTxt));
			wsprintf(g_cTxt, "- %s           [%d]", m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject);
			TextOut(hdc, 610, 164 + iLine*14, g_cTxt, strlen(g_cTxt));
			iLine++;
		}
}


void CGame::ClientMotionHandler(int iClientH, char * pData)
{
	uint32 * dwp, dwClientTime; 
	uint32 wCommand;
	uint16 * wp, wTargetObjectID;
	short * sp, sX, sY, dX, dY, wType, magicType;
	char  * cp, cDir;
	int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bIsObserverMode) return;

	Pop(pData, wCommand);
	Pop(pData, (uint16&)sX);
	Pop(pData, (uint16&)sY);
	Pop(pData, (uint8&)cDir);
	Pop(pData, dwClientTime);
	
	if (wCommand == MSGID_MOTION_MAGIC) {
		Pop(pData, (uint16&)magicType);
	} 
	else if (wCommand == MSGID_MOTION_ATTACK || wCommand == MSGID_MOTION_ATTACKMOVE)
	{
		Pop(pData, (uint16&)dX);
		Pop(pData, (uint16&)dY);
		Pop(pData, (uint16&)wType);
		Pop(pData, (uint16&)wTargetObjectID);
	}

	switch (wCommand) 
	{
	case MSGID_MOTION_STOP:
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short) iClientH, OWNERTYPE_PLAYER, wCommand, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case MSGID_MOTION_RUN:
	case MSGID_MOTION_MOVE:
		if(!bCheckClientMoveFrequency(iClientH, (wCommand == MSGID_MOTION_RUN)))
			iRet = 3;
		else
			iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, (wCommand == MSGID_MOTION_RUN));

		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, wCommand, NULL, NULL, NULL);
		}		
		else if (iRet == 2 || iRet == 3) {
			SendObjectMotionRejectMsg(iClientH);
		}

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) m_pClientList[iClientH]->KilledHandler(NULL, NULL, 1); 
		break;

	case MSGID_MOTION_DAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, false);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, wCommand, (short)m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
		} 
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) m_pClientList[iClientH]->KilledHandler(NULL, NULL, 1); 
		break;

	case MSGID_MOTION_ATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, false);
		if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, wCommand, NULL, NULL, NULL);

			wType = 1;
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, false, true); 
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) m_pClientList[iClientH]->KilledHandler(NULL, NULL, 1); 

		bCheckClientAttackFrequency(iClientH);
		break;

	case MSGID_MOTION_ATTACK:
		_CheckAttackType(iClientH, &wType);

		if(!bCheckClientAttackFrequency(iClientH))
			iRet = 2;
		else
			iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); 
		if (iRet == 1) {
			if (wType >= 20) {
				m_pClientList[iClientH]->m_iSuperAttackLeft--;

				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}

			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, wCommand, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);

		break;

	case MSGID_MOTION_GETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, wCommand, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case MSGID_MOTION_MAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);

		if (iRet == 1) {
			SendEventToNearClient_TypeA((short)iClientH, OWNERTYPE_PLAYER, wCommand, magicType,(short) 10, NULL);
			m_pClientList[iClientH]->m_hasPrecasted = true;
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;
	}
}

int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, bool bIsRun)
{
	char  * cp, cData[3000];
	class CTile * pTile;
	uint32 * dwp, dwTime;
	uint16  * wp, wObjectID;
	short * sp, dX, dY, sDOtype;
	int   * ip, iRet, iSize, i, iTemp, iDamage;
	bool  bRet;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

#ifndef NO_MSGSPEEDCHECK
	if (bIsRun == false) {
		m_pClientList[iClientH]->m_iMoveMsgRecvCount++;

		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
			
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (72*8*7 -3000)) {
					wsprintf(g_cTxt, "(!) Speed hack suspect(%s) - move-lat(%i)",
						m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwMoveLAT); 
					PutLogList(g_cTxt); 
					DeleteClient(iClientH, true, true);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_iRunMsgRecvCount++;

		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {

				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (43*8*7 -1500)) {
					DeleteClient(iClientH, true, true);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}
#endif


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	ClearSkillUsingStatus(iClientH);

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	class CItem * pTopItem = NULL; // 2.172

	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, pTopItem); 

	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0)
		bRet = false;

	if (bRet == true) {

		if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*1,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		if(!m_pClientList[iClientH]->IsEthereal())
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
				OWNERTYPE_PLAYER,	dX, dY);
		}

		if( m_pClientList[iClientH]->GetParty() )
		{
			m_pClientList[iClientH]->GetParty()->UpdateMemberCoords( m_pClientList[iClientH] );
		}

		if (m_astoria.get() && m_astoria->GetEventType() == ET_CAPTURE && 
			m_astoria->GetRelicHolder() == m_pClientList[iClientH])
		{
			m_astoria->m_relicHolderSteps++;
			if (m_astoria->m_relicHolderSteps > 4){
				m_astoria->m_relicHolderSteps = 0;
				UpdateRelicPos();
			}
		}

		if (sDOtype == DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral == true) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {

			}
			else {
				iDamage = dice(2,4);

				if (!m_pClientList[iClientH]->IsInvincible()){
					m_pClientList[iClientH]->m_iHP -= iDamage;
					m_pClientList[iClientH]->m_lastDamageTime = dwTime;
				}
			}
		}

		/*

		short sRemainItemSprite, sRemainItemSpriteFrame;
		char cRemainItemColor;

		switch (pTopItem->m_sIDnum) {
		case 540: 
		if (m_pClientList[iClientH]->m_side == 2) {

		if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_BOOTS] != -1) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_BOOTS]] != NULL) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_BOOTS]]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_ANTIMINE)) {

		}
		else {


		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, (61+100), m_pClientList[iClientH]->m_sType);
		}


		pTopItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
		sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);
		delete pTopItem;
		}
		break;
		case 541: 			if (m_pClientList[iClientH]->m_side == 1) {

		if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_BOOTS] != -1) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_BOOTS]] != NULL) && 
		(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_BOOTS]]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_ANTIMINE)) {

		}
		else {


		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, (61+100), m_pClientList[iClientH]->m_sType);
		}


		pTopItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
		sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);
		delete pTopItem;
		}
		break;
		}
		//
		*/

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;

		dwp  = (uint32 *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
		*wp  = OBJECTMOVE_CONFIRM;

		cp = (char *)(cData + INDEX2_MSGTYPE+2);

		sp  = (short *)cp;
		*sp = (short)(dX - 10); 
		cp += 2;

		sp  = (short *)cp;
		*sp = (short)(dY - 7); 
		cp += 2;

		*cp = cDir;
		cp++;

		if (bIsRun == true) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0; // 1
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStamina == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}
			else {
				*cp = 0; // 1
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStamina == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) {


					m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, true, true);
					return 0;
				}
			}
		}
		else *cp = 0;
		cp++;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;

		iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 4);
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_rejectedMove = true; 
		m_pClientList[iClientH]->m_resetMoveFreq = true; 
		dwp  = (uint32 *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
		*wp  = OBJECTMOVE_REJECT;

		wObjectID = (uint16) iClientH;

		cp = (char *)(cData + INDEX2_MSGTYPE + 2);

		wp  = (uint16 *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		ip  = (int *)cp; 
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp+= 4;

		ip  = (int *)cp;

		*ip = m_pClientList[wObjectID]->m_iStatus;
		cp += 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 42); 

		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	
		Unit * owner = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(dX, dY);
		if(owner){
			if(owner->IsPlayer())
				RequestFullObjectData(iClientH, NULL, owner->m_handle);
			else
				RequestFullObjectData(iClientH, NULL, owner->m_handle+10000);
		}

		return 0;
	}

	return 1;
}


/*void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
	int i;
	char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
	bool bIsObserverMode;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == true) return;


	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); 
	memcpy(cTxt, cCharName, 10);
	CMisc::bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); 
	memcpy(cTxt, cAccountName, 10);
	CMisc::bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); 
	memcpy(cTxt, cAccountPassword, 10);
	CMisc::bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);

	bIsObserverMode = (*cp) ? true : false;
	cp++;


	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {

			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {

				wsprintf(g_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
				PutLogList(g_cTxt);
				//PutLogFileList(g_cTxt);
				DeleteClient(i, true, true, false);
			}
			else {

				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);


				DeleteClient(iClientH, false, false, false);
				return;
			}
		}


	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {

			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				wsprintf(g_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
				PutLogList(g_cTxt);
				//PutLogFileList(g_cTxt);
				DeleteClient(i, true, true, false);
			}
			else {

				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);


				DeleteClient(iClientH, false, false);
				return;
			}
		}


	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);

	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;


	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}*/

void CGame::PlayerMapEntry(int iClientH, bool setRecallTime)
{
	short * sp;
	uint32 * dwp;
	uint16  * wp;
	char  * cp, cQuestRemain;
	int   * ip, iMapSide, iTmpMapSide, iSize, iRet, i;
	SYSTEMTIME SysTime;

	CClient * player = m_pClientList[iClientH];

	if (player == NULL) return;

	iSetSide(iClientH);
	char * pBuffer = new char [MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, MSGBUFFERSIZE+1);

	dwp  = (uint32 *)(pBuffer + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (uint16 *)(pBuffer + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + INDEX2_MSGTYPE + 2);

	if (player->m_bIsObserverMode == false)
		bGetEmptyPosition(&player->m_sX, &player->m_sY, player->m_cMapIndex);
	else GetMapInitialPoint(player->m_cMapIndex, &player->m_sX, &player->m_sY);

	// ObjectID
	wp  = (uint16 *)cp;
	*wp = iClientH;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = player->m_sAppr4;
	cp += 2;

	ip  = (int *)cp; 
	*ip = player->m_iApprColor;
	cp += 4;

	if(m_pClientList[iClientH]->m_iPKCount > 0)
		m_pClientList[iClientH]->SetStatusFlag(STATUS_PK, true);

	ip  = (int *)cp;
	*ip = player->m_iStatus;
	cp += 4;

	memcpy(cp, player->m_cMapName, 10);
	cp += 10;

	memcpy(cp, m_pMapList[player->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	if (m_pMapList[player->m_cMapIndex]->m_bIsFixedDayMode == true) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	if (m_pMapList[player->m_cMapIndex]->m_bIsFixedDayMode) 
		*cp = WEATHER_SUNNY;
	else 
		*cp = m_pMapList[player->m_cMapIndex]->m_weather;
	cp++;

	ip = (int *)cp;
	*ip = player->m_iContribution;
	cp += 4;

	if(!player->m_bIsObserverMode && !m_pClientList[iClientH]->IsEthereal()) {
		m_pMapList[player->m_cMapIndex]->SetOwner((short)iClientH, 
			OWNERTYPE_PLAYER, player->m_sX, player->m_sY);
	}

	*cp = (char)player->m_bIsObserverMode;
	cp++;

	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_reputation;
	cp += 4;

	ip = (int *)cp;
	*ip = player->m_iHP;
	cp += 4;

	if(player->m_bIsOnShop &&	m_iCrusadeWinnerSide == player->m_side) //Shop price adjustment
		*cp = -10;
	else
		*cp = 0;

	cp++;

	iSize = iComposeInitMapData(player->m_sX - 10, player->m_sY - 7, iClientH, cp );

	iRet = player->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+3); 
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		if(pBuffer != NULL) delete[] pBuffer;
		return;
	}

	if(pBuffer != NULL) delete[] pBuffer;

	if(m_astoria.get() && strcmp(player->m_cMapName, "astoria") == 0)
	{
		const Casualties * stats = m_astoria->GetStats();
		player->Notify(NULL, NOTIFY_CASUALTIES, 
			stats[ARESDEN].deaths, stats[ELVINE].deaths, stats[ISTRIA].deaths, NULL, 
			stats[ARESDEN].kills, stats[ELVINE].kills, stats[ISTRIA].kills);

		switch(m_astoria->GetEventType())
		{
		case ET_CAPTURE:
		UpdateRelicPos(iClientH);
			break;

		case ET_DESTROY_SHIELD:
			player->Notify(NULL, NOTIFY_SHIELDHP, ARESDEN, m_astoria->GetShieldHP(ARESDEN));
			player->Notify(NULL, NOTIFY_SHIELDHP, ELVINE, m_astoria->GetShieldHP(ELVINE));
			break;
		}
	}

	if (m_bHeldenianMode)
		UpdateHeldenianStatus();

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_EVENT_CONFIRM, NULL, NULL, NULL);

	if(setRecallTime)
	{
		player->m_bIsWarLocation = false;
		player->m_iTimeLeft_ForceRecall = 0;

		if(player->IsNeutral())
		{
			if(m_bIsCrusadeMode && !player->IsGM() && 
				((strcmp(m_pMapList[player->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0) || 
				 (strcmp(m_pMapList[player->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0) 	|| 
				 (strcmp(m_pMapList[player->m_cMapIndex]->m_cName, sideMap[ISTRIA]) == 0)))
			{
				player->m_dwWarBeginTime = timeGetTime();
				player->m_bIsWarLocation = true;
				player->m_iTimeLeft_ForceRecall = 1; 
			}
		}
		else if (player->IsInFoeMap() && !player->IsGM()) 
		{
			player->m_dwWarBeginTime = timeGetTime();
			player->m_bIsWarLocation = true;

			SetForceRecallTime(iClientH) ;
		}

		if (player->m_iTimeLeft_ForceRecall > 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_FORCERECALLTIME, player->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
		}
	}

	iMapSide = iGetMapLocationSide(m_pMapList[player->m_cMapIndex]->m_cName);

	if (iMapSide >= 11) iTmpMapSide = iMapSide - 10 ;
	else iTmpMapSide = iMapSide ;

	player->m_bIsInBuilding = false ;

	if ((player->m_side != iTmpMapSide) && (iMapSide != 0) ) {
		if ( (iMapSide <= 10) && !player->IsGM() && !player->IsNeutral() )
		{
			player->m_dwWarBeginTime = timeGetTime();
			player->m_bIsWarLocation = true;
			player->m_iTimeLeft_ForceRecall = 1 ; 
			player->m_bIsInBuilding = true ;
		}
	}
	else if (player->IsInJail() && !player->IsGM()) {
		player->m_bIsWarLocation = true;
		player->m_dwWarBeginTime = timeGetTime();

		if (player->m_iTimeLeft_ForceRecall == 0) {
			player->m_iTimeLeft_ForceRecall = 20*5 ; 
		} else if (player->m_iTimeLeft_ForceRecall > 20*5) {
			player->m_iTimeLeft_ForceRecall = 20*5 ;
		}
	}

	_CheckQuestEnvironment(iClientH);

	if (m_astoria.get() && player->m_cMapIndex == m_iAstoriaMapIndex) {
		UpdateRelicPos(iClientH);
	}

	if (player->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}

	if (m_bHeldenianMode)
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_HELDENIANSTART,  NULL , NULL, NULL, NULL);
	}

	if (m_bIsCrusadeMode == true) {
		if (player->m_dwCrusadeGUID == 0) {
			player->m_iCrusadeDuty = 0;
			player->m_iConstructionPoint = 0;
			player->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (player->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			player->m_iCrusadeDuty       = 0;
			player->m_iConstructionPoint = 0;
			player->m_iWarContribution   = 0;
			player->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, NULL, 0, NULL, -1);
		}
		SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, player->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		if (player->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			player->m_iCrusadeDuty = 0;
			player->m_iConstructionPoint = 0;
		}
		else if ((player->m_dwCrusadeGUID != NULL) && (player->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, NULL, 0, NULL, -1);
			player->m_iWarContribution   = 0;
			player->m_dwCrusadeGUID = 0;
		}
	}

	if (m_pMapList[player->m_cMapIndex]->m_bIsFightZone) { //Send all map restrictions
		if (m_pMapList[player->m_cMapIndex]->m_isPartyDisabled && !player->IsGM() && player->GetParty()) 
			partyMgr.RemoveFromParty( player );
		if (m_pMapList[player->m_cMapIndex]->m_isShieldDisabled)
			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTSHIELD, true, NULL, NULL, NULL, NULL);
		if (m_pMapList[player->m_cMapIndex]->m_isArmorDisabled){
			if (!m_pClientList[iClientH]->IsGM() && !m_pClientList[iClientH]->IsDead()){
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ] != -1){
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_HEAD, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], false);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_BODY, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], false);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_ARMS, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], false);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_BOOTS, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ], false);
				}
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ] != -1) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, EQUIPPOS_PANTS, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], NULL, NULL);
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], false);
				}
				SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
			}

			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTARMOR, true, NULL, NULL, NULL, NULL);
		}
		if (m_pMapList[player->m_cMapIndex]->m_isPermIllusionOn){
			if (!player->IsGM()){
				for (i = 1; i < MAXCLIENTS; i++)
					if(m_pClientList[i] != NULL && m_pClientList[i]->IsGM() && m_pClientList[i]->m_cMapIndex == player->m_cMapIndex) break;

				if (i != MAXCLIENTS){
					SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, 3, i, NULL);
					player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = 3;
					player->SetStatusFlag(STATUS_ILLUSION, true);
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTILLUSION, true, NULL, NULL, NULL, NULL);
		}

		if (m_pMapList[player->m_cMapIndex]->m_isChatDisabled)
			SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTCHAT, m_pMapList[player->m_cMapIndex]->m_isChatDisabled, NULL, NULL, NULL, NULL);

		for (i = 0; i < MAXMAGICTYPE; i++)
			if (m_pMapList[player->m_cMapIndex]->m_magicLimited[i])
				SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTSPELL, true, i, NULL, NULL, NULL);

		wsprintf(g_cTxt, "Char(%s)-Enter(%s) Observer(%d)", player->m_cCharName, player->m_cMapName, player->m_bIsObserverMode);
			PutLogFileList(g_cTxt, EVENT_LOGFILE);
	}

	if (player->GetParty())
	{
		player->GetParty()->UpdateMemberMap(player);
	}

	if(player->m_guild)
		player->m_guild->MemberMapChanged(player);

	SendNotifyMsg(NULL, iClientH, NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, NOTIFY_DOWNSKILLINDEXSET, player->m_iDownSkillIndex, NULL, NULL, NULL);
	SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);

	SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, player->m_iConstructionPoint, player->m_iWarContribution, 1, NULL);
	SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, player->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
	Notify_ApocalypseGateState(iClientH);

	player->m_nextRecallPoint = 0;
	if (player->m_iQuest) {
		cQuestRemain = (m_pQuestConfigList[player->m_iQuest]->m_iMaxCount - player->m_iCurQuestCount);
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
		_bCheckIsQuestCompleted(iClientH);
	}
}

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
	int ix, iy, iSize, iTileExists;
	CTile * pTileSrc;

	if (m_pClientList[iClientH] == NULL) return 0;

	short total = 0;

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		(sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	for (iy = 0; iy < 16; iy++)
	{
		for (ix = 0; ix < 21; ix++) 
		{
			if(WriteTileData(pData + iSize, iSize, iClientH, pTileSrc, ix, iy))
				total++;
		}
	}
	*((short *)pData) = total;
	return iSize;
}

void CGame::DeleteClient(int iClientH, bool bSave, bool bNotify, bool bCountLogout, bool bForceCloseConn)
{
	int i, iExH;
	char * cp, cData[120], cTmpMap[30];
	uint32 * dwp;
	uint16 * wp;
	bool previouslyDCd = false;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;

	if(player->m_iGuildGUID != -1)
	{
		if(player->m_guild)
			player->m_guild->MemberLogout(player);
		else
			guildMgr.RemovePendingMember(player);
	}

	if (player->m_bIsInitComplete == true) {
		if (memcmp(player->m_cMapName, "fight", 5) == 0) {
			wsprintf(g_cTxt, "Char(%s)-Exit(%s)", player->m_cCharName, player->m_cMapName);
			PutLogFileList(g_cTxt,EVENT_LOGFILE);
		}

		if (player->m_isExchangeMode == true) {
			iExH = player->m_exchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}


		if ((player->m_iAllocatedFish != NULL) && (m_pFish[player->m_iAllocatedFish] != NULL)) 
			m_pFish[player->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify == true)
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_EVENT_REJECT, NULL, NULL, NULL);

		RemoveFromTarget(iClientH, OWNERTYPE_PLAYER);


		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(NULL, i, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, player->m_cCharName);
			}

			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			*cp = GSM_DISCONNECT;
			cp++;
			memcpy(cp, player->m_cCharName, 10);
			cp += 10;
			bStockMsgToGateServer(cData, 11);
			SendStockMsgToGateServer();

			m_pMapList[player->m_cMapIndex]->ClearOwner(/*2,*/ iClientH, OWNERTYPE_PLAYER,
				player->m_sX, 
				player->m_sY);


			RemoveFromDelayEventList(iClientH, OWNERTYPE_PLAYER, NULL);
	}

	int index = player->HasItem(ITEM_RELIC);
	if(index != ITEM_NONE)
	{
		DropItemHandler(player->m_handle, index, 1, player->m_pItemList[index]->m_cName, false);
	}

	if(bSave && !player->m_bIsOnServerChange) {
		if(player->m_bIsKilled) {
			player->m_sX = -1;
			player->m_sY = -1;

			strcpy(cTmpMap,player->m_cMapName) ;

			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));

			if (player->IsNeutral()) {
				strcpy(player->m_cMapName, sideMap[NEUTRAL]);
			}
			else {
				if (m_bIsCrusadeMode) {
					if (player->m_iDeadPenaltyTime > 0) {
						ZeroMemory(player->m_cLockedMapName, sizeof(player->m_cLockedMapName));
						strcpy(player->m_cLockedMapName, sideMap[ player->m_side ] );
						player->m_iLockedMapTime = 60*5;
						player->m_iDeadPenaltyTime = 60*10; 
					}
					else {
						player->m_iDeadPenaltyTime = 60*10; 
					}
				}

				switch(player->m_side)
				{
				case ARESDEN:
					if ((strcmp(cTmpMap, sideMap[ELVINE]) == 0) && !player->IsGM()){
						strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ELVINE]);
					}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
					}else if (player->m_iLevel > 80)
						strcpy(player->m_cMapName, sideMapRes[ARESDEN]);
					else 
						strcpy(player->m_cMapName, sideMapFarm[ARESDEN]);
					break;
				case ELVINE:
					if ((strcmp(cTmpMap, sideMap[ARESDEN]) == 0) && !player->IsGM()){
						strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
					}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
						strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
					}else if (player->m_iLevel > 80)
						strcpy(player->m_cMapName, sideMapRes[ELVINE]);
					else 
						strcpy(player->m_cMapName, sideMapFarm[ELVINE]);
					break;
				case ISTRIA:
					if ((strcmp(cTmpMap, sideMap[ARESDEN]) == 0) && !player->IsGM()){
						strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
					}else if ((strcmp(cTmpMap, sideMap[ELVINE]) == 0) && !player->IsGM()){
						strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
						player->m_iLockedMapTime = 60*3; 
						strcpy(player->m_cMapName, sideMapJail[ELVINE]);
					}else if (player->m_iLevel > 80)
						strcpy(player->m_cMapName, sideMapRes[ISTRIA]);
					else 
						strcpy(player->m_cMapName, sideMapFarm[ISTRIA]);
					break;
				}
			}
		}
		else if(bForceCloseConn) {

			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			memcpy(player->m_cMapName, "bisle", 5);
			player->m_sX = -1;
			player->m_sY = -1;


			ZeroMemory(player->m_cLockedMapName, sizeof(player->m_cLockedMapName));
			strcpy(player->m_cLockedMapName, "bisle");

			player->m_iLockedMapTime = 10*60;
		}


		if(player->m_bIsObserverMode ||
			memcmp(player->m_cMapName, "astoria", 7) == 0 ) 
		{
			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			strcpy(player->m_cMapName, sideMap[ player->m_side ]);

			player->m_sX = -1;
			player->m_sY = -1;
		}

		if(player->m_cMapIndex >= 0 && !player->IsGM() &&
			(m_pMapList[player->m_cMapIndex]->m_bIsApocalypseMap ||
			m_pMapList[player->m_cMapIndex]->m_bIsFightZone))
		{
			for(List<RecentDisconnect>::iterator it = m_recentDCs.begin(); it != m_recentDCs.end(); ++it) {
				if(strcmp(it->playerName, player->m_cCharName) == 0)
				{	
					if(it->dcCount >= 3){
						m_recentDCs.erase(it);

						ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
						strcpy(player->m_cMapName, sideMap[ player->m_side ]);
						player->m_sX = -1;
						player->m_sY = -1;
					}
					else {
						it->dcCount++;
						for (i = 0; i < 3; i++)
							if (it->disconnectTimes[i] == 0){
								it->disconnectTimes[i] = timeGetTime();
								break;
							}
					}
					previouslyDCd = true;
					break;
				}
			}

			if(!previouslyDCd){
				m_recentDCs.push_back(RecentDisconnect(player->m_cCharName, timeGetTime()));
			}
			
		}

		if(player->m_bIsInitComplete)
		{
			if(!bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) ) 
				LocalSavePlayerData(iClientH);
		} else {
			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
	} else {
		if (!player->m_bIsOnServerChange)
		{
			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		} else {
			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, false); 
		}
	}

	partyMgr.RemoveFromParty( player );

	if (player->m_bIsManager)
		m_iTotalClients--;

	objMgr.Remove( player );
	delete player;
	m_pClientList[iClientH] = NULL;

	RemoveClientShortCut(iClientH);
}


void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, Msgid msgid, short sV1, short sV2, short sV3)
{
	int iShortCutIndex;
	UnitStatus * pstatus, status, statusdummy;
	uint32 size;
	char  * cp, cKey, data[200];
	bool    bOwnerSend;

	pstatus = &statusdummy;
	cKey = (char)(rand() % 255) +1; 

	cp = data;

	Push(cp, msgid);

	if (cOwnerType == OWNERTYPE_PLAYER)
	{
		CClient * player = m_pClientList[sOwnerH];
		if(!player) return;

		switch (msgid) {
		case MSGID_MOTION_NULL:
		case MSGID_MOTION_DAMAGE:
		case MSGID_MOTION_DYING:
			bOwnerSend = true;
			break;
		default:
			bOwnerSend = false;
			break;
		}

		switch (msgid) 
		{
		case MSGID_MOTION_MAGIC:
		case MSGID_MOTION_DAMAGE:
		case MSGID_MOTION_DAMAGEMOVE:
		case MSGID_MOTION_DYING:
			Push(cp, uint16(sOwnerH + 30000));
			Push(cp, (uint8)player->m_cDir);
			Push(cp, (uint8) sV1);
			Push(cp, (uint8) sV2);

			if(msgid == MSGID_MOTION_DYING)
			{
				Push(cp, (uint16)player->m_sX);
				Push(cp, (uint16)player->m_sY);
			}
			break;

		case MSGID_MOTION_ATTACK:
		case MSGID_MOTION_ATTACKMOVE:
			Push(cp, uint16(sOwnerH + 30000));
			Push(cp, (uint8)player->m_cDir);
			
			Push(cp, uint8(sV1 - player->m_sX));
			Push(cp, uint8(sV2 - player->m_sY));
			Push(cp, (uint16)sV3);
			break;

		case MSGID_MOTION_EVENT_CONFIRM:
		case MSGID_MOTION_EVENT_REJECT:
		case MSGID_MOTION_NULL:
		default:
			Push(cp, (uint16)sOwnerH);
			Push(cp, (uint16)player->m_sX);
			Push(cp, (uint16)player->m_sY);
			Push(cp, (uint16)player->m_sType);
			Push(cp, (uint8)player->m_cDir);
			Push(cp, player->m_cCharName);
			
			Push(cp, (uint16)player->m_sAppr1);
			Push(cp, (uint16)player->m_sAppr2);
			Push(cp, (uint16)player->m_sAppr3);
			Push(cp, (uint16)player->m_sAppr4);

			Push(cp, (uint32)player->m_iApprColor);

			pstatus = (UnitStatus*)cp;
			status = player->m_iStatus;
			Push(cp, status);

			Push(cp, (uint8)(
				(msgid != MSGID_MOTION_NULL || !player->m_bIsKilled) 
				? false : true));
			break;
		}

		size = cp - data;
		if(bOwnerSend)
		{
			player->m_pXSock->iSendMsg(data, size, cKey);
		}

		if(player->IsEthereal())
		{
			return;
		}

		CClient * ipClient;
		iShortCutIndex = 0;
		while(int i = m_iClientShortCut[iShortCutIndex++])
		{
			if(!(ipClient = m_pClientList[i]) || !ipClient->m_bIsInitComplete ||
				ipClient->m_cMapIndex != player->m_cMapIndex ||
				ipClient->m_sX < player->m_sX - 11 || ipClient->m_sX > player->m_sX + 11 ||
				ipClient->m_sY < player->m_sY - 9 || ipClient->m_sY > player->m_sY + 9 ||
				i == sOwnerH) 
			{
				continue;
			}

			if(_bGetIsPlayerHostile(i,sOwnerH) && sOwnerH != i && m_pClientList[i]->m_iAdminUserLevel == 0)
				*pstatus = status & STATUS_ENEMYFLAGS;
			else
				*pstatus = status;

			ipClient->m_pXSock->iSendMsg(data, size, cKey);
		}
	}
	else {
		CNpc * npc = m_pNpcList[sOwnerH];
		if(!npc) return;

		switch (msgid) 
		{
		case OBJECTDAMAGE:
		case OBJECTDAMAGEMOVE:
		case OBJECTDYING:
			Push(cp, uint16(sOwnerH + 40000));
			Push(cp, (uint8)npc->m_cDir);
			Push(cp, (uint8) sV1);
			Push(cp, (uint8) sV2);

			if(msgid == MSGID_MOTION_DYING)
			{
				Push(cp, (uint16)npc->m_sX);
				Push(cp, (uint16)npc->m_sY);
			}
			break;

		case OBJECTATTACK:
		case OBJECTATTACKMOVE:
			Push(cp, uint16(sOwnerH + 40000));
			Push(cp, (uint8)npc->m_cDir);
			
			Push(cp, uint8(sV1 - npc->m_sX));
			Push(cp, uint8(sV2 - npc->m_sY));
			Push(cp, (uint16)sV3);
			break;

		case MSGTYPE_CONFIRM:
		case MSGTYPE_REJECT:
		case OBJECTNULLACTION:
		default:
			Push(cp, uint16(sOwnerH + 10000));
			Push(cp, (uint16)npc->m_sX);
			Push(cp, (uint16)npc->m_sY);
			Push(cp, (uint16)npc->m_sType);
			Push(cp, (uint8)npc->m_cDir);
			Push(cp, (uint16)npc->m_sAppr2);

			pstatus = (UnitStatus*)cp;
			status = npc->m_iStatus;
			Push(cp, status);

			Push(cp, (uint8)(
				(msgid != MSGID_MOTION_NULL || !npc->m_bIsKilled) 
				? false : true));
			break;
		}

		iShortCutIndex = 0;

		size = cp - data;
		CClient * pClient;
		while(int i = m_iClientShortCut[iShortCutIndex++]) 
		{
			if(!(pClient = m_pClientList[i]) || !pClient->m_bIsInitComplete ||
				pClient->m_cMapIndex != npc->m_cMapIndex ||
				pClient->m_sX < npc->m_sX - 11 || pClient->m_sX > npc->m_sX + 11 ||
				pClient->m_sY < npc->m_sY - 9 || pClient->m_sY > npc->m_sY + 9) 
			{
				continue;
			}

			pClient->m_pXSock->iSendMsg(data, size, cKey);  
		}
	}
}


int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
	int ix, iy, iSize, iIndex;
	class CTile * pTileSrc;
	short total;

	if (m_pClientList[iClientH] == NULL) return 0;

	iSize = 2;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		(sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	total = 0;
	iIndex = 0;
	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;
		iIndex++;

		if(WriteTileData(pData + iSize, iSize, iClientH, pTileSrc, ix, iy))
			total++;
	}

	*((short *)pData) = total;
	return iSize;
}


void CGame::OnTimer(char cType)
{
	uint32 dwTime;
	BYTE b;


	dwTime = timeGetTime();

	if ((dwTime - m_dwGameTime1) > 300 _ms) {
		NpcProcess();
		m_dwGameTime1 = dwTime;
	}

	MsgProcess();
	guildMgr.Update();

	if ((dwTime - m_dwGameTime2) > 3 _s) {
		CheckClientResponseTime();
		bSendMsgToLS(MSGID_GAMESERVERALIVE, NULL);
		CheckDayOrNightMode();
		InvalidateRect(G_hWnd, NULL, true);
		m_dwGameTime2 = dwTime;


		if ((m_bIsGameStarted == false)     && (m_bIsItemAvailable == true)      && 
			(m_bIsNpcAvailable == true)     && (m_bIsMagicAvailable == true)     &&
			(m_bIsSkillAvailable == true)   && (m_bIsPortionAvailable == true)   &&
			(m_bIsQuestAvailable == true)   && (m_bIsBuildItemAvailable == true) && 
			(m_iSubLogSockActiveCount == MAXSUBLOGSOCK) && (m_dropsInitiated == false)
			) 
		{
			PutLogList("Initializing drops list...");
			drops.InitDrops();
			PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
			m_dropsInitiated = true;
		}
	}

	if ((dwTime - m_dwGameTime6) > 1 _s) {
		if(m_astoria.get() && m_astoria->CheckVictory())
		{
			EventEnd();
		}
		DelayEventProcessor();
		SendStockMsgToGateServer();


		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(g_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(g_cTxt);
			if (m_iFinalShutdownCount <= 1) {

				SendMessage(m_hWnd, WM_DESTROY, NULL, NULL);
				return;

			}
		}


		if (!m_bIsGameServerRegistered && m_pSubLogSock[0] == NULL) {
			m_pSubLogSock[0] = new XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[0]->bConnect(m_cLogServerAddr, m_iGateServerPort, (WM_ONLOGSOCKETEVENT + 1));
			m_pSubLogSock[0]->bInitBufferSize(MSGBUFFERSIZE);
			wsprintf(g_cTxt, "(!) Try to connect sub-log-socket(0)... Addr:%s  Port:%d", m_cLogServerAddr, m_iGateServerPort);
			PutLogList(g_cTxt);
		}
		else if(m_bIsGameServerRegistered) for (b = 1; b < MAXSUBLOGSOCK; b++){
			if(m_pSubLogSock[b] == NULL && !m_bIsSocketConnected[b] && m_bIsSocketConnected[b-1]){
				m_pSubLogSock[b] = new XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
				m_pSubLogSock[b]->bConnect(m_cLogServerAddr, m_iGateServerPort, (WM_ONLOGSOCKETEVENT + b + 1));
				m_pSubLogSock[b]->bInitBufferSize(MSGBUFFERSIZE);
				wsprintf(g_cTxt, "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", b, m_cLogServerAddr, m_iGateServerPort);
				PutLogList(g_cTxt);
			}		 
		}

		m_dwGameTime6 = dwTime;
	}

	if ((dwTime - m_dwGameTime3) > 3 _s) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		// EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
		for(List<ConfirmedLogin>::iterator it = confirmedLogins.begin(); it != confirmedLogins.end();)
			if((dwTime - it->timeReceived) > 15 _s) it = confirmedLogins.erase(it);
			else ++it;

		for(List<RecentDisconnect>::iterator it = m_recentDCs.begin(); it != m_recentDCs.end();){
			for(int i = 0; i < 3; i++){
				if((it->disconnectTimes[i] != 0) && (dwTime - it->disconnectTimes[i]) > 10 _m){
					it->dcCount--;	
					it->disconnectTimes[i] = 0;
				}
			}
			if(it->dcCount == 0) it = m_recentDCs.erase(it);
			else ++it;
		}
	}


	if ((dwTime - m_dwGameTime4) > 600 _ms) {
		MobGenerator();
		m_dwGameTime4 = dwTime;
	}

	if ((dwTime - m_dwGameTime5) > 3 _m) {
		if (m_iMiddlelandMapIndex >= 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		m_dwGameTime5 = dwTime;


		srand( (unsigned)time( NULL ) );   
	}

	if ((dwTime - m_dwFishTime) > 4 _s) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		Scheduler();
		m_dwFishTime = dwTime;
	}

	if ((dwTime - m_dwWeatherTime) > 1 _m) {
		if(g_updateWeb)
		{
			UpdateWebsiteStats();
		}
		WeatherProcessor();
		if(m_bIsApocalypseMode) 
			DoAbaddonThunderDamageHandler(-1);
		if(m_bHeldenianMode)
			UpdateHeldenianStatus();
		m_dwWeatherTime = dwTime;
		TileCleaner();

		if(m_bIsCrusadeMode && (dwTime - m_dwCrusadeGUID) >= 2 _h)
			LocalEndCrusadeMode(0);

		uint32 add;

		if(dwTime - m_startTime < 5 _m)
		{
			add = dice(2,4);
		}
		else if(dwTime - m_startTime < 30 _m)
		{
			add = dice(2,6);
		}
		else
		{
			add = dice(2,8);
		}

		if(add > m_onlineCntAdd)
			m_onlineCntAdd++;
		else if(add < m_onlineCntAdd)
			m_onlineCntAdd--;
	}


	if ((dwTime - m_dwCanFightzoneReserveTime) > 2 _h) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == false) && (m_bOnExitProcess == true) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			guildMgr.Empty();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = true;

			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 3;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	if ((dwTime - m_dwMapSectorInfoTime) > 10 _s) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

void CGame::CheckClientResponseTime()
{
	// int i, iPlusTime, iMaxSuperAttack, iValue, iMapSide,iTmpMapSide;
	int i, iPlusTime, iMaxSuperAttack, iValue;

	short sTemp;
	uint32 dwTime;
	//SYSTEMTIME SysTime;

	/*
	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; 
	case 2:	iWarPeriod = 30; break; 
	case 3:	iWarPeriod = 60; break; 
	case 4:	iWarPeriod = 60*2;  break; 
	case 5:	iWarPeriod = 60*5;  break; 
	case 6:	iWarPeriod = 60*10; break; 
	case 0:	iWarPeriod = 60*20; break; 
	}
	*/

	dwTime = timeGetTime();

	for (i = 1; i < MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {

			if ((dwTime - m_pClientList[i]->m_dwTime) > CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete == true) {

					//Testcode 
					wsprintf(g_cTxt, "Client Timeout: %s (%s)", m_pClientList[i]->m_cCharName ,m_pClientList[i]->m_cIPaddress);
					PutLogList(g_cTxt);

					DeleteClient(i, true, true);
				}
				else {
					DeleteClient(i, false, false); 
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete == true) {
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;


				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;

				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == false)) {

					if ((m_pClientList[i]->m_iLevel < LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 )) {
					}
					else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;

					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30) ) {
						SendNotifyMsg(NULL, i, NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}

				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)_s;
				else iPlusTime = 0;

				iPlusTime = abs(iPlusTime);


				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (uint32)(HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}


				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (uint32)(MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}


				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (uint32)(SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}


				if ((m_pClientList[i]->m_bIsPoisoned == true) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}

				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == false) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (uint32)AUTOSAVETIME)) 
				{
					m_pClientList[i]->Save();
				}


				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (uint32)EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					CheckHeldenianResultCalculation(i);
				}


				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (uint32)AUTOEXPTIME) {

					iValue = (m_pClientList[i]->m_iLevel);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							GetExp(i, iValue);
							CalcExpStock(i);
						}
					}

					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}


				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					SendNotifyMsg(NULL, i, NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

					short sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[EQUIPPOS_RHAND];
					if (sItemIndex != -1) { //Notify player Res available if possible
						if (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS10 || 
							m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS20) {
							if(m_pClientList[i]->GetInt() >= 100 && m_pClientList[i]->GetMag() >= 100){
								m_pClientList[i]->m_cMagicMastery[94] = true; //Resurrection
								SendNotifyMsg(NULL, i, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;


				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == true) {
					if (((dwTime - m_pClientList[i]->m_specialAbilityStartTime)/1000) > m_pClientList[i]->m_specialAbilityLastSec) {

						SendNotifyMsg(NULL, i, NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = false;

						m_pClientList[i]->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}


				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;

				if ( (m_pClientList[i]->m_bIsWarLocation == true) ) {
					// Crusade
					if ((m_bIsCrusadeMode == false) || (m_pClientList[i]->m_bIsInBuilding == true))
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = false;

						SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, 0);
					}
				}
				
				if (m_pClientList[i] == NULL) break;
				if (   (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == true) 
					&& (m_bIsApocalypseMode == false)
					&& (m_pClientList[i]->m_iAdminUserLevel == 0))
				{	m_pClientList[i]->m_bIsWarLocation = true;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;				
				}
					Use_ApocalypseGate(i);	

				if(m_pClientList[i]->m_cMapIndex == m_iAstoriaMapIndex && !m_astoria.get())
				{
					SYSTEMTIME currTime;
					GetLocalTime(&currTime);

					if((currTime.wDayOfWeek == FRIDAY ||
						currTime.wDayOfWeek == SATURDAY ||
						currTime.wDayOfWeek == SUNDAY) && !m_pClientList[i]->IsGM())
					{
						SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, 0);
					}
				}

				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 4) {
					//PutLogFileList(g_cTxt);
					DeleteClient(i, true, true);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				if (m_pClientList[i] == NULL) break;


				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, 0);
				}

				if (m_pClientList[i] == NULL) break;


				if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					(m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
						SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, 0);
				}

				/*		if (m_pClientList[i] == NULL) break;

				if ((memcmp(m_pClientList[i]->m_cLocation, "NONE",4) == 0) &&
				(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0)) {

				SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, 0);
				} */




				/*
				if (m_pClientList[i] == NULL) break;
				if ((m_pClientList[i]->m_dwFightzoneDeadTime != NULL) && 
				((dwTime - m_pClientList[i]->m_dwFightzoneDeadTime) > 1000*30)) {

				m_pClientList[i]->m_dwFightzoneDeadTime = NULL;
				ResurrectPlayer(i);
				}
				*/

				if (m_pClientList[i] == NULL) break;

				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) {

					m_pClientList[i]->m_iSuperAttackCount = 0;
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;

					SendNotifyMsg(NULL, i, NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}


				m_pClientList[i]->m_iTimeLeft_FirmStamina--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStamina < 0) m_pClientList[i]->m_iTimeLeft_FirmStamina = 0;


				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == true) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}
//==============================================================================
bool CGame::bSendMsgToLS(uint32 dwMsg, int iClientH, bool bFlag,char * pData, uint32 v1, uint32 v2)
{
	uint32 * dwp;
	uint16  * wp;
	BYTE  * bp;
	int     iRet, i, iSize;
	char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
	char    cGuildLoc[11], cTemp[120];
	int   * ip, iSendSize;

	CClient * player = NULL;
	if(iClientH != NULL)
		player = m_pClientList[iClientH];

	/*
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	iCnt = 0;
	bLoopFlag = false;
	while (bLoopFlag == false) {
	if (m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) 
	bLoopFlag = true;
	else m_iCurSubLogSockIndex++;

	iCnt++;
	if (iCnt >= MAXSUBLOGSOCK) {

	if (m_bOnExitProcess == false) {
	m_cShutDownCode      = 3;
	m_bOnExitProcess     = true;
	m_dwExitProcessTime  = timeGetTime();

	PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
	}
	return false;
	}
	}
	*/



	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	switch (dwMsg)
	{
	case MSGID_SERVERSTOCKMSG:
		if (_bCheckSubLogSocketIndex() == false) return false;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(pData, m_iIndexGSS+1);
		if (iRet == -1) return false;
		break;

	case MSGID_GAMESERVERALIVE:
		if(!m_bIsGameStarted) return false;
		if (_bCheckSubLogSocketIndex() == false) return false;
		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp  = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		wp  = (uint16 *)cp;
		*wp = m_iTotalClients;
		cp += 2;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 8);
		if (iRet == -1) return false;
		break;

	case MSGID_ITEMLOG:
		if (_bCheckSubLogSocketIndex() == false) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 53);
		break;

	case MSGID_SENDSERVERSHUTDOWNMSG:
		/*if (m_pMainLogSock == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);*/
		break;

	case MSGID_GAMESERVERSHUTDOWNED:
		if (_bCheckSubLogSocketIndex() == false) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6);
		return true;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:

		if (_bCheckSubLogSocketIndex() == false) return false;

		if (player == NULL) return false;
		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cp, player->m_cAccountName, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = player->m_iLevel;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:

		if (_bCheckSubLogSocketIndex() == false) return false;

		if (player == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cp, player->m_cAccountName, 10);
		cp += 10;

		memcpy(cp, player->m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cServerName, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		player->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;

		wsprintf(g_cTxt, "Enter Game: %s(%d)", player->m_cCharName, player->m_iLevel);
		PutLogList(g_cTxt);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;

	case MSGID_REQUEST_REGISTERGAMESERVER:

		wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		PutLogList(cTxt);

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		if (m_iGameServerMode == 1) // LAN
			SafeCopy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
		else // INTERNET
			SafeCopy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		
		SafeCopy(cp, m_cServerName, 10);
		cp += 10;

		SafeCopy(cp, cAddress, 16);
		cp += 16;

		wp  = (uint16 *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		bp  = (BYTE *)cp;
		*bp = ReceivedAllConfig;
		cp++;

		*cp = m_iTotalMaps;
		cp++;

		wp  = (uint16 *)cp;
		*wp = GSID;
		cp += 2;

		for (i = 0; i < m_iTotalMaps; i++) {
			SafeCopy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + m_iTotalMaps*11);
		return true;

	case MSGID_REQUEST_REGISTERGAMESERVERSOCKET:
		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVERSOCKET;
		wp  = (uint16 *)(G_cData50000 + 4);
		*wp = GSID;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6);
		wsprintf(cTxt, "(!) Try to register game server socket(%d) on ID[%u]",m_iCurSubLogSockIndex, GSID);
		PutLogList(cTxt);
		return true;

	case MSGID_REQUEST_PLAYERDATA:

		if (_bCheckSubLogSocketIndex() == false) return false;
		if (player == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		//testcode
		if (strlen(player->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

		memcpy(cCharName, player->m_cCharName, 10);
		memcpy(cAccountName, player->m_cAccountName, 10);
		memcpy(cAccountPassword, player->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, player->m_cIPaddress, 15);
		cp += 15;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;
		//Crusade 
		/*
		case MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA:


		if (_bCheckSubLogSocketIndex() == false) return false;

		if (m_iMiddlelandMapIndex < 0) return false;

		//testcode
		PutLogList("(!) Middleland Aresden OccupyFlag data saved.");

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 1);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;

		case MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA:


		if (_bCheckSubLogSocketIndex() == false) return false;

		if (m_iMiddlelandMapIndex < 0) return false;

		//testcode
		PutLogList("(!) Middleland Elvine OccupyFlag data saved.");

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);
		iSize = _iComposeFlagStatusContents(cp, 2);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize + 10);
		iSendSize = 6 + iSize + 10;
		break;
		*/
	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		if (_bCheckSubLogSocketIndex() == false) return false;
		if (player == NULL) return false;
		if (strlen(player->m_cCharName) == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		SafeCopy(cp, player->m_cCharName);
		cp += 10;

		SafeCopy(cp, player->m_cAccountName);
		cp += 10;

		SafeCopy(cp, player->m_cAccountPassword);
		cp += 10;

		*cp = (char)bFlag;
		cp++;

		iSize = _iComposePlayerDataFileContents(iClientH, cp);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		iSendSize = 37 + iSize;
		break;

	case MSGID_REQUEST_NOSAVELOGOUT:

		if (_bCheckSubLogSocketIndex() == false) return false;
		if (player == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, player->m_cCharName, 10);
		memcpy(cAccountName, player->m_cAccountName, 10);
		memcpy(cAccountPassword, player->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		*cp = (char)bFlag; 
		cp++;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;

	case MSGID_REQUEST_CREATENEWGUILD:

		if (_bCheckSubLogSocketIndex() == false) return false;
		if (player == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, player->m_cCharName, 10);
		memcpy(cAccountName, player->m_cAccountName, 10);
		memcpy(cAccountPassword, player->m_cAccountPassword, 10);
		memcpy(cGuildName, player->m_cGuildName, 20);
		memcpy(cGuildLoc, player->m_cLocation, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = player->m_iGuildGUID;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_DISBANDGUILD:

		if (_bCheckSubLogSocketIndex() == false) return false;
		if (player == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, player->m_cCharName, 10);
		memcpy(cAccountName, player->m_cAccountName, 10);
		memcpy(cAccountPassword, player->m_cAccountPassword, 10);
		memcpy(cGuildName, player->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		if (_bCheckSubLogSocketIndex() == false) return false;
		if (player == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, player->m_cCharName, 10);
		memcpy(cGuildName, player->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		if (_bCheckSubLogSocketIndex() == false) return false;
		if (player == NULL) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cCharName, player->m_cCharName, 10);
		memcpy(cGuildName, player->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_GAMEMASTERLOG:
	case MSGID_GAMEITEMLOG:
	case MSGID_GAMECRUSADELOG:
		if (_bCheckSubLogSocketIndex() == false) return false;
		if (pData == NULL) return false ;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	case MSGID_REQ_RETRIEVEMAILITEM:
		if (_bCheckSubLogSocketIndex() == false) return false;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(pData, 6 + 4 + sizeof(ItemUID) + 2 + 4);
		break;

	case MSGID_REQ_MAILBOX:
	case MSGID_REQ_MAILDATA:
		if (_bCheckSubLogSocketIndex() == false) return false;
		
		cp = G_cData50000;
		Push(cp, dwMsg);
		Push(cp, (uint16)0);

		Push(cp, (uint16)iClientH);
		Push(cp, (uint32)v1); // charid
		Push(cp, (uint32)v2);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, cp - G_cData50000);
		break;

	case MSGID_REQ_DELETEMAIL:
		if (_bCheckSubLogSocketIndex() == false) return false;
		
		cp = G_cData50000;
		Push(cp, dwMsg);
		Push(cp, (uint16)0);

		Push(cp, (uint32)v1); // charid
		Push(cp, (uint32)v2);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, cp - G_cData50000);
		break;
				
	case MSGID_REQ_SENDMAIL:
		if (_bCheckSubLogSocketIndex() == false) return false;

		cp = (char*)(pData + v1);
		Push(cp, player->m_cCharName, 10);
		Push(cp, (uint16)iClientH);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(pData, cp - pData);
		break;
		
	case MSGID_REQ_GUILDBOARD:
	case MSGID_REQ_GUILDPOSTDATA:
		if (_bCheckSubLogSocketIndex() == false) return false;
		
		cp = G_cData50000;
		Push(cp, dwMsg);
		Push(cp, (uint16)0);

		Push(cp, (uint16)iClientH);
		Push(cp, (uint16)player->m_guild->m_guildGUID);
		Push(cp, (uint32)v1);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, cp - G_cData50000);
		break;

	case MSGID_REQ_DELETEGUILDPOST:
		if (_bCheckSubLogSocketIndex() == false) return false;
		
		cp = G_cData50000;
		Push(cp, dwMsg);
		Push(cp, (uint16)0);

		Push(cp, (uint16)player->m_guild->m_guildGUID);
		Push(cp, (uint32)v1);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, cp - G_cData50000);
		break;

	case MSGID_REQ_POSTGUILDBOARD:
		if (_bCheckSubLogSocketIndex() == false) return false;
		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = NULL;

		cp = (char*)(pData + v1);
		Push(cp, player->m_cCharName, 10);
		Push(cp, (uint16)iClientH);
		Push(cp, (uint16)player->m_guild->m_guildGUID);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(pData, cp - pData);
		break;

	case MSGID_REQUEST_LGNPTS:
		if (_bCheckSubLogSocketIndex() == false) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = NULL;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		wp = (uint16 *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, player->m_cAccountName, 10);
		cp += 10;

		iSendSize = 18;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;

	case MSGID_REQUEST_LGNSVC:
		if (_bCheckSubLogSocketIndex() == false) return false;

		memcpy(G_cData50000, pData, 6);

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		wp = (uint16 *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, player->m_cAccountName, 10);
		cp += 10;

		iSendSize = 18;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;

	case MSGID_SUBCASH:		
		if (_bCheckSubLogSocketIndex() == false) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = NULL;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cp, pData, 12);

		iSendSize = 18;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;

	case MSGID_ADDCASH:		
		if (_bCheckSubLogSocketIndex() == false) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (uint16 *)(G_cData50000 + INDEX2_MSGTYPE);
		*wp  = NULL;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE + 2);

		memcpy(cp, pData, 12);

		iSendSize = 18;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;

	case MSGID_REQUEST_LOAD_GUILDINFO:
		if (_bCheckSubLogSocketIndex() == false) return false;
		if(!player || player->m_iGuildGUID == -1) return false;

		dwp  = (uint32 *)(G_cData50000 + INDEX4_MSGID);
		*dwp = dwMsg;
		dwp++;

		cp = (char *)(G_cData50000 + INDEX2_MSGTYPE);
		
		memcpy(cGuildName, player->m_cGuildName, 20);
		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		Push(cp, (uint16)player->m_iGuildGUID);

		iSendSize = 26;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
		break;
	case MSGID_SAVE_GUILDINFO:
		if (_bCheckSubLogSocketIndex() == false) return false;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(pData, v1);
		break;

	case MSGID_CONFIRMFORCELOGOUT:
		if (_bCheckSubLogSocketIndex() == false) return false;
		cp = G_cData50000;
		Push(cp, dwMsg);
		Push(cp, (uint16) NULL);
		Push(cp, pData, 10); //Account name
		iSendSize = 16;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

	case MSGID_GAMESERVERINITALIZED:
		if (_bCheckSubLogSocketIndex() == false) return false;
		cp = G_cData50000;
		Push(cp, dwMsg);
		Push(cp, (uint16) NULL);
		iSendSize = 6;
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);
	}

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:

		wsprintf(g_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(g_cTxt);
		PutLogFileList(g_cTxt);

		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = false;
		m_iSubLogSockActiveCount--;


		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(MSGBUFFERSIZE);

		wsprintf(g_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(g_cTxt);

		m_iSubLogSockFailCount++;

		if (_bCheckSubLogSocketIndex() == false) return false;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

		return false;
	}

	return true;
}



void CGame::ResponsePlayerDataHandler(char * pData, uint32 dwSize)
{
	uint16 * wp;
	uint32 * dwp ;
	char * cp, cCharName[11], cTxt[120];
	int  i; 

	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	for (i = 1; i < MAXCLIENTS; i++) 
		if (m_pClientList[i] != NULL) {
			if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
				wp = (uint16 *)(pData + INDEX2_MSGTYPE);
				switch (*wp) {
				case LOGRESMSGTYPE_CONFIRM:
					InitPlayerData(i, pData, dwSize); 
					break;

				case LOGRESMSGTYPE_REJECT:

					if( *cp == 1) {
						ZeroMemory(cTxt, sizeof(cTxt));
						dwp  = (uint32 *)(cTxt + INDEX4_MSGID);
						*dwp = MSGID_RESPONSE_INITPLAYER;
						wp   = (uint16 *)(cTxt + INDEX2_MSGTYPE);
						*wp  = MSGTYPE_REJECT;

						m_pClientList[i]->m_pXSock->iSendMsg(cTxt, 6); 
					}
					else {
						wsprintf(g_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
						PutLogList(g_cTxt);
						//PutLogFileList(g_cTxt); 

						DeleteClient(i, false, false);
					}
					break;
				}

				return;
			}
		}

		wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
		PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, uint32 dwSize)
{
	char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus;
	uint32 * dwp;
	uint16  * wp;
	int   * ip, i, iRet, iTotalItemA, iTotalItemB, iStats;
	bool    bRet, bFlag;
	char  * pBuffer = NULL;
	short * sp;
	
	CClient * player = m_pClientList[iClientH];

	if (!player) return;
	if (player->m_bIsInitComplete == true) return; 


	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	//player->m_cAccountStatus = *cp;
	cp++;

	cGuildStatus = *cp;
	cp++;

	player->m_iHitRatio		= 0;
	player->m_iDefenseRatio	= 0;
	player->m_side	= NEUTRAL;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	if (!bRet) {
		wsprintf(g_cTxt, "(HACK?) Character(%s) data error!", player->m_cCharName);
		DeleteClient(iClientH, false, true);
		return;
	}	

	//***************************************************************************

	if(!player->IsGM() && player->m_iLevel > PLAYERMAXLEVEL) {
		wsprintf(g_cTxt, "Hack: (%s) Player: (%s) High level hack (%i)", player->m_cIPaddress, player->m_cCharName, player->m_iLevel);
		PutLogFileList(g_cTxt, HACK_LOGFILE);
		PutLogList(g_cTxt);
		DeleteClient(iClientH, false, true, true, true);
		return;
	}

	objMgr.Add( player );

	if ((player->m_sX == -1) && (player->m_sY == -1)) {
		GetMapInitialPoint(player->m_cMapIndex, &player->m_sX, &player->m_sY, player->m_cLocation);
	}

	if(player->m_iPKCount > 0)
		player->SetStatusFlag(STATUS_PK, true);

	iSetSide(iClientH);

	player->m_iNextLevelExp = m_iLevelExpTable[player->m_iLevel + 1];

	CalcTotalItemEffect(iClientH, -1, true); //false
	iCalcTotalWeight(iClientH);
	_SendQuestContents(iClientH);

	player->ValidateSkills(true);
	CheckMagicInt(iClientH);

	if(player->IsGM())
	{
		player->m_GMFlags |= GMFLAG_INVINCIBLE | GMFLAG_NOAGGRO | GMFLAG_ETHEREAL;
		m_pClientList[iClientH]->Notify(NULL, NOTIFY_ADMININFO);
	}

	if ((cGuildStatus == 0) && (memcmp(player->m_cGuildName, "NONE", 4) != 0)) {
		ZeroMemory(player->m_cGuildName, sizeof(player->m_cGuildName));
		strcpy(player->m_cGuildName, "NONE");
		player->m_iGuildRank = GUILDRANK_NONE;
		player->m_iGuildGUID = -1;
		player->m_guild = NULL;

		SendNotifyMsg(NULL, iClientH, NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, player->m_cGuildName);
	}

	if (player == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	iRet = player->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:

		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);

		DeleteClient(iClientH, false, true); //!!!!!
		return;
	}

	player->m_bIsInitComplete = true;

	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	if(player->GetParty())
	{
		if (m_pMapList[player->m_cMapIndex]->m_isPartyDisabled && !player->IsGM())
		{
			partyMgr.RemoveFromParty( player );
		}
	}


	pBuffer = new char [MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, MSGBUFFERSIZE+1);

	dwp  = (uint32 *)(pBuffer + INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS;
	wp   = (uint16 *) (pBuffer + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetStr();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetInt();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetDex();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->GetMag();
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;

	iStats = (m_pClientList[iClientH]->GetBaseStr() + m_pClientList[iClientH]->GetBaseDex() + m_pClientList[iClientH]->m_iVit +  
		m_pClientList[iClientH]->GetBaseInt() + m_pClientList[iClientH]->GetBaseMag() + m_pClientList[iClientH]->m_iCharisma); 

	m_pClientList[iClientH]->m_iLU_Pool =  m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70);
	wp = (uint16 *)cp; 
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;


	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillTotalCount;
	cp  += 4;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 119);
	switch (iRet) 
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		if(pBuffer != NULL) delete[] pBuffer;
		return;
	}

	dwp  = (uint32 *)(pBuffer + INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (uint16 *) (pBuffer + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;


	iTotalItemA = 0;
	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			iTotalItemA++;


	bFlag = false;
	while (bFlag == false) {
		bFlag = true;
		for (i = 0; i < MAXITEMS-1; i++)
			if ((m_pClientList[iClientH]->m_pItemList[i] == NULL) && (m_pClientList[iClientH]->m_pItemList[i+1] != NULL)) {
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemList[i+1];
				m_pClientList[iClientH]->m_pItemList[i+1] = NULL;

				m_pClientList[iClientH]->m_ItemPosList[i].x = m_pClientList[iClientH]->m_ItemPosList[i+1].x;
				m_pClientList[iClientH]->m_ItemPosList[i].y = m_pClientList[iClientH]->m_ItemPosList[i+1].y;
				bFlag = false;
			}
	}


	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	CalcTotalItemEffect(iClientH, -1, false);

	cp = (char *)(pBuffer + INDEX2_MSGTYPE + 2);
	*cp = iTotalItemA;
	cp++;

	for(i = 0; i < iTotalItemA; i++) {
		CItem * item = m_pClientList[iClientH]->m_pItemList[i];
		if(!item) 
		{
			wsprintf(g_cTxt, "Player error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(g_cTxt);

			DeleteClient(iClientH, false, true);
			if(pBuffer != NULL) delete[] pBuffer;
			return;
		}
		memcpy(cp, item->m_cName, 20);
		cp += 20;
		dwp  = (uint32 *)cp;
		*dwp = item->m_dwCount;
		cp += 4;
		*cp = item->m_cItemType;
		cp++;
		*cp = item->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = item->m_sLevelLimit;
		cp += 2;
		*cp = item->m_cGenderLimit;
		cp++;
		wp = (uint16 *)cp;
		*wp = item->m_wCurLifeSpan;
		cp += 2;
		wp = (uint16 *)cp;
		*wp = item->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = item->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = item->m_sSpriteFrame;
		cp += 2;
		*cp = item->m_cItemColor; 
		cp++;
		*cp = (char)item->m_sItemSpecEffectValue2; 
		cp++;
		dwp =(uint32 *)cp;
		*dwp = item->m_dwAttribute;
		cp += 4;
		for(int j = 0; j < MAXITEMSOCKETS; j++)
		{
			Push(cp, item->m_sockets[j]);
		}
	}

	iTotalItemB = 0;
	for (i = 0; i < MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;

	for (i = 0; i < iTotalItemB; i++)
	{
		CItem * item = m_pClientList[iClientH]->m_pItemInBankList[i];
		if(!item) {
			wsprintf(g_cTxt, "Player error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(g_cTxt);

			DeleteClient(iClientH, false, true);
			if(pBuffer != NULL) delete[] pBuffer;
			return;
		}
		memcpy(cp, item->m_cName, 20);
		cp += 20;
		dwp  = (uint32 *)cp;
		*dwp = item->m_dwCount;
		cp += 4;
		*cp = item->m_cItemType;
		cp++;
		*cp = item->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = item->m_sLevelLimit;
		cp += 2;
		*cp = item->m_cGenderLimit;
		cp++;
		wp = (uint16 *)cp;
		*wp = item->m_wCurLifeSpan;
		cp += 2;
		wp = (uint16 *)cp;
		*wp = item->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = item->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = item->m_sSpriteFrame;
		cp += 2;
		*cp = item->m_cItemColor; 
		cp++;
		*cp = (char)item->m_sItemSpecEffectValue2; 
		cp++;
		dwp =(uint32 *)cp;
		*dwp = item->m_dwAttribute;
		cp += 4;
		for(int j = 0; j < MAXITEMSOCKETS; j++)
		{
			Push(cp, item->m_sockets[j]);
		}
	}

	for (i = 0; i < MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}

	for (i = 0; i < MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*(44 + MAXITEMSOCKETS) + iTotalItemB*(43+MAXITEMSOCKETS) + MAXMAGICTYPE + MAXSKILLTYPE);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		if(pBuffer != NULL) delete[] pBuffer;
		return;
	}

	PlayerMapEntry(iClientH);

	if(player->m_iGuildGUID != GUILDGUID_NONE)
	{
		CGuild * guild = guildMgr.FindGuild(player->m_iGuildGUID);

		if(guild)
		{
			guild->MemberLogin(player);
		}
		else
		{
			guildMgr.AddPendingMember(player);
			bSendMsgToLS(MSGID_REQUEST_LOAD_GUILDINFO, player->m_handle);
		}
	}

	if (m_astoria.get())
		SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTSTART, m_astoria->GetEventType(), NULL, NULL, NULL);

	if((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone ||
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap) &&
		!m_pClientList[iClientH]->IsGM())
	{
		uint32 allowedDCTime = 0;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) {
			allowedDCTime = 18 _s;
		} 
		else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap) {
			allowedDCTime = 3 _m;
		}

		bool toRecall = true;
		for(List<RecentDisconnect>::iterator it = m_recentDCs.begin();
			it != m_recentDCs.end(); ++it)
		{
			if(strcmp(it->playerName, player->m_cCharName) == 0) {
				uint32 dwTime = timeGetTime();  
				for(i = 0; i < 3; i++){
					if((dwTime - it->disconnectTimes[i]) < allowedDCTime){
						toRecall = false;
						break;
					}
				}
				if(toRecall)
					m_recentDCs.erase(it);
				break;
			}
		}
		if(toRecall) {
			RequestTeleportHandler(iClientH, 0);
		}
	}
	if(pBuffer != NULL) delete[] pBuffer;
	return;
}

bool CGame::bReadProgramConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "";
	char seps[] = "= \t\n", * urlDelimiter = "/";
	int webLen;
	
	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		//	PutLogList("(!) Cannot open configuration file.");
		return false;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) Game server name(%s) must be within 10 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Log server address(%s) must be within 15 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5:
					if (strlen(token) > 10) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must be within 10 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					if (_bRegisterMap(token) == false) {
						return false;
					}
					cReadMode = 0;
					break;

				case 6:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						wsprintf(cTxt, "(!!!) Game server address(%s) must be within 15 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 7:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8:
					ZeroMemory(m_websiteAddr, sizeof(m_websiteAddr));
					ZeroMemory(m_websiteScriptAddr, sizeof(m_websiteScriptAddr));
					if (strlen(token) >= 120) {
						wsprintf(cTxt, "(!!!) Website script url(%s) must be within 120 chars!", token);
						PutLogList(cTxt);
						return false;
					}
					strcpy(cTxt, token);
					webLen = strcspn(token, urlDelimiter);
					if (webLen == NULL || webLen > 60 || (strlen(token) - webLen) > 60){
						wsprintf(cTxt, "(!!!) Website script url(%s) is incorrectly formed!", token);
						PutLogList(cTxt);
						return false;
					}
					memcpy(m_websiteAddr, token, webLen);
					memcpy(m_websiteScriptAddr, token + webLen, strlen(token) - webLen);
					wsprintf(cTxt, "(*) Website address : %s", m_websiteAddr);
					PutLogList(cTxt);
					wsprintf(cTxt, "(*) Website script address : %s", m_websiteScriptAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;				
				case 9:
					m_websitePort = atoi(token);
					wsprintf(cTxt, "(*) Website port : %d", m_websitePort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 10:
					if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0))
					{	m_iGameServerMode = 1;
					memcpy(cGSMode, "LAN", 3);
					}
					if ((memcmp(token, "internet", 8) == 0) || (memcmp(token, "INTERNET", 8) == 0))
					{	m_iGameServerMode = 2;
					memcpy(cGSMode, "INTERNET", 8);
					}
					if (m_iGameServerMode == 0)
					{	wsprintf(cTxt, "(!!!) Game server mode(%s) must be either ROUTER/router/LAN/lan or INTERNET/internet", token);
					PutLogList(cTxt);
					return false;
					}
					wsprintf(cTxt, "(*) Game server mode : %s", cGSMode);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 11:
					ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
					if (strlen(token) > 15) 
					{	wsprintf(cTxt, "(!!!) External (Internet) Game server IP(%s) must within 15 chars!", token);
					PutLogList(cTxt);
					return false;
					}
					strcpy(m_cGameServerAddrExternal, token);
					wsprintf(cTxt, "(*) Game server IP : %s", m_cGameServerAddrExternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "log-server-port", 15) == 0)			cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
				if (memcmp(token, "website-script-address", 22) == 0)	cReadMode = 8;
				if (memcmp(token, "website-port", 12) == 0)				cReadMode = 9;
				if (memcmp(token, "server-mode", 11) == 0)				cReadMode = 10;
				if (memcmp(token, "game-server-address-ext", 23) == 0)	cReadMode = 11;
			}

			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return true;
}

bool CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32  dwFileSize;
	char * cp, * token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";
	int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Cannot open Crusade Schedule file.");
		return false;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete[] cp;
							return false;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != NULL) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate potion number.");
							delete[] cp;
							return false;
						}

						cReadModeB = 2;
						break;

					case 2:
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;


					case 3:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							return false;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							return false;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;

					case 5:
						if (_bGetIsStringIsNumber(token) == false) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete[] cp;
							return false;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				case 2: 
					m_iMaxGMGMana = atoi(token); 
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "Mana-Stone", 10) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
			}
			token = pStrTok->pGet();
		}

		delete[] cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return false;
		}
	}

	if (pFile != NULL) fclose(pFile);
	return true;
}



bool CGame::_bRegisterMap(char * pName)
{
	int i;
	char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < MAXMAPS; i++)
		if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
			wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
			PutLogList(cTxt);
			return false;
		}

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] == NULL) {
			m_pMapList[i] = (class CMap *)new class CMap(this);
			wsprintf(cTxt, "(*) Add map (%s)   - Loading map info files...", pName);
			PutLogList(cTxt);
			if (m_pMapList[i]->bInit(pName) == false) {
				wsprintf(cTxt, "(!!!) Data file loading fail!");
				PutLogList(cTxt);
				return false;
			}

		if ((m_iBtFieldMapIndex == -1) && (strcmp("BtField", pName) == 0))
			m_iBtFieldMapIndex = i;
		if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0)) m_iGodHMapIndex = i;

			if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
				m_iMiddlelandMapIndex = i;
			else if ((m_iAresdenMapIndex == -1) && (strcmp(sideMap[ARESDEN], pName) == 0)) 
				m_iAresdenMapIndex = i;
			else if ((m_iElvineMapIndex == -1) && (strcmp(sideMap[ELVINE], pName) == 0)) 
				m_iElvineMapIndex = i;
			else if ((m_iIstriaMapIndex == -1) && (strcmp(sideMap[ISTRIA], pName) == 0)) 
				m_iIstriaMapIndex = i;
			else if ((m_iAstoriaMapIndex == -1) && (strcmp("astoria", pName) == 0)) 
				m_iAstoriaMapIndex = i;

				m_iGodHMapIndex = i;
//wsprintf(cTxt, "m_iBtFieldMapIndex (%d) ", m_iBtFieldMapIndex);
//	 PutLogList(cTxt);
			m_iTotalMaps++;
			return true;
		}

	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
	PutLogList(cTxt);
	return false;
}

bool CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, uint32 dwSize)
{
	int    i, iNotUsedItemPrice;
	char   cTxt[200], ItemName[25], OriginBlockDate[25];
	BYTE   NItems, NBankItems;
	uint32  ItemCount;
	bool   IsItemEquipped;
	CItem * item;
	uint16   BankItemIndex, TotalSkillPoints, sTmpType, sTmpAppr1;

	iNotUsedItemPrice = 0;

	CClient * player = m_pClientList[iClientH];
	if(!player) return false;
	ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
	SafeCopy(player->m_cMapName, pData, 10);

	player->m_cMapIndex = (char) iGetMapIndex(player->m_cMapName);
	if (player->m_cMapIndex == -1)
	{
		wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", player->m_cCharName, player->m_cMapName);
		PutLogList(cTxt);
		return false;
	}
	player->m_sX = (short)wGetOffsetValue(pData, 10);
	player->m_sY = (short)wGetOffsetValue(pData, 12);
	player->m_cSex = (Sex)bGetOffsetValue(pData, 14);
	player->m_cSkin = bGetOffsetValue(pData, 15);
	player->m_cHairStyle = bGetOffsetValue(pData, 16);
	player->m_cHairColor = bGetOffsetValue(pData, 17);
	player->m_cUnderwear = bGetOffsetValue(pData, 18);
	ZeroMemory(player->m_cGuildName, sizeof(player->m_cGuildName));
	SafeCopy(player->m_cGuildName, pData+19, 20);
	player->m_iGuildRank = (signed char)bGetOffsetValue(pData, 39);
	player->m_iHP = dwGetOffsetValue(pData, 40);
	player->m_iLevel = wGetOffsetValue(pData, 44);
	player->SetStr( bGetOffsetValue(pData, 46), false );
	player->m_iVit = bGetOffsetValue(pData, 47);
	player->SetDex( bGetOffsetValue(pData, 48) );
	player->SetInt( bGetOffsetValue(pData, 49), false );
	player->SetMag( bGetOffsetValue(pData, 50) );
	player->m_iCharisma = bGetOffsetValue(pData, 51);
	player->m_iLuck = bGetOffsetValue(pData, 52);
	player->m_iExp = dwGetOffsetValue(pData, 53);
	for (i = 0; i < MAXMAGICTYPE; i++) player->m_cMagicMastery[i] = bGetOffsetValue(pData, 57+i) - 48;
	ZeroMemory(player->m_cLocation, sizeof(player->m_cLocation));
	SafeCopy(player->m_cLocation, pData+181, 10);
	//if (memcmp(player->m_cLocation+3,"hunter",6) == 0) player->m_bIsPlayerCivil = true;
	player->m_iMP = dwGetOffsetValue(pData, 191);
	player->m_iSP = dwGetOffsetValue(pData, 195);
	player->m_iLU_Pool = bGetOffsetValue(pData, 199);
	player->m_iEnemyKillCount = dwGetOffsetValue(pData, 200);
	player->m_iPKCount = (int)dwGetOffsetValue(pData, 204);
	player->m_iRewardGold = dwGetOffsetValue(pData, 208);
	for(BYTE b = 0; b < 24; b++)
	{
		player->m_cSkillMastery[b] = bGetOffsetValue(pData, (157+b));
		player->m_iSkillSSN[b] = dwGetOffsetValue(pData, (212+(b*4)));
	}
	player->m_iHungerStatus = bGetOffsetValue(pData, 312);
	player->m_iAdminUserLevel = bGetOffsetValue(pData, 313);
	player->m_iTimeLeft_ShutUp = dwGetOffsetValue(pData, 314);
	player->m_iTimeLeft_Rating = dwGetOffsetValue(pData, 318);
	player->m_reputation = (int)dwGetOffsetValue(pData, 322);
	player->m_iGuildGUID = (short)wGetOffsetValue(pData, 326);
	player->m_iDownSkillIndex = (signed char)bGetOffsetValue(pData, 330);
	player->m_charID = dwGetOffsetValue(pData, 331);
	player->m_sCharIDnum1 = (short)dwGetOffsetValue(pData, 335);
	player->m_sCharIDnum2 = (short)dwGetOffsetValue(pData, 339);
	player->m_sCharIDnum3 = (short)dwGetOffsetValue(pData, 343);
	ZeroMemory(OriginBlockDate, sizeof(OriginBlockDate));
	SafeCopy(OriginBlockDate, pData+347, 20);
	char seps[] = " :-";
	StrTok pStrTok(new CStrTok(OriginBlockDate, seps));
	player->m_iPenaltyBlockYear = atoi(pStrTok->pGet());
	player->m_iPenaltyBlockMonth = atoi(pStrTok->pGet());
	player->m_iPenaltyBlockDay = atoi(pStrTok->pGet());
	player->m_iQuest = wGetOffsetValue(pData, 367);
	player->m_iCurQuestCount = wGetOffsetValue(pData, 369);
	player->m_iQuestRewardType = (suint16)wGetOffsetValue(pData, 371);
	player->m_iQuestRewardAmount = dwGetOffsetValue(pData, 373);
	player->m_iContribution = dwGetOffsetValue(pData, 377);
	player->m_iQuestID = dwGetOffsetValue(pData, 381);
	player->m_bIsQuestCompleted = bGetOffsetValue(pData, 385) ? true : false;
	player->m_iTimeLeft_ForceRecall = dwGetOffsetValue(pData, 386);
	player->m_iTimeLeft_FirmStamina = dwGetOffsetValue(pData, 390);
	player->m_iSpecialEventID = dwGetOffsetValue(pData, 394);
	player->m_iSuperAttackLeft = wGetOffsetValue(pData, 398);
	player->m_iFightzoneNumber = bGetOffsetValue(pData, 400);
	player->m_iReserveTime = dwGetOffsetValue(pData, 401);
	player->m_iFightZoneTicketNumber = bGetOffsetValue(pData, 405);
	player->m_iSpecialAbilityTime = dwGetOffsetValue(pData, 406);
	player->m_iWarContribution = dwGetOffsetValue(pData, 410);
	ZeroMemory(player->m_cLockedMapName, sizeof(player->m_cLockedMapName));
	SafeCopy(player->m_cLockedMapName, pData+414, 10);
	player->m_iLockedMapTime = dwGetOffsetValue(pData, 424);
	player->m_iCrusadeDuty = bGetOffsetValue(pData, 428);

	if(m_bIsCrusadeMode && player->m_iCrusadeDuty == 3)
	{
		for(int i = 1; i < MAXCLIENTS; i++)
		{
			if(g_clientList[i] && g_clientList[i]->m_iCrusadeDuty == 3)
			{
				// there's already one commander
				player->m_iCrusadeDuty = 0;
			}
		}
	}

	player->m_iConstructionPoint = dwGetOffsetValue(pData, 429);
	player->m_dwCrusadeGUID = dwGetOffsetValue(pData, 433);
	player->m_iDeadPenaltyTime = dwGetOffsetValue(pData, 437);

	//uint32 partyid = dwGetOffsetValue(pData, 441);
	//if(partyid && partyMgr.PartyExists( partyid ))
	//{
	//	player->SetParty( partyMgr.GetParty(partyid) );
	//	player->GetParty()->AddPlayer( player );
	//}

	player->m_iGizonItemUpgradeLeft = wGetOffsetValue(pData, 445);
	player->m_elo = wGetOffsetValue(pData, 447);
	player->m_iEnemyKillTotalCount = dwGetOffsetValue(pData, 449);
	static long charIndexEnd = 453;

	for (i = 0; i < MAXITEMEQUIPPOS; i++) player->m_sItemEquipmentStatus[i] = -1;
	for (i = 0; i < MAXITEMS; i++) player->m_bIsItemEquipped[i] = false;
	NItems = bGetOffsetValue(pData, charIndexEnd);
	NBankItems = bGetOffsetValue(pData, (charIndexEnd+1 + (NItems*67)+1));
	if(NItems > MAXITEMS || NBankItems > MAXBANKITEMS) return false;
	if(NItems > 0)
		for(BYTE b = 0; b < NItems; b++)
		{
			uint16 IndexForItem = (charIndexEnd+1 + (b*67));
			ZeroMemory(ItemName, sizeof(ItemName));
			SafeCopy(ItemName, pData+IndexForItem, 20);
			item = player->m_pItemList[b] = new CItem;
			if(item->InitItemAttr(ItemName) == false)
			{
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", player->m_cCharName, ItemName);
				PutLogFileList(cTxt, ERROR_LOGFILE);
				SAFEDELETE(player->m_pItemList[b]);
				return false;
			}
			ItemCount = dwGetOffsetValue(pData, (IndexForItem+20));
			if(ItemCount < 0) ItemCount = 1;
			if(item->GetWeight(ItemCount) > _iCalcMaxLoad(iClientH) )
			{
				ItemCount = 1;
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "(!) Client(%s)-Item(%s) is too heavy.", player->m_cCharName, item->m_cName);
				PutLogFileList(cTxt, ERROR_LOGFILE);
				SAFEDELETE(player->m_pItemList[b]);
				return false;
			}
			item->m_dwCount = ItemCount;
			item->m_sTouchEffectType = wGetOffsetValue(pData, (IndexForItem+24));
			item->m_sTouchEffectValue1 = (short)dwGetOffsetValue(pData, (IndexForItem+26));
			item->m_sTouchEffectValue2 = (short)dwGetOffsetValue(pData, (IndexForItem+30));
			item->m_sTouchEffectValue3 = (short)dwGetOffsetValue(pData, (IndexForItem+34));
			item->m_cItemColor = bGetOffsetValue(pData, (IndexForItem+38));
			item->m_sItemSpecEffectValue1 = (short)wGetOffsetValue(pData, (IndexForItem+39));
			item->m_sItemSpecEffectValue2 = (short)wGetOffsetValue(pData, (IndexForItem+41));
			item->m_sItemSpecEffectValue3 = (short)wGetOffsetValue(pData, (IndexForItem+43));
			item->m_wCurLifeSpan = wGetOffsetValue(pData, (IndexForItem+45));
			item->m_dwAttribute = dwGetOffsetValue(pData, (IndexForItem+47));
			item->m_sockets[0] = bGetOffsetValue(pData, (IndexForItem+51));
			item->m_sockets[1] = bGetOffsetValue(pData, (IndexForItem+52));
			item->m_sockets[2] = bGetOffsetValue(pData, (IndexForItem+53));

			if(item->m_sTouchEffectType == ITET_UNIQUE_OWNER)
			{
				if((item->m_sTouchEffectValue1 != player->m_sCharIDnum1) ||
					(item->m_sTouchEffectValue2 != player->m_sCharIDnum2) ||
					(item->m_sTouchEffectValue3 != player->m_sCharIDnum3) )
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt,"(!) Player(%s) have Item(%s) with another owner ID-> [%d  %d  %d] - [%d  %d  %d]", player->m_cCharName, item->m_cName,
						item->m_sTouchEffectValue1, item->m_sTouchEffectValue2,
						item->m_sTouchEffectValue3, player->m_sCharIDnum1, player->m_sCharIDnum2,
						player->m_sCharIDnum3);
					PutLogList(cTxt);
				}
			}
			if(item->IsManued() && (item->m_sIDnum > ITEM_MAGICSAPPHIRE ||  item->m_sIDnum < ITEM_MAGINDIAMOND)) //Quick hack. TODO: Fix Endu for Magic jewels
				item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;
			if (((item->m_dwAttribute & 0xF0000000) >> 28) > 0) {
				switch (item->m_cCategory) 
				{
				case 5:
				case 6: 
					item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;
					break;
				}
			}
			item->AdjustByStat();

			if(item->m_wCurLifeSpan > item->m_wMaxLifeSpan) item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
			if((item->m_wCurLifeSpan == 0) && (item->m_sItemEffectType == ITEMEFFECTTYPE_ALTERITEMDROP))
			{
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "(!) Player(%s) has a Zemstone with lifespan = 0!", player->m_cCharName);
				PutLogFileList(cTxt, ERROR_LOGFILE);
				item->m_wCurLifeSpan = 1;
			}
			
			if (item->m_cItemType == ITEMTYPE_NOTUSED)
			{
				iNotUsedItemPrice += item->m_wPrice;
				SAFEDELETE(player->m_pItemList[b]);
			}
			else if(_bCheckDupItemID(item) == true)
			{
				_bItemLog(ITEMLOG_DUPITEMID, iClientH, NULL, item);
				iNotUsedItemPrice += item->m_wPrice;
				SAFEDELETE(player->m_pItemList[b]);
			}
			if(player->m_pItemList[b] != NULL)
			{
				IsItemEquipped = bGetOffsetValue(pData, (IndexForItem+54)) ? true : false;
				if(IsItemEquipped && item->m_cItemType == ITEMTYPE_EQUIP)
					player->m_bIsItemEquipped[b] = true;
			}
			if(player->m_bIsItemEquipped[b] == true && bEquipItemHandler(iClientH, b, false) == false) player->m_bIsItemEquipped[b] = false;
			player->m_ItemPosList[b].x = (int)wGetOffsetValue(pData, (IndexForItem+55));
			player->m_ItemPosList[b].y = (int)wGetOffsetValue(pData, (IndexForItem+57));
			item->ItemUniqueID = ullGetOffsetValue(pData, (IndexForItem+59));
			if (player->m_ItemPosList[b].y < -10) player->m_ItemPosList[b].y = -10;
		}
		BankItemIndex = (charIndexEnd+1 + (NItems*67)+1);
		if(NBankItems > 0)
			for(BYTE b = 0; b < NBankItems; b++)
			{
				uint16 IndexForItem = (BankItemIndex+1 + (b*62));
				ZeroMemory(ItemName, sizeof(ItemName));
				SafeCopy(ItemName, pData+IndexForItem, 20);
				item = player->m_pItemInBankList[b] = new CItem;
				if(item->InitItemAttr(ItemName) == false)
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is a non-existing item! Connection closed.", player->m_cCharName, ItemName);
					PutLogFileList(cTxt, ERROR_LOGFILE);
					SAFEDELETE(player->m_pItemInBankList[b]);
					return false;
				}
				ItemCount = dwGetOffsetValue(pData, (IndexForItem+20));
				if(ItemCount < 0) ItemCount = 1;
				if(item->GetWeight(ItemCount) > _iCalcMaxLoad(iClientH) ) //FIX: Break into smaller stacks possibly
				{
					ItemCount = 1;
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, "(!) Client(%s)-BankItem(%s) is too heavy.", player->m_cCharName, item->m_cName);
					PutLogFileList(cTxt, ERROR_LOGFILE);
					SAFEDELETE(player->m_pItemInBankList[b]);
					return false;
				}
				item->m_dwCount = ItemCount;
				item->m_sTouchEffectType = wGetOffsetValue(pData, (IndexForItem+24));
				item->m_sTouchEffectValue1 = (short)dwGetOffsetValue(pData, (IndexForItem+26));
				item->m_sTouchEffectValue2 = (short)dwGetOffsetValue(pData, (IndexForItem+30));
				item->m_sTouchEffectValue3 = (short)dwGetOffsetValue(pData, (IndexForItem+34));
				item->m_cItemColor = bGetOffsetValue(pData, (IndexForItem+38));
				item->m_sItemSpecEffectValue1 = (short)wGetOffsetValue(pData, (IndexForItem+39));
				item->m_sItemSpecEffectValue2 = (short)wGetOffsetValue(pData, (IndexForItem+41));
				item->m_sItemSpecEffectValue3 = (short)wGetOffsetValue(pData, (IndexForItem+43));
				item->m_wCurLifeSpan = wGetOffsetValue(pData, (IndexForItem+45));
				item->m_dwAttribute = dwGetOffsetValue(pData, (IndexForItem+47));
				item->m_sockets[0] = bGetOffsetValue(pData, (IndexForItem+51));
				item->m_sockets[1] = bGetOffsetValue(pData, (IndexForItem+52));
				item->m_sockets[2] = bGetOffsetValue(pData, (IndexForItem+53));
				item->ItemUniqueID = ullGetOffsetValue(pData, (IndexForItem+54));

				if(item->IsManued() && (item->m_sIDnum > ITEM_MAGICSAPPHIRE ||  item->m_sIDnum < ITEM_MAGINDIAMOND)) //Quick hack. TODO: Fix Endu for Magic jewels
					item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;

				int iValue = (item->m_dwAttribute & 0xF0000000) >> 28;
				if(iValue > 0)
				{
					switch (item->m_cCategory) {
					case 5:
					case 6:
						item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;
						break;
					}
				}
				item->AdjustByStat();
				if(item->m_wCurLifeSpan > item->m_wMaxLifeSpan)
					item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
				if((item->m_wCurLifeSpan == 0) && (item->m_sItemEffectType == ITEMEFFECTTYPE_ALTERITEMDROP))
				{
					ZeroMemory(cTxt, sizeof(cTxt));
					wsprintf(cTxt, "(!) Player(%s) has a Zemstone with lifespan = 0!", player->m_cCharName);
					PutLogFileList(cTxt, ERROR_LOGFILE);
					item->m_wCurLifeSpan = 1;
				}
				if(item->m_cItemType == ITEMTYPE_NOTUSED)
				{
					iNotUsedItemPrice += item->m_wPrice;
					SAFEDELETE(player->m_pItemInBankList[b]);
				}
				else if(_bCheckDupItemID(item) == true)
				{
					_bItemLog(ITEMLOG_DUPITEMID, iClientH, NULL, item);
					iNotUsedItemPrice += item->m_wPrice;
					SAFEDELETE(player->m_pItemInBankList[b]);
				}
			}
		uint16 InfoSize = (BankItemIndex + (NBankItems*62)+2);
		ZeroMemory(player->m_cProfile, sizeof(player->m_cProfile));
		SafeCopy(player->m_cProfile, pData+InfoSize, strlen(pData+InfoSize));

		bool bRet = m_pMapList[player->m_cMapIndex]->bIsValidLoc(player->m_sX, player->m_sY);
		if(bRet == false)
		{
			if ((player->m_sX != -1) || (player->m_sY != -1))
			{
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt, "Invalid location error! %s (%d, %d)", player->m_cCharName, player->m_sX, player->m_sY);
				PutLogFileList(cTxt, ERROR_LOGFILE);
				return false;
			}
		}
		
		if(!player->IsGM())
		{
			//if((player->m_iLU_Pool < 0) || (player->m_iLU_Pool > CHARPOINTLIMIT)) return false;
			if((player->GetBaseStr() < 10) || (player->GetBaseStr() > CHARPOINTLIMIT)) return false;
			if((player->GetBaseDex() < 10) || (player->GetBaseDex() > CHARPOINTLIMIT)) return false;
			if((player->m_iVit < 10) || (player->m_iVit > CHARPOINTLIMIT)) return false;
			if((player->GetBaseInt() < 10) || (player->GetBaseInt() > CHARPOINTLIMIT)) return false;
			if((player->GetBaseMag() < 10) || (player->GetBaseMag() > CHARPOINTLIMIT)) return false;
			if((player->m_iCharisma < 10) || (player->m_iCharisma > CHARPOINTLIMIT)) return false;
			//if((player->m_cAccountStatus != 2) && (player->m_iLevel > LEVELLIMIT)) return false;
		}
		if((CMisc::bCheckValidName(player->m_cCharName) == false) || (CMisc::bCheckValidName(player->m_cAccountName) == false)) return false;
		if(player->m_iPenaltyBlockYear != 0 && !IsDatePast(OriginBlockDate)) return false;
		if(player->m_iReserveTime != 0)
		{
			SYSTEMTIME SysTime;
			GetLocalTime(&SysTime);
			__int64 iDateSum1 = (__int64)player->m_iReserveTime;
			__int64 iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
			if(iDateSum2 >= iDateSum1)
			{
				SendNotifyMsg(NULL, i, NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
				player->m_iFightzoneNumber = 0;
				player->m_iReserveTime = 0;
				player->m_iFightZoneTicketNumber = 0;
			}
		}
		if(player->m_iAdminUserLevel < 0) player->m_iAdminUserLevel = 0;
		if(player->m_cSex == MALE) sTmpType = 1;
		else if(player->m_cSex == FEMALE) sTmpType = 4;
		switch (player->m_cSkin) {
		case 1:
			break;
		case 2:
			sTmpType += 1;
			break;
		case 3:
			sTmpType += 2;
			break;
		}
		if(player->m_iAdminUserLevel >= 10) sTmpType = player->m_iAdminUserLevel;
		sTmpAppr1 = (player->m_cHairStyle << 8) | (player->m_cHairColor << 4) | (player->m_cUnderwear);

		player->m_sType  = sTmpType;
		player->m_sAppr1 = sTmpAppr1;

		iCalcTotalWeight(iClientH);
		TotalSkillPoints = 0;
		for(int b = 0; b < 24; b++) TotalSkillPoints += player->m_cSkillMastery[b];

		if (player->m_sCharIDnum1 == 0) {
			int _i, _iTemp1, _iTemp2;
			short _sID1, _sID2, _sID3;

			_iTemp1 = 1;
			_iTemp2 = 1;
			for (_i = 0; _i < 10; _i++) {
				_iTemp1 += player->m_cCharName[_i];
				_iTemp2 += abs(player->m_cCharName[_i] ^ player->m_cCharName[_i]);
			}

			_sID1 = (short)timeGetTime(); 
			_sID2 = (short)_iTemp1; 
			_sID3 = (short)_iTemp2;

			player->m_sCharIDnum1 = _sID1;
			player->m_sCharIDnum2 = _sID2;
			player->m_sCharIDnum3 = _sID3;
		}

		player->m_iRewardGold += iNotUsedItemPrice;
		if (IsSame(player->m_cLocation, "NONE")) player->m_bIsNeutral = true;

		return true;
}
//=============================================================================
int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
	SYSTEMTIME SysTime;
	char  cTxt[30];
	int   i;
	BYTE  NItems, NBankItems;
	uint16  IndexForItem, Index;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	PutOffsetValue(pData, 0, WORDSIZE, SysTime.wYear);
	PutOffsetValue(pData, 2, BYTESIZE, SysTime.wMonth);
	PutOffsetValue(pData, 3, BYTESIZE, SysTime.wDay);
	PutOffsetValue(pData, 4, BYTESIZE, SysTime.wHour);
	PutOffsetValue(pData, 5, BYTESIZE, SysTime.wMinute);
	PutOffsetValue(pData, 6, BYTESIZE, SysTime.wSecond);
	ZeroMemory(pData+7, 10);
	SafeCopy(pData+7, m_pClientList[iClientH]->m_cLocation);
	ZeroMemory(pData+17, 10);
	SafeCopy(pData+17, m_pClientList[iClientH]->m_cMapName);
	PutOffsetValue(pData, 27, WORDSIZE, m_pClientList[iClientH]->m_sX);
	PutOffsetValue(pData, 29, WORDSIZE, m_pClientList[iClientH]->m_sY);
	ZeroMemory(pData+31, 10);
	if (m_pClientList[iClientH]->m_iGuildRank != GUILDRANK_NONE)
	{
		SafeCopy(pData+31, m_pClientList[iClientH]->m_cGuildName);
		PutOffsetValue(pData, 51, WORDSIZE, m_pClientList[iClientH]->m_iGuildGUID);
	}
	else
	{
		SafeCopy(pData+31, "NONE");
		PutOffsetValue(pData, 51, WORDSIZE, -1);
	}
	PutOffsetValue(pData, 53, WORDSIZE, m_pClientList[iClientH]->m_iGuildRank);
	if(m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP();
	PutOffsetValue(pData, 55, DWORDSIZE, m_pClientList[iClientH]->m_iHP);
	if(m_pClientList[iClientH]->m_iMP <= 0) m_pClientList[iClientH]->m_iMP = 30;
	PutOffsetValue(pData, 59, DWORDSIZE, m_pClientList[iClientH]->m_iMP);
	if(m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 20;
	PutOffsetValue(pData, 63, DWORDSIZE, m_pClientList[iClientH]->m_iSP);
	PutOffsetValue(pData, 67, WORDSIZE, m_pClientList[iClientH]->m_iLevel);
	PutOffsetValue(pData, 69, DWORDSIZE, m_pClientList[iClientH]->m_reputation);
	PutOffsetValue(pData, 73, BYTESIZE, m_pClientList[iClientH]->GetBaseStr());
	PutOffsetValue(pData, 74, BYTESIZE, m_pClientList[iClientH]->m_iVit);
	PutOffsetValue(pData, 75, BYTESIZE, m_pClientList[iClientH]->GetBaseDex());
	PutOffsetValue(pData, 76, BYTESIZE, m_pClientList[iClientH]->GetBaseInt());
	PutOffsetValue(pData, 77, BYTESIZE, m_pClientList[iClientH]->GetBaseMag());
	PutOffsetValue(pData, 78, BYTESIZE, m_pClientList[iClientH]->m_iCharisma);
	PutOffsetValue(pData, 79, BYTESIZE, m_pClientList[iClientH]->m_iLuck);
	PutOffsetValue(pData, 80, DWORDSIZE, m_pClientList[iClientH]->m_iExp);
	PutOffsetValue(pData, 84, DWORDSIZE, m_pClientList[iClientH]->m_iEnemyKillCount);
	PutOffsetValue(pData, 88, DWORDSIZE, m_pClientList[iClientH]->m_iPKCount);
	PutOffsetValue(pData, 92, DWORDSIZE, m_pClientList[iClientH]->m_iRewardGold);
	PutOffsetValue(pData, 96, BYTESIZE, m_pClientList[iClientH]->m_iDownSkillIndex);
	PutOffsetValue(pData, 97, DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum1);
	PutOffsetValue(pData, 101, DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum2);
	PutOffsetValue(pData, 105, DWORDSIZE, m_pClientList[iClientH]->m_sCharIDnum3);
	PutOffsetValue(pData, 109, BYTESIZE, m_pClientList[iClientH]->m_cSex);
	PutOffsetValue(pData, 110, BYTESIZE, m_pClientList[iClientH]->m_cSkin);
	PutOffsetValue(pData, 111, BYTESIZE, m_pClientList[iClientH]->m_cHairStyle);
	PutOffsetValue(pData, 112, BYTESIZE, m_pClientList[iClientH]->m_cHairColor);
	PutOffsetValue(pData, 113, BYTESIZE, m_pClientList[iClientH]->m_cUnderwear);
	PutOffsetValue(pData, 114, BYTESIZE, m_pClientList[iClientH]->m_iHungerStatus);
	PutOffsetValue(pData, 115, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	PutOffsetValue(pData, 119, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_Rating);
	PutOffsetValue(pData, 123, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	PutOffsetValue(pData, 127, DWORDSIZE, m_pClientList[iClientH]->m_iTimeLeft_FirmStamina);
	PutOffsetValue(pData, 131, BYTESIZE, m_pClientList[iClientH]->m_bIsBankModified);
	ZeroMemory(pData+132, 20);
	ZeroMemory(cTxt, sizeof(cTxt));
	wsprintf(cTxt, "%d-%d-%d 00:00:00", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	SafeCopy(pData+132, cTxt);
	PutOffsetValue(pData, 152, WORDSIZE, m_pClientList[iClientH]->m_iQuest);
	PutOffsetValue(pData, 154, WORDSIZE, m_pClientList[iClientH]->m_iQuestID);
	PutOffsetValue(pData, 156, WORDSIZE, m_pClientList[iClientH]->m_iCurQuestCount);
	PutOffsetValue(pData, 158, WORDSIZE, m_pClientList[iClientH]->m_iQuestRewardType);
	PutOffsetValue(pData, 160, DWORDSIZE, m_pClientList[iClientH]->m_iQuestRewardAmount);
	PutOffsetValue(pData, 164, DWORDSIZE, m_pClientList[iClientH]->m_iContribution);
	PutOffsetValue(pData, 168, DWORDSIZE, m_pClientList[iClientH]->m_iWarContribution);
	PutOffsetValue(pData, 172, BYTESIZE, m_pClientList[iClientH]->m_bIsQuestCompleted);
	PutOffsetValue(pData, 173, DWORDSIZE, m_pClientList[iClientH]->m_iSpecialEventID);
	PutOffsetValue(pData, 177, WORDSIZE, m_pClientList[iClientH]->m_iSuperAttackLeft);
	PutOffsetValue(pData, 179, BYTESIZE, m_pClientList[iClientH]->m_iFightzoneNumber);
	PutOffsetValue(pData, 180, DWORDSIZE, m_pClientList[iClientH]->m_iReserveTime);
	PutOffsetValue(pData, 184, BYTESIZE, m_pClientList[iClientH]->m_iFightZoneTicketNumber);
	PutOffsetValue(pData, 185, DWORDSIZE, m_pClientList[iClientH]->m_iSpecialAbilityTime);
	ZeroMemory(pData+189, 10);
	SafeCopy(pData+189, m_pClientList[iClientH]->m_cLockedMapName);
	PutOffsetValue(pData, 199, DWORDSIZE, m_pClientList[iClientH]->m_iLockedMapTime);
	PutOffsetValue(pData, 203, BYTESIZE, m_pClientList[iClientH]->m_iCrusadeDuty);
	PutOffsetValue(pData, 204, DWORDSIZE, m_pClientList[iClientH]->m_dwCrusadeGUID);
	PutOffsetValue(pData, 208, DWORDSIZE, m_pClientList[iClientH]->m_iConstructionPoint);
	PutOffsetValue(pData, 212, DWORDSIZE, m_pClientList[iClientH]->m_iDeadPenaltyTime);
	PutOffsetValue(pData, 216, DWORDSIZE, 0);
	PutOffsetValue(pData, 220, WORDSIZE, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	PutOffsetValue(pData, 222, DWORDSIZE, m_pClientList[iClientH]->m_iSpecialAbilityTime);
	PutOffsetValue(pData, 226, WORDSIZE, m_pClientList[iClientH]->m_sAppr1);
	PutOffsetValue(pData, 230, WORDSIZE, m_pClientList[iClientH]->m_sAppr2);
	PutOffsetValue(pData, 234, WORDSIZE, m_pClientList[iClientH]->m_sAppr3);
	PutOffsetValue(pData, 238, WORDSIZE, m_pClientList[iClientH]->m_sAppr4);
	PutOffsetValue(pData, 242, DWORDSIZE, m_pClientList[iClientH]->m_iApprColor);
	PutOffsetValue(pData, 246, WORDSIZE, m_pClientList[iClientH]->m_elo);
	PutOffsetValue(pData, 248, DWORDSIZE, m_pClientList[iClientH]->m_iEnemyKillTotalCount);

	static long charIndexEnd = 252;
	for (i = 0; i < MAXMAGICTYPE; i++) PutOffsetValue(pData, charIndexEnd+i, BYTESIZE, m_pClientList[iClientH]->m_cMagicMastery[i]+48);
	for (i = 0; i < 24; i++){
		PutOffsetValue(pData, charIndexEnd+100+i, BYTESIZE, m_pClientList[iClientH]->m_cSkillMastery[i]);
		PutOffsetValue(pData, charIndexEnd+124+(i*4),DWORDSIZE, m_pClientList[iClientH]->m_iSkillSSN[i]);
	}

	NItems = 0;
	NBankItems = 0;

	for(i = 0; i < MAXITEMS; i++)
	{
		CItem * item = m_pClientList[iClientH]->m_pItemList[i];

		if(!item)
			continue;

		if(item->m_disabled)
		{
			//sprintf(
			ERR(string("Attempt at saving disabled item. ") + item->Dump());
			continue;
		}

		IndexForItem = (charIndexEnd+225 + (NItems*67));//475
		ZeroMemory(pData+IndexForItem, 20);
		SafeCopy(pData+IndexForItem, item->m_cName);
		PutOffsetValue(pData, (IndexForItem+20), DWORDSIZE, item->m_dwCount);
		PutOffsetValue(pData, (IndexForItem+24), WORDSIZE, item->m_sTouchEffectType);
		PutOffsetValue(pData, (IndexForItem+26), DWORDSIZE, item->m_sTouchEffectValue1);
		PutOffsetValue(pData, (IndexForItem+30), DWORDSIZE, item->m_sTouchEffectValue2);
		PutOffsetValue(pData, (IndexForItem+34), DWORDSIZE, item->m_sTouchEffectValue3);
		PutOffsetValue(pData, (IndexForItem+38), BYTESIZE, item->m_cItemColor);
		PutOffsetValue(pData, (IndexForItem+39), WORDSIZE, item->m_sItemSpecEffectValue1);
		PutOffsetValue(pData, (IndexForItem+41), WORDSIZE, item->m_sItemSpecEffectValue2);
		PutOffsetValue(pData, (IndexForItem+43), WORDSIZE, item->m_sItemSpecEffectValue3);
		PutOffsetValue(pData, (IndexForItem+45), WORDSIZE, item->m_wCurLifeSpan);
		PutOffsetValue(pData, (IndexForItem+47), DWORDSIZE, item->m_dwAttribute);
		PutOffsetValue(pData, (IndexForItem+51), BYTESIZE, item->m_sockets[0]);
		PutOffsetValue(pData, (IndexForItem+52), BYTESIZE, item->m_sockets[1]);
		PutOffsetValue(pData, (IndexForItem+53), BYTESIZE, item->m_sockets[2]);
		PutOffsetValue(pData, (IndexForItem+54), BYTESIZE, m_pClientList[iClientH]->m_bIsItemEquipped[i]);
		PutOffsetValue(pData, (IndexForItem+55), WORDSIZE, m_pClientList[iClientH]->m_ItemPosList[i].x);
		PutOffsetValue(pData, (IndexForItem+57), WORDSIZE, m_pClientList[iClientH]->m_ItemPosList[i].y);
		PutOffsetValue(pData, (IndexForItem+59), I64SIZE, item->ItemUniqueID);
		NItems++;
	}
	PutOffsetValue(pData, charIndexEnd+224, BYTESIZE, NItems);

	Index = charIndexEnd+225+(NItems*67);
	if(m_pClientList[iClientH]->m_bIsBankModified)
	{
		for(i = 0; i < MAXBANKITEMS; i++)
		{
			CItem * item = m_pClientList[iClientH]->m_pItemInBankList[i];

			if(!item)
				continue;

			if(item->m_disabled)
			{
				//sprintf(
				ERR(string("Attempt at saving disabled WH item. ") + item->Dump());
				continue;
			}

			IndexForItem = (Index+1+(NBankItems*62));
			ZeroMemory(pData+IndexForItem, 20);
			SafeCopy(pData+IndexForItem, item->m_cName);
			PutOffsetValue(pData, (IndexForItem+20), DWORDSIZE, item->m_dwCount);
			PutOffsetValue(pData, (IndexForItem+24), WORDSIZE, item->m_sTouchEffectType);
			PutOffsetValue(pData, (IndexForItem+26), DWORDSIZE, item->m_sTouchEffectValue1);
			PutOffsetValue(pData, (IndexForItem+30), DWORDSIZE, item->m_sTouchEffectValue2);
			PutOffsetValue(pData, (IndexForItem+34), DWORDSIZE, item->m_sTouchEffectValue3);
			PutOffsetValue(pData, (IndexForItem+38), BYTESIZE, item->m_cItemColor);
			PutOffsetValue(pData, (IndexForItem+39), WORDSIZE, item->m_sItemSpecEffectValue1);
			PutOffsetValue(pData, (IndexForItem+41), WORDSIZE, item->m_sItemSpecEffectValue2);
			PutOffsetValue(pData, (IndexForItem+43), WORDSIZE, item->m_sItemSpecEffectValue3);
			PutOffsetValue(pData, (IndexForItem+45), WORDSIZE, item->m_wCurLifeSpan);
			PutOffsetValue(pData, (IndexForItem+47), DWORDSIZE, item->m_dwAttribute);
			PutOffsetValue(pData, (IndexForItem+51), BYTESIZE, item->m_sockets[0]);
			PutOffsetValue(pData, (IndexForItem+52), BYTESIZE, item->m_sockets[1]);
			PutOffsetValue(pData, (IndexForItem+53), BYTESIZE, item->m_sockets[2]);
			PutOffsetValue(pData, (IndexForItem+54), I64SIZE, item->ItemUniqueID);

			NBankItems++;
		}
	}
	PutOffsetValue(pData, Index, BYTESIZE, NBankItems);
	Index += (NBankItems*62)+1;
	if(strlen(m_pClientList[iClientH]->m_cProfile) == 0){
		SafeCopy(pData+Index, "__________");
		return (Index+12);
	}
	else{
		SafeCopy(pData+Index, m_pClientList[iClientH]->m_cProfile);
		return (Index+2+strlen(m_pClientList[iClientH]->m_cProfile)+1);
	}
}
//=============================================================================
bool CGame::_bDecodeItemConfigFileContents(char * pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iItemConfigListIndex, iTemp;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete[] pContents;
						return false;
					}
					iItemConfigListIndex = atoi(token);

					if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB++;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB++;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB++;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB++;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB++;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB++;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB++;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB++;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB++;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB++;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB++;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (uint16)atoi(token);
					cReadModeB++;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB++;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB++;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB++;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete[] pContents;
						return false;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = false;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = true;

					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB++;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB++;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB++;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB++;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB++;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB++;
					break;

				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB++; 
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB++;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB++;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB++;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete[] pContents;
						return false;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeB++;
					break;
				case 27:
					// m_isLogged		
					if( strcmp(token,"FALSE") == 0 )
						m_pItemConfigList[iItemConfigListIndex]->m_isLogged = false;
					else if( strcmp(token,"TRUE") == 0 )
						m_pItemConfigList[iItemConfigListIndex]->m_isLogged = true;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Is logged");
						delete[] pContents;
						return false;
					}
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}

DICFC_STOPDECODING:;

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);

	// 2002-09-09 #1
	m_bReceivedItemList = true;

	return true;
}

bool CGame::_bGetIsStringIsNumber(char * pStr)
{
	int i;
	for (i = 0; i < (int)strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return false;

	return true;
}

CNpc * CGame::CreateNpc(char * pNpcName, int mapIndex, char cSA, char cMoveType, int * poX, int * poY, Side changeSide, char * pWaypointList, RECT * pArea, int iSpotMobIndex, bool bHideGenMode, bool bIsSummoned, bool bFirmBerserk, bool bIsMaster, int iGuildGUID)
{
	int i, t, j, k;
	char cTxt[120];
	short sX, sY, sRange;
	bool  bFlag;
	SYSTEMTIME SysTime;

	if(strlen(pNpcName) == 0 || !m_pMapList[mapIndex]) return NULL;

	GetLocalTime(&SysTime);

	for (i = 1; i < MAXNPCS; i++)
	{
		if(m_pNpcList[i]) 
			continue;

		switch(cSA)
		{
		case 9:
			m_pNpcList[i] = (CNpc*)(new CHTNpc(i));
			break;
		case 10:
			m_pNpcList[i] = (CNpc*)(new CElite(i));
			break;
		default:
			m_pNpcList[i] = new CNpc(i);
			break;
		}
		CNpc * npc = m_pNpcList[i];

		if (!npc->initNpcAttr(pNpcName, cSA) )
		{
			wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);

			delete npc;
			m_pNpcList[i] = NULL;
			return false;
		}

		if (npc->m_cDayOfWeekLimit < 10) 
		{
			if (npc->m_cDayOfWeekLimit != SysTime.wDayOfWeek) 
			{
				delete npc;
				m_pNpcList[i] = NULL;
				return false;
			}
		}

		switch (cMoveType) 
		{
		case MOVETYPE_GUARD:
		case MOVETYPE_RANDOM:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				sX = *poX;
				sY = *poY;
			}
			else {
				for ( j = 0; j <= 30; j++) 
				{
					sX = (rand() % (m_pMapList[mapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[mapIndex]->m_sSizeY - 50)) + 15;

					bFlag = true;
					for (k = 0; k < MAXMGAR; k++)
					{
						if (m_pMapList[mapIndex]->m_rcMobGenAvoidRect[k].left != -1)
						{
							if ((sX >= m_pMapList[mapIndex]->m_rcMobGenAvoidRect[k].left) &&
								(sX <= m_pMapList[mapIndex]->m_rcMobGenAvoidRect[k].right) &&
								(sY >= m_pMapList[mapIndex]->m_rcMobGenAvoidRect[k].top) &&
								(sY <= m_pMapList[mapIndex]->m_rcMobGenAvoidRect[k].bottom)) 
							{
								delete npc;
								m_pNpcList[i] = NULL;
								return false;
							}
						}
					}
				}
			}
			break;

		case MOVETYPE_RANDOMAREA:
			sRange = (short)(pArea->right - pArea->left);
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case MOVETYPE_RANDOMWAYPOINT:
			sX = (short)m_pMapList[mapIndex]->m_WaypointList[pWaypointList[dice(1,10) - 1]].x;
			sY = (short)m_pMapList[mapIndex]->m_WaypointList[pWaypointList[dice(1,10) - 1]].y;
			break;

		default:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				sX = *poX;
				sY = *poY;
			}
			else {
				sX = (short)m_pMapList[mapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[mapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}

		if (!bGetEmptyPosition(&sX, &sY, mapIndex) || 
			(bHideGenMode && getPlayerNum(mapIndex, sX, sY, 7) > 0)) 
		{
			delete npc;
			m_pNpcList[i] = NULL;
			return false;
		}

		if ((poX != NULL) && (poY != NULL)) {
			*poX = sX;
			*poY = sY;
		}

		npc->m_sX = sX;
		npc->m_sY = sY;

		npc->m_vX = sX;
		npc->m_vY = sY;

		for (t = 0; t < 10; t++)
			npc->m_iWayPointIndex[t] = pWaypointList[t];

		npc->m_cTotalWaypoint = 0;
		for (t = 0; t < 10; t++)
			if (npc->m_iWayPointIndex[t] != -1) npc->m_cTotalWaypoint++;

		if (pArea != NULL) {
			// RANDOMAREA Copy
			SetRect(&npc->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}

		switch (cMoveType) 
		{
		case MOVETYPE_GUARD:
			npc->m_dX = npc->m_sX;
			npc->m_dY = npc->m_sY;
			break;

		case MOVETYPE_SEQWAYPOINT: 
			npc->m_cCurWaypoint = 1;

			npc->m_dX  = (short)m_pMapList[mapIndex]->m_WaypointList[ npc->m_iWayPointIndex[ npc->m_cCurWaypoint ] ].x;
			npc->m_dY  = (short)m_pMapList[mapIndex]->m_WaypointList[ npc->m_iWayPointIndex[ npc->m_cCurWaypoint ] ].y;
			break;

		case MOVETYPE_RANDOMWAYPOINT:
			npc->m_cCurWaypoint = (rand() % (npc->m_cTotalWaypoint - 1)) + 1;

			npc->m_dX  = (short)m_pMapList[mapIndex]->m_WaypointList[ npc->m_iWayPointIndex[ npc->m_cCurWaypoint ] ].x;
			npc->m_dY  = (short)m_pMapList[mapIndex]->m_WaypointList[ npc->m_iWayPointIndex[ npc->m_cCurWaypoint ] ].y;
			break;

		case MOVETYPE_RANDOMAREA:
			npc->m_cCurWaypoint = 0;

			sRange = (short)(npc->m_rcRandomArea.right - npc->m_rcRandomArea.left);
			npc->m_dX = (short)((rand() % sRange) + npc->m_rcRandomArea.left);
			sRange = (short)(npc->m_rcRandomArea.bottom - npc->m_rcRandomArea.top);
			npc->m_dY = (short)((rand() % sRange) + npc->m_rcRandomArea.top);
			break;

		case MOVETYPE_RANDOM:
			npc->m_dX = (short)((rand() % (m_pMapList[mapIndex]->m_sSizeX - 50)) + 15);
			npc->m_dY = (short)((rand() % (m_pMapList[mapIndex]->m_sSizeY - 50)) + 15);
			break;
		}

		npc->m_tmp_iError  = 0;
		npc->m_cMoveType   = cMoveType;

		switch (npc->m_cActionLimit) 
		{
		case 2:
		case 3:
		case 5:
			npc->m_cBehavior = BEHAVIOR_STOP;

			switch (npc->m_sType) 
			{
			case 15:
			case 19:
			case 20:
			case 24:
			case 25:
			case 26:
				npc->m_cDir      = 4 + dice(1,3) -1;
				break;

			default:
				npc->m_cDir      = dice(1,8);
				break;
			}
			break;
		case 8: // Heldenian gate
			npc->m_cDir      = 3;
			npc->m_cBehavior = BEHAVIOR_STOP;	
			if (npc->m_cSize > 0)
			{	
				for(short sx1 = (sX - 1); sx1 <= sX + 1; sx1++)
					for(short sy1 = (sY - 1); sy1 <= sY + 1; sy1++)
					{	
						m_pMapList[mapIndex]->SetTempMoveAllowedFlag(sx1, sy1, false);		

					}	
			}
			break;

		default: 
			npc->m_cBehavior = BEHAVIOR_MOVE;
			npc->m_cDir      = 5;
			break;
		}

		npc->m_iFollowOwnerIndex  = NULL;
		npc->m_iTargetIndex	    = NULL;
		npc->m_cTurn              = (rand() % 2);

		switch (npc->m_sType) 
		{
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			npc->m_sAppr2 = (short)0xF000;
			npc->m_sAppr2 = npc->m_sAppr2 | ((rand() % 13) << 4);
			npc->m_sAppr2 = npc->m_sAppr2 | (rand() % 9);
			break;

		case 36:
		case 37:
		case 38:
		case 39:
			npc->m_sAppr2 = 3;
			break;
		case 64:
			npc->m_sAppr2 = 1;
			break;

		default:
			npc->m_sAppr2 = 0;
			break;
		}

		npc->m_cMapIndex          = (char)mapIndex;
		npc->m_dwTime             = timeGetTime() + (rand() % 10000);
		npc->m_dwMPupTime			= timeGetTime();
		npc->m_dwHPupTime			= npc->m_dwMPupTime;
		npc->m_sBehaviorTurnCount	= 0;
		npc->m_bIsSummoned        = bIsSummoned;
		npc->m_bIsMaster          = bIsMaster;
		if (bIsSummoned == true) 
			npc->m_dwSummonedTime = timeGetTime();

		if (bFirmBerserk == true) {
			npc->AddMagicEffect(MAGICTYPE_BERSERK, 0);
			npc->m_iExp *= 2;
			npc->m_iNoDieRemainExp *= 2;
		}

		// !!!
		if (changeSide != -1) 
		{
			npc->m_side = changeSide;
			npc->SetSideFlag(changeSide);
		}

		npc->m_cBravery = (rand() % 3) + npc->m_iMinBravery;
		npc->m_iSpotMobIndex		= iSpotMobIndex;
		npc->m_iGuildGUID         = iGuildGUID;


		//testcode
		if (iGuildGUID != 0) {
			wsprintf(g_cTxt, "Summon War Unit(%d) GUID(%d)", npc->m_sType, iGuildGUID);
			PutLogList(g_cTxt);
		}

		m_pMapList[mapIndex]->SetOwner(i, OWNERTYPE_NPC, sX, sY);
		m_pMapList[mapIndex]->m_iTotalActiveObject++;
		m_pMapList[mapIndex]->m_iTotalAliveObject++;

		switch (npc->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 42:
			m_pMapList[mapIndex]->bAddCrusadeStructureInfo(npc->m_sType, sX, sY, npc->m_side);
			break;
		case 64:
			m_pMapList[mapIndex]->bAddCropsTotalSum();
			return npc;
			break;
		}

		SendEventToNearClient_TypeA(i, OWNERTYPE_NPC, MSGID_MOTION_EVENT_CONFIRM, NULL, NULL, NULL);
		return npc;
	}

	return false;
}

void CGame::NpcProcess()
{
	int i, iMaxHP;
	uint32 dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < MAXNPCS; i++) {

		if (m_pNpcList[i] != NULL) {
			switch(m_pNpcList[i]->m_cBehavior)
			{
				case BEHAVIOR_ATTACK:
					dwActionTime = m_pNpcList[i]->m_dwActionTime + 50*dice(1,7);
					break;
				case BEHAVIOR_MOVE:
				case BEHAVIOR_FLEE:
					dwActionTime = m_pNpcList[i]->m_dwActionTime + 400; 
					break;
				default:
					dwActionTime = m_pNpcList[i]->m_dwActionTime; 
					break;
			}


			if (m_pNpcList[i]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] != 0) 
				dwActionTime += (dwActionTime/2);

			if ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime) {
				m_pNpcList[i]->m_dwTime = dwTime;
			
				m_pNpcList[i]->RegenHP();
				m_pNpcList[i]->RegenMP();
				m_pNpcList[i]->Behave();

				if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == true)) {
					switch (m_pNpcList[i]->m_sType) {
					case 29:
						if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*90)
							NpcKilledHandler(NULL, NULL, i, 0);
						break;
					case 64:
						if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > PLANTTIME) 
							DeleteNpc(i);
						break;
					default:
						if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > SUMMONTIME) 
							NpcKilledHandler(NULL, NULL, i, 0);
						break;
					}
				}
		}
		}
	}
}


void CGame::ChatMsgHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	int i, iRet;
	uint16 * wp;
	int  * ip, chatZone;
	char * cp, * cp2;
	char   cBuffer[256], cTemp[256], cSendMode = NULL;

	CClient * player = m_pClientList[iClientH];
	if(!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (dwMsgSize > 83 +30) return;

	if (player->m_iTimeLeft_ShutUp > 0) return;

	if (memcmp((pData + 10), player->m_cCharName, strlen(player->m_cCharName)) != 0) return;

	if ((player->m_bIsObserverMode == true) && (player->m_iAdminUserLevel == 0)) return;

	if (m_pMapList[player->m_cMapIndex] != NULL) {
		m_pMapList[player->m_cMapIndex]->IncPlayerActivity(player);
	}

	cp = (char *)(pData + 21);


	if (player->m_iAdminUserLevel > 0) {
		char cTemp[200] ;
		ZeroMemory(cTemp,sizeof(cTemp)) ;
		pData[dwMsgSize-1] = NULL;
		wsprintf(cTemp,"GM Chat(%s):\"%s\"",player->m_cCharName,cp) ;

		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
	}

	switch (*cp) {
	case '$':
		*cp = 32;

		cSendMode = CHAT_PARTY;
		break;

	case '@':
	case '^':
		*cp = 32;

		if(!player->m_guild)
			break;

		cSendMode = CHAT_GUILD;
		break;

	case '!':
		*cp = 32;

		if(player->m_iLevel <= 10 || player->IsDead())
			break;

		cSendMode = CHAT_SHOUT;
		break;

	case '%':
		*cp = 32;

		if(!player->IsGM())
			break;

		cSendMode = CHAT_GM;
		break;

	case '~':
		*cp = 32;

		if(player->IsDead())
			break;

		cSendMode = CHAT_NATIONSHOUT;
		break;

	case '/':
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);

		if (memcmp(cp, "/who", 4) == 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
		} 
		else if (memcmp(cp, "/mcount", 7) == 0) {
			Apocalypse_MonsterCount(iClientH);
		} else if (memcmp(cp, "/send ", 5) == 0) {
			AdminOrder_Pushplayer(iClientH, cp, dwMsgSize -21);
		} else if (memcmp(cp, "/goto ", 6) == 0) {
			AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/clearmap", 9) == 0) {
			AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
		} else if (memcmp(cp, "/afk", 5) == 0) {
			PlayerOrder_SetAFK(iClientH);
		} else if (memcmp(cp, "/checkrep", 9) == 0) {
			AdminOrder_CheckRep(iClientH,cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/fi ", 4) == 0) {
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/to", 3) == 0) {
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/setpf ", 7) == 0) {
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/pf ", 4) == 0) {
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/shutup ", 8) == 0) {
			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/rep+ ", 6) == 0)  {
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
		} else if (memcmp(cp, "/rep- ", 6) == 0) {
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
		} else if (memcmp(cp, "/hold", 5) == 0) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
		} else if (memcmp(cp, "/tgt ", 5) == 0) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
		} else if (memcmp(cp, "/free", 5) == 0) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
		} else if (memcmp(cp, "/closeconn ", 11) == 0) {
			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventspell ", 12) == 0) {
			AdminOrder_EventSpell(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventarmor", 11) == 0) {
			AdminOrder_EventArmor(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventshield", 12) == 0) {
			AdminOrder_EventSheild(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventchat", 10) == 0) {
			AdminOrder_EventChat(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventparty", 11) == 0) {
			AdminOrder_EventParty(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventreset", 11) == 0) {
			AdminOrder_EventReset(iClientH);
		} else if (memcmp(cp, "/eventtp", 8) == 0) {
			AdminOrder_EventTP(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/eventillusion", 14) == 0) {
			AdminOrder_EventIllusion(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/ban", 4) == 0) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/dissmiss ", 9) == 0) {
			UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/attack ", 8) == 0) {
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/summonplayer ", 14) == 0) {
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/unsummonall", 12) == 0) {
			AdminOrder_UnsummonAll(iClientH);
		} else if (memcmp(cp, "/unsummonboss", 13) == 0) {
			AdminOrder_UnsummonBoss(iClientH);
		} else if (memcmp(cp, "/checkip ", 9) == 0) {
			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/noaggro", 8) == 0) {
			AdminOrder_ToggleNoAggro(iClientH);
		} else if (memcmp(cp, "/invincible", 11) == 0) {
			AdminOrder_ToggleInvincible(iClientH);
		} else if (memcmp(cp, "/eth", 4) == 0) {
			AdminOrder_ToggleEthereal(iClientH);
		} else if (memcmp(cp, "/setinvi", 8) == 0 || memcmp(cp, "/invi", 5) == 0) {
			AdminOrder_SetInvi(iClientH);
		} else if (memcmp(cp, "/sethp", 6) == 0 ) {
			AdminOrder_SetHP(iClientH, atoi(cp+6));
		} else if (memcmp(cp, "/setmp", 6) == 0 ) {
			AdminOrder_SetMP(iClientH, atoi(cp+6));
		} else if (memcmp(cp, "/setmag", 7) == 0 ) {
			AdminOrder_SetMag(iClientH, atoi(cp+7));
		//} else if (memcmp(cp, "/gns ", 4) == 0) {
		//	AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/setattackmode ", 15) == 0) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
			AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/disconnectall", 14) == 0) {
			AdminOrder_DisconnectAll(iClientH);
		} else if (memcmp(cp, "/createitem ", 12) == 0 || memcmp(cp, "/ci ", 4) == 0) {
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/setweather ", 12) == 0) {
			AdminOrder_SetWeather(iClientH, cp, dwMsgSize - 21);
		} else if (memcmp(cp, "/soccer", 7) == 0) {
			if (m_SoccerMode) return;
			m_SoccerMode = true;
			if (player->m_iAdminUserLevel >= 2)
			{	
				EnergySphereProcessor(true, iClientH);
				for (int i = 1; i <  MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) 
					{	
						SendNotifyMsg(NULL, i, NOTIFY_SOCCERBEGIN,  NULL , NULL, NULL, NULL);
					}
					wsprintf(g_cTxt, "GM Order(%s): Begin Soccer on Map (%s)", player->m_cCharName, player->m_cMapName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			}
		} else if (memcmp(cp, "/endsoccer", 10) == 0) {
			if (!m_SoccerMode) return;
			m_SoccerMode = false;
			if (player->m_iAdminUserLevel >= 2)
			{	
				for (i = 0; i < MAXMAPS; i++)	
					if (m_pMapList[i] != NULL) {	
						if (memcmp(m_pMapList[i]->m_cName, player->m_cMapName, 10) == 0) {
							DeleteNpc(NPC_ENERGY_SPHERE);		
						}
					}
					SoccerEventWon((Side)0, player->m_cMapIndex);
					wsprintf(g_cTxt, "GM Order(%s): End Soccer on Map (%s)", player->m_cCharName, player->m_cMapName);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			}
		}else if (memcmp(cp, "/apocalypse", 11) == 0) {	
			if (player->m_iAdminUserLevel >= 4)
			{	wsprintf(cTemp, "GM Order(%-10s): /beginapocalypse", player->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
				GlobalStartApocalypseMode(iClientH);
			}
			return;
		} else	if (memcmp(cp, "/endapocalypse", 14) == 0) {	
			if (player->m_iAdminUserLevel >= 4) 	
			{	
				wsprintf(cTemp, "GM Order(%-10s): /endapocalypse", player->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
				GlobalEndApocalypseMode(iClientH);
			}
			return;
		} else if (memcmp(cp, "/heldenian", 10) == 0) {	
			if (player->m_iAdminUserLevel < 4)
			{	
				SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
				return;
			}
			wsprintf(cTemp, "GM Order(%-10s): /beginheldenian", player->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
			StartHeldenianMode(iClientH);
			return;
		} else if (memcmp(cp, "/endheldenian ", 14) == 0) {	
			if (player->m_iAdminUserLevel < 4)
			{	
				SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
				return;
			}
			wsprintf(cTemp, "GM Order(%-10s): /endheldenian", player->m_cCharName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, cTemp);
			Side side = (Side)atoi(cp+14);
			HeldenianEndWarNow(m_iHeldenianType, side); 
			return;
		} 
		else if (memcmp(cp, "/crusade", 8) == 0) {
			if (player->m_iAdminUserLevel >= 4) {
				GlobalStartCrusadeMode();
				wsprintf(g_cTxt, "GM Order(%s): begincrusadetotalwar", player->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			}
		} else if (memcmp(cp, "/endcrusade", 11) == 0) {
			if (player->m_iAdminUserLevel >= 4) {
				ManualEndCrusadeMode(0);
				wsprintf(g_cTxt, "GM Order(%s): endcrusade", player->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			} 
		} else if (memcmp(cp, "/astoria ", 9) == 0) {
			if (player->m_iAdminUserLevel >= 4) {
				EventType eType = (EventType)atoi(cp+9);
				EventStart(eType);
				wsprintf(g_cTxt, "GM Order(%s): Start Astoria(%u)", player->m_cCharName, eType);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
			}
		} else if (memcmp(cp, "/endastoria", 11) == 0) {
			if (player->m_iAdminUserLevel >= 4) {
				wsprintf(g_cTxt, "GM Order(%s): End Astoria", player->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
				EventEnd();
			}
		} else if (memcmp(cp, "/dismissparty", 13) == 0) {
			if(player->GetParty())
			{
				partyMgr.RemoveFromParty( player );
			}
		} else if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (player->m_iAdminUserLevel >= 5)) {
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = true;
			m_dwExitProcessTime  = timeGetTime();
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

			if (m_iMiddlelandMapIndex > 0) {
				// Crusade
				SaveOccupyFlagData();
				//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
				//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
			}
			return;
		} else if ((memcmp(cp, "/setobservermode", 16) == 0 || memcmp(cp, "/obs", 4) == 0) && 
			(player->m_iAdminUserLevel >= 3)) {
			AdminOrder_SetObserverMode(iClientH);
		} else if ((memcmp(cp, "/getticket", 10) == 0) && (player->m_iAdminUserLevel >= 2)) {
			AdminOrder_GetFightzoneTicket(iClientH);
		}

		return;
	}

	pData[dwMsgSize-1] = NULL;

	if ((player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] == 1) && (dice(1,3) != 2)) {
		// Confuse Language
		cp = (char *)(pData + INDEX2_MSGTYPE + 17);

		while (*cp != NULL) {
			if ((cp[0] != NULL) && (cp[0] != ' ') && (cp[1] != NULL) && (cp[1] != ' ')) {
				switch (dice(1,3)) {
				case 1:	memcpy(cp, "", 2); break;
				case 2:	memcpy(cp, "", 2); break;
				case 3:	memcpy(cp, "", 2); break;
				}
				cp += 2;
			}
			else cp++; 
		}
	}

	cp = (char *)(pData + INDEX2_MSGTYPE + 17);

	if ((cSendMode == NULL) && (player->m_iWhisperPlayerIndex != -1)) {
		cSendMode = CHAT_WHISPER;

		if (*cp == '#') cSendMode = CHAT_NORMAL;

		if (player->m_iTimeLeft_ShutUp > 0) cSendMode = CHAT_NORMAL;
	}

	wp = (uint16 *)(pData + INDEX2_MSGTYPE);
	*wp = (uint16)iClientH;
	cp = (char *)(pData + INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	bool send;

	if(cSendMode == CHAT_GUILD)
	{
		if(!player->m_guild) return;
		if(m_pMapList[player->m_cMapIndex]->m_isChatDisabled && !player->IsGM()) return;
		player->m_guild->Broadcast(pData, dwMsgSize);

	} else if (cSendMode != CHAT_WHISPER) {
		chatZone = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_chatZone;
		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				if (m_pClientList[i]->m_bIsInitComplete == false) continue;

					if (m_bIsCrusadeMode) {
							if (!player->IsNeutral() && 
								!m_pClientList[i]->IsNeutral() && 
								m_pClientList[i]->m_side != player->m_side) 
							{
								send = false;
							}
							else 
								send = true;
					}else{ 
						send = true;
					}
					if(m_pMapList[player->m_cMapIndex]->m_isChatDisabled == false || i == iClientH || player->IsGM() || m_pClientList[i]->IsGM())
						switch (cSendMode) 
						{
						case CHAT_NORMAL:
							if ( (m_pClientList[i]->m_cMapIndex == player->m_cMapIndex) &&
								(m_pClientList[i]->m_sX > player->m_sX - 10) &&
								(m_pClientList[i]->m_sX < player->m_sX + 10) &&
								(m_pClientList[i]->m_sY > player->m_sY - 7) &&
								(m_pClientList[i]->m_sY < player->m_sY + 7) ) {

									if (send)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							}
							break;

						case CHAT_SHOUT:
							if (send && m_pMapList[m_pClientList[i]->m_cMapIndex]->m_chatZone == chatZone)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case CHAT_GM:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case CHAT_NATIONSHOUT:
							if (m_pClientList[i]->m_side == player->m_side &&
								m_pMapList[m_pClientList[i]->m_cMapIndex]->m_chatZone == chatZone) 
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;

						case CHAT_PARTY:
							if (m_pClientList[i]->GetParty() && m_pClientList[i]->GetParty() == player->GetParty()) 
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
							break;
						}

					switch (iRet) 
					{
					case XSOCKEVENT_QUENEFULL:
					case XSOCKEVENT_SOCKETERROR:
					case XSOCKEVENT_CRITICALERROR:
					case XSOCKEVENT_SOCKETCLOSED:
						//DeleteClient(i, true, true);
						break;
					}
			}
	}
	else if (m_pMapList[player->m_cMapIndex]->m_isChatDisabled == false || player->IsGM()
		|| (player->m_iWhisperPlayerIndex < MAXCLIENTS &&  m_pClientList[ player->m_iWhisperPlayerIndex ] != NULL && 
		m_pClientList[player->m_iWhisperPlayerIndex]->IsGM())) {
		iRet = player->m_pXSock->iSendMsg(pData, dwMsgSize);

		if (player->m_iWhisperPlayerIndex == 10000) {
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)(cBuffer);
			*cp =  GSM_WHISPERMSG;
			cp++;

			memcpy(cp, player->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (uint16 *)cp;
			*wp = (uint16)dwMsgSize;
			cp += 2;

			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;

			bStockMsgToGateServer(cBuffer, (13 +dwMsgSize));
		}
		else if (m_pClientList[ player->m_iWhisperPlayerIndex ] != NULL) {
			if( strcmp(player->m_cWhisperPlayerName, m_pClientList[ player->m_iWhisperPlayerIndex ]->m_cCharName) == 0)  {
				iRet = m_pClientList[player->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);
				if (m_pClientList[player->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0) {
					char cTxt[200] ;

					ZeroMemory(cTxt,sizeof(cTxt)) ;

					wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",player->m_cCharName,pData+21,player->m_cWhisperPlayerName) ;
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL, cTxt);
				}
			}
		}

		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			//DeleteClient(i, true, true);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, uint32 dwMsgSize)
{
	int i, iRet;
	uint32 * dwp;
	uint16 * wp;
	short * sp;
	char * cp, cTemp[256];

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (uint32 *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (uint16 *)(cTemp + INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case CHAT_GUILD:
		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				if (m_pClientList[i]->m_bIsInitComplete == false) break;
				if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
				}
			}
			break;

	case CHAT_SHOUT:
	case CHAT_GM:
		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
			break;
	}
}

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char * cp, cTemp[256];
	uint32 * dwp, dwMsgSize;
	uint16 * wp;
	short * sp;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (uint32 *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (uint16 *)(cTemp + INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	memcpy(cp, "Server", 7);
	cp += 10;

	*cp = CHAT_GM;
	cp++;

	dwMsgSize = strlen(pMsg);
	if(dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, uint16 wTargetObjectID, bool bResponse, bool bIsDash)
{
	char cData[100];
	uint32 * dwp, dwTime;
	uint16  * wp;
	int     iRet, iExp, tdX = 0, tdY = 0;
	short   sOwner, sAbsX, sAbsY;
	char    cOwnerType, tgtDist = 1;
	bool    bNearAttack = false;
	int  iErr = 0, tX = 0, tY = 0, i = 1;
	short sItemIndex;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return 0;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

#ifndef NO_MSGSPEEDCHECK
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7)
	{
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0)
		{
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (80*8*7 -3000)) {
				wsprintf(g_cTxt, "(!) Speed hack suspect(%s) - attack-lat(%i)",
					m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwAttackLAT); 
				PutLogList(g_cTxt); 
				DeleteClient(iClientH, true, true);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}
#endif

	if ((wTargetObjectID != NULL) && (wType != 2)) {
		if (wTargetObjectID < MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
				tgtDist = 1;
			}
		}else if ((wTargetObjectID > 10000) && (wTargetObjectID < (10000 + MAXNPCS))){
			if (m_pNpcList[wTargetObjectID - 10000] != NULL){
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
				tgtDist = (m_pNpcList[wTargetObjectID - 10000]->m_cSize < 2) ? 1 : m_pNpcList[wTargetObjectID - 10000]->m_cSize;
			}
		}
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if(sOwner == (wTargetObjectID - 10000)) {
			dX = tdX = m_pNpcList[sOwner]->m_sX;
			dY = tdY = m_pNpcList[sOwner]->m_sY;
			bNearAttack = false;
		}
		else if((tdX == dX) && (tdY == dY)) {
			bNearAttack = false;
		}
		else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
			dX = tdX;
			dY = tdY;
			bNearAttack = true;	
		}	
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ];
		if (sItemIndex != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_STORMBRINGER) {
				if (sAbsX > (3+tgtDist) || sAbsY > (3+tgtDist)) wType = 0;
			}
			else{
				if (sAbsX > tgtDist || sAbsY > tgtDist) wType = 0;
			}
		}
		else{
			if (sAbsX > tgtDist || sAbsY > tgtDist) wType = 0;
		}
	}

	if(m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	m_pClientList[iClientH]->m_cDir = cDir;

	iExp = 0;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

	if (sOwner != NULL) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) {
			if (m_pClientList[iClientH]->m_bIsInBuilding == false) {
				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
					if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_DIRECTION_BOW){
						sAbsX = abs(sX - dX);
						sAbsY = abs(sY - dY);
						tgtDist = sAbsX > sAbsY ? sAbsX : sAbsY;
						for(i = 1; i < tgtDist; i++){
							if (dice(1, 4) <= 3) {
								iErr = 0;
								CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
								if (cOwnerType != OWNERTYPE_NONE)
									iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash);
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
						if(iExp == 0 && cOwnerType == OWNERTYPE_NPC && dice(1,2) == 1) {
							iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
						}
						iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);						
					}
					else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_FIRE_BOW){
						if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {

							if(!m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) && (abs(dX - sX) > 1 || abs(dY - sY) > 1))
								iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, DYNAMICOBJECT_FIRE, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (dice(1,7)+3)*1000, 8);

							iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
						}
					}
					else{
						iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
					}
				}
				else{
					iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
				}
			}
			else{
				iExp += calculateAttackEffect(sOwner, cOwnerType, iClientH, OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash);
			}
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY);


	if (iExp != 0) 	GetExp(iClientH, iExp, true);


	if (bResponse == true) {
		dwp  = (uint32 *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
		*wp  = OBJECTMOTION_ATTACK_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}

	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
	char  cDir, cTmpDir;
	int   aX, aY, dX, dY;
	int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;

	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else CMisc::GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = CMisc::cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
		for (i = cDir; i <= cDir + 7;i++) {
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == true) return cTmpDir;
		}

	if (cTurn == 1)
		for (i = cDir; i >= cDir - 7;i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == true) return cTmpDir;
		}

	return 0;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError, short * DOType)
{
	char  cDir, cTmpDir;
	int   aX, aY, dX, dY;
	int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;

	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else CMisc::GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = CMisc::cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
		for (i = cDir; i <= cDir + 7;i++) {
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY, DOType) == true) return cTmpDir;
		}

	if (cTurn == 1)
		for (i = cDir; i >= cDir - 7;i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY, DOType) == true) return cTmpDir;
		}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

bool CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
	int i;
	short sX, sY;

	for (i = 0; i < 25; i++) 
		if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == true) &&
			(m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == false) ) {
				sX = *pX + _tmp_cEmptyPosX[i];
				sY = *pY + _tmp_cEmptyPosY[i];
				*pX = sX;
				*pY = sY;
				return true;
		}

	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return false;
}

void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
	int i;
	uint32 dwTime = timeGetTime();

	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {

			if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (cTargetType == OWNERTYPE_PLAYER) &&
				(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

				if (m_pNpcList[i]->m_cActionLimit == 0) {
					m_pNpcList[i]->m_bIsSummoned = true;
					m_pNpcList[i]->m_dwSummonedTime = dwTime;
				}
			}

		if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) && 
			(m_pNpcList[i]->m_cTargetType == cTargetType)) {

			switch (iCode) 
			{
			case MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility == 1) {
				}
				else {
					m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;

			default:
				m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
			}
		}
	}
}

void CGame::RemoveFromTarget(Unit * target, int iCode)
{
	int i;
	uint32 dwTime = timeGetTime();

	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {

			if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (target->IsPlayer()) &&
				(target->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

					if (m_pNpcList[i]->m_cActionLimit == 0) {
						m_pNpcList[i]->m_bIsSummoned = true;
						m_pNpcList[i]->m_dwSummonedTime = dwTime;
					}
			}

			if ((m_pNpcList[i]->m_iTargetIndex == target->m_handle) && 
				(m_pNpcList[i]->m_cTargetType == target->m_ownerType)) {

					switch (iCode) 
					{
					case MAGICTYPE_INVISIBILITY:
						if (m_pNpcList[i]->m_cSpecialAbility == 1) {
						}
						else {
							m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
							m_pNpcList[i]->m_iTargetIndex = NULL;
							m_pNpcList[i]->m_cTargetType  = NULL;
						}
						break;

					default:
						m_pNpcList[i]->m_cBehavior = BEHAVIOR_MOVE;
						m_pNpcList[i]->m_iTargetIndex = NULL;
						m_pNpcList[i]->m_cTargetType  = NULL;
						break;
					}
			}
		}
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
	if(!m_pNpcList[iNpcH] || m_pNpcList[iNpcH]->m_bIsKilled) return;

	Unit * attacker = NULL;

	if(cAttackerType == OWNERTYPE_PLAYER)
		attacker = m_pClientList[sAttackerH];
	else if(cAttackerType == OWNERTYPE_NPC)
		attacker = m_pNpcList[sAttackerH];

	m_pNpcList[iNpcH]->Behavior_Death(attacker, sDamage);
}

void CGame::NpcBehavior_Dead(int iNpcH)			   
{
	uint32 dwTime;

	if (m_pNpcList[iNpcH] == NULL) return; 

	dwTime = timeGetTime();
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	}

	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
	char cDir;
	short sX, sY, dX, dY;
	short sTarget;
	char  cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == true) return;

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;


	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case ATTACKAI_EXCHANGEATTACK: 
	case ATTACKAI_TWOBYONEATTACK: 
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {

			m_pNpcList[iNpcH]->m_cBehavior          = BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;

	default:
		if (dice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		m_pNpcList[iNpcH]->m_cBehavior          = BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += dice(1, m_pNpcList[iNpcH]->m_iHitDice); 
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	m_pNpcList[iNpcH]->TargetSearch(&sTarget, &cTargetType);
	if (sTarget != NULL) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(/*11,*/ iNpcH, OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, OWNERTYPE_NPC, MSGID_MOTION_MOVE, NULL, NULL, NULL);
	}
}


void CGame::MsgProcess()
{
	char   * pData, cFrom, cGSReg[200], cKey, cTxt[250];
	uint32    dwMsgSize, * dwpMsgID;
	uint16   * wpMsgType, * wp;
	int      i, iClientH;

	if ((m_bF1pressed == true) && (m_bF4pressed == true) && (m_bOnExitProcess == false)) {
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = true;
		m_dwExitProcessTime  = timeGetTime();

		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

		if (m_iMiddlelandMapIndex > 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}

		return;
	}

	ZeroMemory(m_pMsgBuffer, MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == true) {
		CClient * player = m_pClientList[iClientH];

		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom)
		{
		case MSGFROM_CLIENT:
			if(!player) break;

			dwpMsgID = (uint32 *)(pData + INDEX4_MSGID);

			if(*dwpMsgID & MSGIDTYPE_MOTION)
			{
				ClientMotionHandler(iClientH, pData);
				break;
			}

			switch (*dwpMsgID) 
			{

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				RequestNoticementHandler(iClientH, pData);
				break;

			case MSGID_MANAGER_INIT:
				_Manager_Init(iClientH, pData);
				break;

			case MSGID_MANAGER_SHUTDOWN:
				_Manager_Shutdown(iClientH, pData);
				break;

			case MSGID_REQUEST_SETITEMPOS:
				_SetItemPos(iClientH, pData);
				break;

			case MSGID_REQUEST_FULLOBJECTDATA:
				RequestFullObjectData(iClientH, pData);
				break;

			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, 4);
				break;

			case MSGID_REQUEST_INITPLAYER:
				//RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;
				
			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_TELEPORT_LIST:
				RequestTeleportListHandler(iClientH, pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_CHARGED_TELEPORT:
				RequestChargedTeleportHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_QUEST_LIST:
				RequestQuestListHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_ACCEPT_QUEST:
				RequestAcceptQuestHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIAN_SCROLL:
				RequestHeldenianScroll(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_ANGEL:
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DKITEM:
				GetDKItemHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_UPDATE_FRIENDS:
				RequestUpdateFriendsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_RESURRECTPLAYER_YES:
				RequestResurrectPlayer(iClientH, true);
				break;

			case MSGID_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, false);
				break;

			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_LGNPTS:
				bSendMsgToLS(MSGID_REQUEST_LGNPTS, iClientH);
				break;

			case MSGID_REQUEST_LGNSVC:
				bSendMsgToLS(MSGID_REQUEST_LGNSVC, iClientH, NULL, pData);
				break;

			case MSGID_REQUEST_SETRECALLPNT:
				RequestSetRecallPoint(iClientH, pData, dwMsgSize);
				break;
				
			case MSGID_REQ_MAILBOX:
				RequestMailbox(player, pData+6);
				break;

			case MSGID_REQ_MAILDATA:
				RequestMailData(player, pData+6);
				break;

			case MSGID_REQ_RETRIEVEMAILITEM:
				RequestRetrieveMailItem(player, pData);
				break;

			case MSGID_REQ_DELETEMAIL:
				RequestDeleteMail(player, pData+6);
				break;

			case MSGID_REQ_SENDMAIL:
				RequestSendMail(player, pData, dwMsgSize);
				break;
				
			case MSGID_REQ_GUILDBOARD:
				RequestGuildBoard(player, pData+6);
				break;

			case MSGID_REQ_GUILDPOSTDATA:
				RequestGuildBoardPost(player, pData+6);
				break;
				
			case MSGID_REQ_DELETEGUILDPOST:
				RequestDeleteGuildBoardPost(player, pData+6);
				break;
				
			case MSGID_REQ_POSTGUILDBOARD:
				RequestPostGuildBoard(player, pData, dwMsgSize);
				break;
				
			case MSGID_REQUEST_GUILDBANK:
				RequestGuildBank(player, pData+6);
				break;
				
			case MSGID_REQGUILDSUMMONS:
				RequestGuildSummon(player, pData+4);
				break;
				
			case MSGID_RSPGUILDSUMMONS:
				ResponseGuildSummon(player, pData+4);
				break;

			case MSGID_GUILDCONTRIBUTE:
				GuildContribute(player, pData+6);
				break;
				
			case MSGID_GUILDUPGRADE:
				GuildUpgrade(player, pData+6);
				break;

			case MSGID_GUILDSMANCHANGE:
				GuildsmanChange(player, pData+6);
				break;
				
			case MSGID_REQUEST_RETRIEVEITEM_GUILDBANK:
				RequestRetrieveGuildItem(player, pData+4);
				break;

			case MSGID_PINGMAP:
				HandlePingMap(player, pData + 4);
				break;

			case MSGID_CONFIRMBUMP:
				player->m_rejectedMove = false;
				break;

			default:
				ZeroMemory(cTxt, sizeof(cTxt));
				wsprintf(cTxt,"Unknown message received: (0x%.8X) PC(%s IP: %s)"
					, *dwpMsgID
					, m_pClientList[iClientH]->m_cCharName
					, m_pClientList[iClientH]->m_cIPaddress );
				DeleteClient(iClientH, true, true);

				PutLogFileList(cTxt, HACK_LOGFILE);
				PutLogList(cTxt); 
				break;
			}
			break;

		case MSGFROM_LOGSERVER:
			dwpMsgID   = (uint32 *)(pData + INDEX4_MSGID);
			wpMsgType  = (uint16 *)(pData + INDEX2_MSGTYPE);

			switch (*dwpMsgID) 
			{
			case MSGID_UPDATECONFIGFILES:
				_iForcePlayerDisconect(MAXCLIENTS);
				guildMgr.Empty();
				for (i = 0; i < MAXITEMTYPES; i++)          SAFEDELETE(m_pItemConfigList[i]);
				for (i = 0; i < MAXBUILDITEMS; i++)         SAFEDELETE(m_pBuildItemList[i]);
				for (i = 0; i < MAXDUPITEMID; i++)          SAFEDELETE(m_pDupItemIDList[i]);
				for (i = 0; i < MAXMAGICTYPE; i++)          SAFEDELETE(m_pMagicConfigList[i]);
				for (i = 0; i < MAXNPCTYPES; i++)           SAFEDELETE(m_npcConfigList[i]);
				for (i = 0; i < MAXPORTIONTYPES; i++)       SAFEDELETE(m_pPortionConfigList[i]);
				for (i = 0; i < MAXCRAFTING; i++)			SAFEDELETE(m_pCraftingConfigList[i]);
				for (i = 0; i < MAXQUESTTYPE; i++)          SAFEDELETE(m_pQuestConfigList[i]);
				for (i = 0; i < MAXSKILLTYPE; i++)          SAFEDELETE(m_pSkillConfigList[i]);
				break;

			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				wpMsgType  = (uint16 *)(pData + INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + INDEX2_MSGTYPE + 2), *wpMsgType);
				break;

			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;

			case MSGID_GUILDNOTIFY:
				GuildNotifyHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_DISBANDGUILD:
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_SERVERSTOCKMSG:
				ServerStockMsgHandler(pData);
				break;

			case MSGID_SENDSERVERSHUTDOWNMSG:
				wp = (uint16 *)(pData + INDEX2_MSGTYPE + 2);
				switch (*wp) 
				{
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < MAXCLIENTS; i++)
						if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
							SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
						}
						break;

				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < MAXCLIENTS; i++)
						if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
							SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
						}
						break;
				}
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;

			case MSGID_GAMESERVERSHUTDOWNED:

				m_cShutDownCode      = 1;
				m_bOnExitProcess     = true;
				m_dwExitProcessTime  = timeGetTime();

				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

				if (m_iMiddlelandMapIndex > 0) {
					// Crusade
					SaveOccupyFlagData();
					//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
					//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
				}
				break;

			case MSGID_TOTALGAMESERVERCLIENTS:
				wp = (uint16 *)(pData + INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;

			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) 
				{
				case MSGTYPE_CONFIRM:
					GSID = bGetOffsetValue(pData, 6);
					ZeroMemory(cGSReg, sizeof(cGSReg));
					wsprintf(cGSReg,"(!) Game Server registration to Log Server - Success! GSID[%u]",GSID);
					PutLogList(cGSReg);
					m_bIsGameServerRegistered = true;
					break;

				case MSGTYPE_REJECT:
					PutLogList("(!) Game Server registration to Log Server - Fail!");
					break;
				}
				if(ReceivedAllConfig) break;

				if (m_bIsBuildItemAvailable == false) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}

				if (m_bIsItemAvailable == false) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}

				if (m_bIsNpcAvailable == false) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == false) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == false) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == false) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPortionAvailable == false) {
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! POTION configuration error.");
				}

				ReceivedAllConfig = true;
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				// Build Item contents
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_ITEMCONFIGURATIONCONTENTS:
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:

				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_MAGICCONFIGURATIONCONTENTS:
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_PORTIONCONFIGURATIONCONTENTS:
				PutLogList("(!) POTION configuration contents received. Now decoding...");
				m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_DUPITEMIDFILECONTENTS:
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_CRAFTINGCONFIGURATIONCONTENTS:
				_bDecodeCraftingConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break; 

			case MSGID_TELEPORTLISTCONTENTS:
				PutLogList("(!) TeleportListConfig file contents received. Now decoding...");
				_bDecodeTeleportListConfigFileContents((char *)(pData + INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
				
			case MSGID_RSP_GUILDBOARD:
				ResponseGuildBoard(pData, dwMsgSize);
				break;

			case MSGID_RSP_POSTGUILDBOARD:
				ResponsePostGuildBoard(pData, dwMsgSize);
				break;

			case MSGID_RSP_MAILBOX:
				ResponseMailbox(pData, dwMsgSize);
				break;

			case MSGID_RSP_MAILDATA:
				ResponseMailData(pData);
				break;
				
			case MSGID_RSP_RETRIEVEMAILITEM:
				ResponseRetrieveMailItem(pData + INDEX2_MSGTYPE + 2);
				break;

			case MSGID_RSP_GUILDBOARDPOST:
				ResponseGuildBoardPost(pData, dwMsgSize);
				break;

			case MSGID_RSP_SENDMAIL:
				ResponseSendMail(pData);
				break;

			case MSGID_RESPONSE_LGNPTS:
				SendNotifyMsg(NULL, *(uint16 *)(pData+ INDEX2_MSGTYPE + 2), NOTIFY_LGNPTS, *(uint32 *)(pData+ INDEX2_MSGTYPE + 2 + 2));
				break;

			case MSGID_RESPONSE_LGNSVC:
				HandleLegionService(pData);
				break;

			case MSGID_CONFIRMEDLOGIN:
				ConfirmedLogin login;
				pData += INDEX2_MSGTYPE;
				Pop(pData, login.accName, 15);
				Pop(pData, login.accPass, 12);
				Pop(pData, login.playerName, 12);
				Pop(pData, login.ip, 16);
				login.timeReceived = timeGetTime();

				confirmedLogins.push_back(login);
				wsprintf(g_cTxt,"(!) Confirmed client: %s (%s / %s - %s)", login.ip, login.accName, login.accPass, login.playerName);
				PutLogList(g_cTxt);
				break;

			case MSGID_RESPONSE_LOAD_GUILDINFO:
				ResponseGuildInfo(pData+4);
				break;
			}
			break;
		}
	}
}


bool CGame::bPutMsgQuene(char cFrom, char * pData, uint32 dwMsgSize, int iIndex, char cKey)
{
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, m_cServerName);
	if (hMutex != NULL) return false; 
	hMutex = CreateMutex(NULL, false, m_cServerName);
	*/
	if (m_pMsgQuene[m_iQueneTail] != NULL) return false;

	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return false;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == false) return false;

	m_iQueneTail++;
	if (m_iQueneTail >= MSGQUENESIZE) m_iQueneTail = 0;

	//ReleaseMutex(hMutex);

	return true;
}


bool CGame::bGetMsgQuene(char * pFrom, char * pData, uint32 * pMsgSize, int * pIndex, char * pKey)
{
	/*
	HANDLE hMutex;

	hMutex = OpenMutex(MUTEX_ALL_ACCESS, false, m_cServerName);
	if (hMutex != NULL) return false; 
	hMutex = CreateMutex(NULL, false, m_cServerName);
	*/

	if (m_pMsgQuene[m_iQueneHead] == NULL) return false;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= MSGQUENESIZE) m_iQueneHead = 0;

	//ReleaseMutex(hMutex);

	return true;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
	uint16 * wp, wCommand;
	short * sp, sX, sY; 
	int   * ip, iV1, iV2, iV3, iV4;
	char  * cp, cDir, * pString;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;

	wp = (uint16 *)(pData + INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;

	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;


	switch (wCommand) {


	case COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

	case COMMONTYPE_REQGUILDNAME:
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case COMMONTYPE_UPGRADEITEM:
		RequestItemUpgradeHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	case COMMONTYPE_SETGUILDTELEPORTLOC:
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case COMMONTYPE_SETGUILDCONSTRUCTLOC:
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case COMMONTYPE_GUILDTELEPORT:
		RequestGuildTeleportHandler(iClientH);
		break;

	case COMMONTYPE_SUMMONWARUNIT:
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;

	case COMMONTYPE_REQUEST_MAPSTATUS:
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQUEST_CANCELQUEST:
		CancelQuestHandler(iClientH);
		break;

	case COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		ActivateSpecialAbilityHandler(iClientH);
		break;

	case COMMONTYPE_REQUEST_JOINPARTY:
		JoinPartyHandler(iClientH, iV1, pString);
		break;

	case COMMONTYPE_GETMAGICABILITY:
		GetMagicAbilityHandler(iClientH);
		break;

	case COMMONTYPE_BUILDITEM:
		BuildItemHandler(iClientH, pData);
		break;

	case COMMONTYPE_CANCELEXCHANGEITEM:
		CancelExchangeItem(iClientH);
		break;

	case COMMONTYPE_CONFIRMEXCHANGEITEM:
		ConfirmExchangeItem(iClientH);
		break;

	case COMMONTYPE_SETEXCHANGEITEM:
		SetExchangeItem(iClientH, iV1, iV2);
		break;

	case COMMONTYPE_REQ_GETHEROMANTLE:
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;

	case COMMONTYPE_REQ_GETOCCUPYFLAG:
		GetOccupyFlagHandler(iClientH);
		break;

	case COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case COMMONTYPE_TALKTONPC:
		NpcTalkHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQ_CREATEPOTION:
		ReqCreatePortionHandler(iClientH, pData);
		break;

	case COMMONTYPE_REQ_GETFISHTHISTIME:
		ReqGetFishThisTimeHandler(iClientH);
		break;

	case COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;

	case COMMONTYPE_REQ_REPAIRITEM:
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;

	case COMMONTYPE_REQ_SELLITEMCONFIRM:
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;

	case COMMONTYPE_REQ_SELLITEM:
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;

	case COMMONTYPE_REQ_USESKILL:
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;

	case COMMONTYPE_REQ_USEITEM:
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;

	case COMMONTYPE_REQ_GETREWARDMONEY:
		GetRewardMoneyHandler(iClientH);
		break;

	case COMMONTYPE_ITEMDROP:
		DropItemHandler(iClientH, iV1, iV2, pString, true);
		break;

	case COMMONTYPE_EQUIPITEM:
		bEquipItemHandler(iClientH, iV1);
		break;

	case COMMONTYPE_REQ_PURCHASEITEM:
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case COMMONTYPE_REQ_STUDYMAGIC:
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case COMMONTYPE_REQ_TRAINSKILL:
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case COMMONTYPE_GIVEITEMTOCHAR:
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case COMMONTYPE_EXCHANGEITEMTOCHAR:
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case COMMONTYPE_JOINGUILDAPPROVE:
		JoinGuildApproveHandler(iClientH, pString);
		break;

	case COMMONTYPE_JOINGUILDREJECT:
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case COMMONTYPE_DISMISSGUILDAPPROVE:
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case COMMONTYPE_DISMISSGUILDREJECT:
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case COMMONTYPE_RELEASEITEM:
		ReleaseItemHandler(iClientH, iV1, true);
		break;

	case COMMONTYPE_TOGGLECOMBATMODE:
		ToggleCombatModeHandler(iClientH);
		break;

	case COMMONTYPE_MAGIC:
		if(m_pClientList[iClientH]->m_hasPrecasted || m_pClientList[iClientH]->IsGM())
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case COMMONTYPE_TOGGLESAFEATTACKMODE:
		ToggleSafeAttackModeHandler(iClientH);
		break;

	case COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		GetFightzoneTicketHandler(iClientH);
		break;

	case COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break; 
		
	case COMMONTYPE_REQ_REPAIRALL:
		ReqRepairAll(iClientH);
		break;

	case COMMONTYPE_REQ_REPAIRALLCONFIRM:
		ReqRepairAllConfirmHandler(iClientH, iV1);
		break;
	}
}


void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, bool bByPlayer)
{
	CItem * pItem;
	CClient * player = m_pClientList[iClientH];
	if (!player || player->m_bIsOnWaitingProcess || !player->m_bIsInitComplete) return;

	if (sItemIndex < 0 || sItemIndex >= MAXITEMS) return;

	CItem * &itemDrop = player->m_pItemList[sItemIndex];
	if (!itemDrop || itemDrop->m_disabled) return;
	if (iAmount != -1 && iAmount < 0) return;

	if( (itemDrop->m_cItemType == ITEMTYPE_CONSUME || 
		itemDrop->m_cItemType == ITEMTYPE_ARROW) &&
		iAmount == -1) 
		iAmount = itemDrop->m_dwCount;


	if(memcmp(itemDrop->m_cName, pItemName, 20) != 0) return;
	if(m_pMapList[ player->m_cMapIndex ]->iCheckItem(player->m_sX, player->m_sY) == ITEM_RELIC)
		return;

	if ( ( (itemDrop->m_cItemType == ITEMTYPE_CONSUME) ||
		(itemDrop->m_cItemType == ITEMTYPE_ARROW) ) &&
		(((int)itemDrop->m_dwCount - iAmount) > 0) ) {
			pItem = new class CItem;
			if (pItem->InitItemAttr(itemDrop->m_cName) == false) {

				delete pItem;
				return;
			}
			else {
				if (iAmount <= 0) {

					delete pItem;
					return;
				}
				pItem->m_dwCount = (uint32)iAmount;
			}


			if ((uint32)iAmount > itemDrop->m_dwCount) {
				delete pItem;
				return;
			}

			itemDrop->m_dwCount -= iAmount;

			SetItemCount(iClientH, sItemIndex, itemDrop->m_dwCount);

			m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX,	player->m_sY, pItem);

			_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem, !bByPlayer);

			AddGroundItem(pItem, player->m_sX, player->m_sY, player->m_cMapIndex, TILECLEANTIMEPLAYER);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
				player->m_sX, player->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 

			SendNotifyMsg(NULL, iClientH, NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
	}
	else {

		ReleaseItemHandler(iClientH, sItemIndex, true);

		if ( player->m_bIsItemEquipped[sItemIndex] == true)
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, itemDrop->m_cEquipPos, sItemIndex, NULL, NULL);

		if ((itemDrop->m_sItemEffectType == ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(itemDrop->m_wCurLifeSpan == 0)) {
				delete itemDrop;
				itemDrop = NULL;
		}
		else {
			if(itemDrop->m_sIDnum != ITEM_RELIC || (m_astoria.get() &&
				m_astoria->IsRelicGenuine(itemDrop)))
			{
				if(itemDrop->m_sIDnum == ITEM_RELIC)
				{
					m_astoria->PlayerDropRelic(player);		
					UpdateRelicPos();
				}
				else
					AddGroundItem(itemDrop, player->m_sX, player->m_sY, player->m_cMapIndex, TILECLEANTIMEPLAYER);

				m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, 
					itemDrop);

				_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, itemDrop, !bByPlayer);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
					player->m_sX, player->m_sY,  
					itemDrop->m_sSprite, 
					itemDrop->m_sSpriteFrame, 
					itemDrop->m_cItemColor);
			}else{
				// delete the fake relic
				delete itemDrop;
			}
		}

		itemDrop = NULL;
		player->m_bIsItemEquipped[sItemIndex] = false;

		SendNotifyMsg(NULL, iClientH, NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);

		player->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	iCalcTotalWeight(iClientH);
}

int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
	uint32 * dwp;
	uint16  * wp;
	short sRemainItemSprite, sRemainItemSpriteFrame;
	char  cRemainItemColor, cData[100];
	int   iRet, iEraseReq;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	if(m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); 
	if (pItem != NULL) {

		if(!pItem->m_disabled && _bAddClientItemList(iClientH, pItem, &iEraseReq)) {

			if(m_astoria.get() && m_astoria->IsRelicGenuine(pItem))
			{
				m_astoria->PlayerGetRelic(m_pClientList[iClientH]);
			}
			_bItemLog(ITEMLOG_GET, iClientH, (int) -1, pItem);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
			if (iEraseReq == 1) delete pItem;
			if (m_pClientList[iClientH] == NULL) return 0;
		}
		else 
		{

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);

			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			if (m_pClientList[iClientH] == NULL) return 0;
		}
	}

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

bool CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return false;
	if (pItem == NULL) return false;


	if ((pItem->m_cItemType == ITEMTYPE_CONSUME) || (pItem->m_cItemType == ITEMTYPE_ARROW)) {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->GetWeight(pItem->m_dwCount)) > _iCalcMaxLoad(iClientH)) 
			return false;
	}
	else {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->GetWeight(1)) > _iCalcMaxLoad(iClientH)) 
			return false;
	}

	if ((pItem->m_cItemType == ITEMTYPE_CONSUME) || (pItem->m_cItemType == ITEMTYPE_ARROW)) {
		for (i = 0; i < MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {

					m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
					//delete pItem;
					*pDelReq = 1;

					iCalcTotalWeight(iClientH);

					return true;
			}
	}

	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {

			m_pClientList[iClientH]->m_pItemList[i] = pItem;

			m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
			m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

			*pDelReq = 0;

			if (pItem->m_cItemType == ITEMTYPE_ARROW)
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

			iCalcTotalWeight(iClientH);

			return true;
		}

	return false;
}


bool CGame::bEquipItemHandler(int iClientH, short sItemIndex, bool bNotify)
{
	char  cEquipPos;
	short sSpeed, sTemp;
	int   iTemp;

	if (m_pClientList[iClientH] == NULL) return false;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_EQUIP) return false;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return false;


	if (!m_pClientList[iClientH]->m_pItemList[sItemIndex]->IsManued() &&
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)
		return false;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:

			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return false;
			break;
		case 4:
		case 5:
		case 6:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return false;
			break;
		}
	}


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetWeight(1) > m_pClientList[iClientH]->GetStr()*100) return false;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	if (cEquipPos == EQUIPPOS_LHAND && m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled == true && !m_pClientList[iClientH]->IsGM()){
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
		ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
		return false;
	}

	if ((cEquipPos == EQUIPPOS_BODY) || (cEquipPos == EQUIPPOS_BOOTS) || (cEquipPos == EQUIPPOS_ARMS) || (cEquipPos == EQUIPPOS_HEAD)) {
		if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled == true && !m_pClientList[iClientH]->IsGM()){
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
			return false;
		}
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: 
			if (m_pClientList[iClientH]->GetStr() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
				return false;
			}
			break;
		case 11: // Dex
			if (m_pClientList[iClientH]->GetDex() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
				return false;
			}
			break;
		case 12: 
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
				return false;
			}
			break;
		case 13: // Int
			if (m_pClientList[iClientH]->GetInt() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
				return false;
			}
			break;
		case 14: // Mag
			if (m_pClientList[iClientH]->GetMag() < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
				return false;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], true);
				return false;
			}
			break;
		}
	}

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS10) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS20)) 
	{
		if(m_pClientList[iClientH]->GetInt() >= 100 && m_pClientList[iClientH]->GetMag() >= 100 &&  
			m_pClientList[iClientH]->m_iSpecialAbilityTime < 1)
		{
			m_pClientList[iClientH]->m_cMagicMastery[94] = true; //Resurrection
			SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
		}
	}
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_STORMBRINGER) 
	{
		if(!m_pClientList[iClientH]->IsGM() && m_pClientList[iClientH]->GetInt() <= 65)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
			ReleaseItemHandler(iClientH, sItemIndex, true);
			return false;
		}
	}
	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) 
	{
		if (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) 
		{
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], true);
			}
		}
	}

	if (cEquipPos == EQUIPPOS_NONE) return false;

	if (cEquipPos == EQUIPPOS_TWOHAND) {
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);
		else {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_RHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_RHAND ], false);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ], false);
		}
	}
	else {

		if ((cEquipPos == EQUIPPOS_LHAND) || (cEquipPos == EQUIPPOS_RHAND)) {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ], false);
		}

		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);
	}

	if(cEquipPos == EQUIPPOS_FULLBODY) {
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);
		else {
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], false);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], true);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], false);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ], false);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], false);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ], false);

		}
	}
	else
	{
		if ((cEquipPos == EQUIPPOS_HEAD) 
			|| (cEquipPos == EQUIPPOS_BODY)
			|| (cEquipPos == EQUIPPOS_ARMS)
			|| (cEquipPos == EQUIPPOS_BOOTS)
			|| (cEquipPos == EQUIPPOS_PANTS)
			|| (cEquipPos == EQUIPPOS_BACK)) {
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_FULLBODY ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ EQUIPPOS_FULLBODY ], false);
		}

		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], false);

	}
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = true;


	switch (cEquipPos) {
	case EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);

		m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;

#ifdef WEAPONSPEEDLIMIT
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) 
		{
		//case SKILL_ARCHERY:  if (sSpeed < 1) sSpeed = 1; break; 		
		//case SKILL_SHORTSWORD:  if (sSpeed < 0) sSpeed = 0; break; 
		//case SKILL_LONGSWORD:  if (sSpeed < 2) sSpeed = 2; break; 		
		//case SKILL_FENCING:  if (sSpeed < 1) sSpeed = 1; break; 
		//case SKILL_AXE: if (sSpeed < 3) sSpeed = 1; break; 		
		case SKILL_HAMMER: if (sSpeed < 1) sSpeed = 1; break; 		
		default: if (sSpeed < 0) sSpeed = 0; break; 		
		}			
#else
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		if (sSpeed < 0) sSpeed = 0;	
#endif
		iTemp = iTemp | sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;

		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;			
		sTemp = sTemp | (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue); 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xF0FFFFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_TWOHAND:

		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);



		m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ;


#ifdef WEAPONSPEEDLIMIT
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill) 
		{
		//case SKILL_ARCHERY:  if (sSpeed < 1) sSpeed = 1; break; 		
		//case SKILL_SHORTSWORD:  if (sSpeed < 0) sSpeed = 0; break; 
		//case SKILL_LONGSWORD:  if (sSpeed < 2) sSpeed = 2; break; 		
		//case SKILL_FENCING:  if (sSpeed < 1) sSpeed = 1; break; 
		//case SKILL_AXE: if (sSpeed < 3) sSpeed = 1; break; 		
		case SKILL_HAMMER: if (sSpeed < 1) sSpeed = 1; break; 		
		default: if (sSpeed < 0) sSpeed = 0; break; 		
		}	
#else
		sSpeed -= (m_pClientList[iClientH]->GetStr() / 13);
		if (sSpeed < 0) sSpeed = 0;
#endif

		iTemp = iTemp | sSpeed;
		m_pClientList[iClientH]->m_iStatus = iTemp;

		m_pClientList[iClientH]->m_iComboAttackCount = 0;
		break;

	case EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
		}
		else {
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;

			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp | 0x080;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
		}

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFF0FFFFF; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;			
		sTemp = sTemp | (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFF0FFF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFF0FF; 		
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BOOTS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFF0F; 
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;			
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFFF0; 		
		iTemp = iTemp | (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_FULLBODY: 
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}
	
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_SPECABLTY) {

		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;     // 1111111111110011   
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 1: 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	// 0100
			break;

		case 2: 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	// 1100
			break;

		case 3: 			
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	// 1000
			break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC; // 1111111111111100
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 50: 
		case 51:
		case 52: 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;	// 10
			break;

		default: 
			if (m_pClientList[iClientH]->m_iAdminUserLevel < 1 ) break ;
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;	 // 01
			break;
		}
	}

	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);

	if (bNotify) {
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);

		sTemp = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum;
		if (sTemp == ITEM_ANGELICPENDANT_DEX ||
			sTemp == ITEM_ANGELICPENDANT_INT ||
			sTemp == ITEM_ANGELICPENDANT_MAG ||
			sTemp == ITEM_ANGELICPENDANT_STR)
			SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
	}

	return true;
}


void CGame::SendEventToNearClient_TypeB(uint32 dwMsgID, uint16 wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
	int i, iRet, iShortCutIndex;
	char  * cp, cData[100];
	uint32 * dwp, dwTime;
	uint16 * wp;
	short * sp;
	bool bFlag;
	char  cKey ;

	cKey = (char)(rand() % 255) +1; 

	ZeroMemory(cData, sizeof(cData));

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = wMsgType;

	cp = (char *)(cData + INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	bFlag = true;
	iShortCutIndex = 0;

	CClient * pClient;
	while (bFlag == true) {

		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = false;

		pClient = m_pClientList[i];
		if ((bFlag == true) && (pClient != NULL)) {
			if ( (pClient->m_cMapIndex == cMapIndex) &&
				(pClient->m_sX >= sX - 10) &&
				(pClient->m_sX <= sX + 10) &&
				(pClient->m_sY >= sY - 8 ) &&
				(pClient->m_sY <= sY + 8 ) ) {

					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18,cKey);
			}
		}
	}
}

int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
	char cData[100];
	uint32 * dwp;
	uint16  * wp;
	int     iRet;
	short   sOwnerH;
	char    cOwnerType;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;


	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;


	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == true) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, true, true);
			return 0;
		}
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, uint32 dwMsgSize)
{
	int i;
	uint16  * wp, wResult;
	uint32 * dwp;
	char  * cp, cCharName[11], cData[100], cTxt[120];
	int iRet;

	
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;

	for (i = 1; i < MAXCLIENTS; i++) 
	{
		CClient * player = m_pClientList[i];

		if (player && memcmp(player->m_cCharName, cCharName, 10) == 0 &&
			player->m_iLevel >= 20 && player->m_iCharisma >= 20)
		{

			wp = (uint16 *)(pData + INDEX2_MSGTYPE);
			switch (*wp) 
			{
			case LOGRESMSGTYPE_CONFIRM:
				wResult = MSGTYPE_CONFIRM;
				player->m_iGuildRank = GUILDRANK_MASTER;

				ASSERT(guildMgr.FindGuild(player->m_iGuildGUID) == NULL);
				player->m_guild = new CGuild(player->m_iGuildGUID, player->m_cGuildName);
				guildMgr.Add(player->m_guild);
				player->m_guild->MemberLogin( player );

				wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", player->m_cGuildName, player->m_cCharName);
				PutLogList(cTxt);
				break;

			case LOGRESMSGTYPE_REJECT:
				wResult = MSGTYPE_REJECT;
				ZeroMemory(player->m_cGuildName, sizeof(player->m_cGuildName));
				memcpy(player->m_cGuildName, "NONE", 4);
				player->m_iGuildRank = GUILDRANK_NONE;  
				player->m_iGuildGUID = -1;
				player->m_guild = NULL;
				wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", player->m_cGuildName, player->m_cCharName);
				PutLogList(cTxt);
				break;
			}

			dwp  = (uint32 *)(cData + INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
			*wp  = wResult;

			iRet = player->m_pXSock->iSendMsg(cData, 6);
			switch (iRet)
			{
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(i, true, true);
				return;
			}

			return;
		}
	}

	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char * cp, cGuildName[21], cTxt[120], cData[100];
	uint32 * dwp;
	uint16  * wp;
	int     iRet;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_bIsCrusadeMode == true) return;

	cp = (char *)(pData	+ INDEX2_MSGTYPE + 2);

	cp += 10;
	cp += 10;
	cp += 10;

	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if (m_pClientList[iClientH]->m_iGuildRank != GUILDRANK_NONE) {
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if (m_pClientList[iClientH]->m_iLevel < 20 ||
			m_pClientList[iClientH]->m_iCharisma < 20 ||
			m_pClientList[iClientH]->IsNeutral()	||
			m_pClientList[iClientH]->m_iIsOnTown == PK ) 
		{

				ZeroMemory(cData, sizeof(cData));

				dwp  = (uint32 *)(cData + INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_CREATENEWGUILD;
				wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
				*wp  = MSGTYPE_REJECT;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) 
				{
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}
		}
		else {
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());

			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == true) return;

	cp = (char *)(pData	+ INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp += 10;
	cp += 10;
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	if(!gldRankPerm[ m_pClientList[iClientH]->m_iGuildRank ].canDisband || 
		memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)
	{
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
#ifdef TAIWANLOG 
		_bItemLog(ITEMLOG_GUILDDISMISS,iClientH, cGuildName, NULL) ;
#endif
		bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, uint32 dwMsgSize)
{
	uint16  * wp, wResult;
	uint32 * dwp;
	char  * cp, cCharName[11], cData[100], cTxt[120];
	int iRet;

	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;

	for(int i = 1; i < MAXCLIENTS; i++) 
	{
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {

			wp = (uint16 *)(pData + INDEX2_MSGTYPE);
			switch (*wp) 
			{
			case LOGRESMSGTYPE_CONFIRM:
				wResult = MSGTYPE_CONFIRM;
				wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);

				if(m_pClientList[i]->m_guild)
				{
					SendGuildMsg(i, NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
					guildMgr.Remove( m_pClientList[i]->m_guild );
				}

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_CLEARGUILDNAME, m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);
				break;

			case LOGRESMSGTYPE_REJECT:
				wResult = MSGTYPE_REJECT;
				wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;
			}

			dwp  = (uint32 *)(cData + INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_DISBANDGUILD;
			wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
			*wp  = wResult;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) 
			{
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(i, true, true);
				return;
			}
			return;
		}
	}

	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::ResponseGuildInfo(char * data)
{
	int16 guildID;
	Pop(data, (uint16&)guildID);

	ASSERT(guildMgr.FindGuild(guildID) == NULL);

	char guildName[20];
	Pop(data, guildName, 20);
	CGuild * guild = new CGuild(guildID, guildName, data);
	
	guildMgr.Add(guild);
}

void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
	class CItem * pItem;
	char  * cp, cItemName[21], cData[100];
	uint32 * dwp, dwGoldCount, dwItemCount;
	uint16  * wp, wTempPrice;
	int   i, iRet, iEraseReq, iGoldWeight;
	int   iCost,iCost2, iDiscountRatio, iDiscountCost;
	double dTmp1, dTmp2, dTmp3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;


	// if (!m_pClientList[iClientH]->IsNeutral() && m_pClientList[iClientH]->m_bIsOnShop == false ) {
	if ( m_pClientList[iClientH]->m_bIsOnShop == false ) {
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cItemName, sizeof(cItemName));

	if (memcmp(pItemName, ITEMNAME_10ARROWS, 8) == 0) {
		strcpy(cItemName, ITEMNAME_ARROW);
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, ITEMNAME_100ARROWS, 9) == 0) {
		strcpy(cItemName, ITEMNAME_ARROW);
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}

	for (i = 1; i <= iNum; i++) {
		pItem = new class CItem;
		if (pItem->InitItemAttr(cItemName) == false) {

			delete pItem;
		}
		else {
			if (pItem->m_bIsForSale == false) {
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;

			pItem->m_sTouchEffectType   = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);

#ifdef LOGTIME
			pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
			SYSTEMTIME SysTime;
			char cTemp[20] ;

			GetLocalTime(&SysTime); //
			ZeroMemory(cTemp, sizeof(cTemp));
			//			wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
			wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif

			if(m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_side)
			{
				iCost =(int)((float)(pItem->m_wPrice) * 0.9f + 0.5f) ;
				iCost = iCost * pItem->m_dwCount;
				iCost2 = pItem->m_wPrice * pItem->m_dwCount;
			}
			else
			{
				iCost2 = iCost = pItem->m_wPrice * pItem->m_dwCount;
			}

			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -10)/ 4) ;

			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -50)/ -4);   // 50..90 charisma gives 0..10% price discount.	

			if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_side){ // Lost last Crusade +10% prices
				iDiscountRatio += 10;
			}	


			if (iDiscountRatio <  0 ) iDiscountRatio =  0;	 // Never lower prices
			if (iDiscountRatio > 10 ) iDiscountRatio = 10;	 // Sometimes increase them up to 10%

			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;

			if ((iCost - iDiscountCost) <= (iCost2/2)) {
				iDiscountCost = iCost - (iCost2/2) + 1; 
			}
			if (m_pClientList[iClientH]->IsHeldLoser()) (iCost = iCost *1.5);

			if ( dwGoldCount < (uint32)(iCost - iDiscountCost) ) {

				delete pItem;

				dwp  = (uint32 *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + INDEX2_MSGTYPE + 2);
				*cp  = -1; 
				cp++;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}
				return;
			}

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				dwp  = (uint32 *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_ITEMPURCHASED;

				cp = (char *)(cData + INDEX2_MSGTYPE + 2);

				WriteItemData(cp, pItem);

				wp  = (uint16 *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;

				if (iEraseReq == 1){
					delete pItem;
					pItem = NULL;
				}


				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);


				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				iCalcTotalWeight(iClientH);


				m_stCityStatus[m_pClientList[iClientH]->m_side].iFunds += wTempPrice;

				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);

					return;
				}
			}
			else 
			{
				delete pItem;

				iCalcTotalWeight(iClientH);

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
				if (m_pClientList[iClientH] == NULL) return;
			}
		}
	} // for ??

	if ( i <= 1) return ;
#ifdef TAIWANLOG  
	_bItemLog(ITEMLOG_BUY, iClientH, i - 1, pItem);
#endif
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, uint16 wObjectID, char * pItemName)
{
	int iEraseReq;
	short sOwnerH;
	char  cOwnerType, cCharName[21];
	CItem * pItem;
	bool save = false;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;
	if (player->m_bIsOnWaitingProcess == true) return;	//DEBUG
	if (player->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (player->m_pItemList[sItemIndex] == NULL) return;
	if (iAmount <= 0) return;
	if (player->m_pItemList[sItemIndex]->m_disabled) return;

	if (wObjectID < MAXCLIENTS) {
		// Player	
		if( m_pClientList[wObjectID] != NULL && player->m_cMapIndex != m_pClientList[wObjectID]->m_cMapIndex) return;
	}
	else if ( (wObjectID > 10000) && (wObjectID < (10000 + MAXNPCS)) ) {
		if( m_pNpcList[wObjectID - 10000] != NULL && player->m_cMapIndex != m_pNpcList[wObjectID - 10000]->m_cMapIndex) return;
	}

	if (memcmp(player->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	if(player->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_RELIC)
		return;

	ZeroMemory(cCharName, sizeof(cCharName));

	if ( (player->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_CONSUME ||
		player->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_ARROW ) &&
		player->m_pItemList[sItemIndex]->m_dwCount > (uint32)iAmount )
	{
			pItem = new CItem;
			if (pItem->InitItemAttr(player->m_pItemList[sItemIndex]->m_cName) == false) {
				
				delete pItem;
				return;
			}
			else {
				pItem->m_dwCount = iAmount;
			}

			
			player->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
			
			SetItemCount(iClientH, sItemIndex, player->m_pItemList[sItemIndex]->m_dwCount);

			m_pMapList[player->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			
			if (wObjectID != NULL) {
				if (wObjectID < 10000) {
					
					if ((wObjectID > 0) && (wObjectID < MAXCLIENTS)) {
						if (m_pClientList[wObjectID] != NULL) {
							if ((uint16)sOwnerH != wObjectID) sOwnerH = NULL;
						}
					}
				}
				else {
					// NPC
					if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < MAXNPCS)) {
						if (m_pNpcList[wObjectID - 10000] != NULL) {
							if ((uint16)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
						}
					}
				}
			}

			if (sOwnerH == NULL) {
				
				
				m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, pItem);

				_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);
				
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
					player->m_sX, player->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
			}
			else {
				
				if (cOwnerType == OWNERTYPE_PLAYER) {
					
					memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

					if (sOwnerH == iClientH) {
						
						delete pItem;
						return;
					}

					if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == true) {
						
						_bItemLog(ITEMLOG_GIVE, iClientH, sOwnerH, pItem);
						SendItemNotifyMsg(sOwnerH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

						if (iEraseReq == 1) delete pItem;
						
						SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
					}
					else {

						m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, 
							player->m_sY, 
							pItem);

 
						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
							player->m_sX, player->m_sY,  
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

						
						SendItemNotifyMsg(sOwnerH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);

						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
					}

				}
				else {
					
					memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

					if(memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
						if (bSetItemToBankItem(iClientH, pItem) == false) {
							player->Notify(NULL, NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

							m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, pItem);

							_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);

							SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
								player->m_sX, player->m_sY,  
								pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
						}
					}else if(memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Diana", 5) == 0) {
						if (!player->m_guild || !player->m_guild->AddToWarehouse(pItem,player) ) {
							player->Notify(NULL, NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

							m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, pItem);

							_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);

							SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
								player->m_sX, player->m_sY,  
								pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
						}else
							save = true;
					}else{						
						m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, pItem);

						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
							player->m_sX, player->m_sY,  
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					}
				}
			}
	}
	else {
		

		
		ReleaseItemHandler(iClientH, sItemIndex, true);

		
		if (player->m_pItemList[sItemIndex]->m_cItemType == ITEMTYPE_ARROW) 
			player->m_cArrowIndex = -1;

		
		m_pMapList[player->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); 

		
		if (wObjectID != NULL) {
			if (wObjectID < 10000) {
				
				if ((wObjectID > 0) && (wObjectID < MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((uint16)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((uint16)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			
			
			m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, 
				player->m_sY, 
				player->m_pItemList[sItemIndex]);

			_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, player->m_pItemList[sItemIndex]);

			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
				player->m_sX, player->m_sY,  
				player->m_pItemList[sItemIndex]->m_sSprite, 
				player->m_pItemList[sItemIndex]->m_sSpriteFrame, 
				player->m_pItemList[sItemIndex]->m_cItemColor);

			
			SendNotifyMsg(NULL, iClientH, NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		}
		else {
			if (cOwnerType == OWNERTYPE_PLAYER) {
				
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = player->m_pItemList[sItemIndex];

				if (pItem->m_sIDnum == ITEM_GUILDADMISSIONTICKET)
				{
					if (player->m_iGuildRank == GUILDRANK_NONE && 
						!player->IsNeutral() &&
						player->m_side == m_pClientList[sOwnerH]->m_side &&
						gldRankPerm[ m_pClientList[sOwnerH]->m_iGuildRank ].canInvite ) 
					{		
						SendNotifyMsg(iClientH, sOwnerH, NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);

						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				if (!m_bIsCrusadeMode && 
					player->m_pItemList[sItemIndex]->m_sIDnum == ITEM_GUILDSECESSIONTICKET) 
				{
					if(memcmp(player->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0 && 
						player->m_iGuildRank != GUILDRANK_NONE && player->m_iGuildRank != GUILDRANK_MASTER &&
						gldRankPerm[ m_pClientList[sOwnerH]->m_iGuildRank ].canBan) 
					{
						SendNotifyMsg(iClientH, sOwnerH, NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == true) {
					_bItemLog(ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					SendItemNotifyMsg(sOwnerH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

					if (iEraseReq == 1) delete pItem;

				}
				else {
					m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, 
						player->m_sY, 
						player->m_pItemList[sItemIndex]);
					
					_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, player->m_pItemList[sItemIndex]);

					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
						player->m_sX, player->m_sY,  
						player->m_pItemList[sItemIndex]->m_sSprite, 
						player->m_pItemList[sItemIndex]->m_sSpriteFrame, 
						player->m_pItemList[sItemIndex]->m_cItemColor);

					SendItemNotifyMsg(sOwnerH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);

					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}
			else {
				
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					if (bSetItemToBankItem(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]) == false) {
						
						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
												
						m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, player->m_pItemList[sItemIndex]);
												
						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, player->m_pItemList[sItemIndex]);
												
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
							player->m_sX, player->m_sY,  
							player->m_pItemList[sItemIndex]->m_sSprite, 
							player->m_pItemList[sItemIndex]->m_sSpriteFrame, 
							player->m_pItemList[sItemIndex]->m_cItemColor);
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Diana", 5) == 0) {
					if (!player->m_guild || !player->m_guild->AddToWarehouse(player->m_pItemList[sItemIndex], player) )
					{
						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
												
						m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, player->m_pItemList[sItemIndex]);
												
						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, player->m_pItemList[sItemIndex]);
												
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
							player->m_sX, player->m_sY,  
							player->m_pItemList[sItemIndex]->m_sSprite, 
							player->m_pItemList[sItemIndex]->m_sSpriteFrame, 
							player->m_pItemList[sItemIndex]->m_cItemColor);
					}else
						save = true;
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0)
				{
					if(!m_bIsCrusadeMode && player->m_pItemList[sItemIndex]->m_sIDnum == ITEM_GUILDSECESSIONTICKET)
					{
						if(player->m_iGuildRank != GUILDRANK_MASTER && player->m_iGuildRank != GUILDRANK_NONE)
						{
							SendNotifyMsg(iClientH, iClientH, COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);

							player->WithdrawFromGuild();
						}

						
						delete player->m_pItemList[sItemIndex];
					} 
					else {
						
						m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, 
							player->m_sY, 
							player->m_pItemList[sItemIndex]);

						
						_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, player->m_pItemList[sItemIndex]);

						
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
							player->m_sX, player->m_sY,  
							player->m_pItemList[sItemIndex]->m_sSprite, 
							player->m_pItemList[sItemIndex]->m_sSpriteFrame, 
							player->m_pItemList[sItemIndex]->m_cItemColor);

						
						ZeroMemory(cCharName, sizeof(cCharName));

					}
				}
				else {
					

					m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, 
						player->m_sY, 
						player->m_pItemList[sItemIndex]);

					
					_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, player->m_pItemList[sItemIndex]);

					
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
						player->m_sX, player->m_sY,  
						player->m_pItemList[sItemIndex]->m_sSprite, 
						player->m_pItemList[sItemIndex]->m_sSpriteFrame, 
						player->m_pItemList[sItemIndex]->m_cItemColor);

					
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}

			
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}

REMOVE_ITEM_PROCEDURE:;

		
		if (player == NULL) return;

		
		player->m_pItemList[sItemIndex] = NULL;
		player->m_bIsItemEquipped[sItemIndex] = false;
		
		if(save)
		{
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, player->m_handle);
			player->m_dwAutoSaveTime = timeGetTime();
			if(player->m_guild)
				player->m_guild->Save(true);
		}

		
		player->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, uint16 wMsgType, uint32 sV1, uint32 sV2, uint32 sV3, const char * pString, 
								  uint32 sV4, uint32 sV5, uint32 sV6, uint32 sV7, uint32 sV8, uint32 sV9, char * pString2) const
{
	char cData[1000];
	uint32 * dwp;
	uint16  * wp;
	char  * cp, *index;
	short * sp;
	int   * ip, iRet, i;
	CItem * pItem;

	CClient * player = m_pClientList[iToH];
	if(!player) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	index = (char*)dwp;
	*dwp = MSGID_NOTIFY;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ INDEX2_MSGTYPE + 2);

	CNpc * npc;

	switch (wMsgType)
	{
	case NOTIFY_PINGMAP:
		Push(cp, uint8(sV1));
		Push(cp, uint16(sV2));
		Push(cp, uint16(sV3));

		iRet = player->m_pXSock->iSendMsg(cData, cp - cData);
		break;

	case NOTIFY_DONATEEVENTINFO:
		Push(cp, m_donateEventPot);
		
		iRet = player->m_pXSock->iSendMsg(cData, cp - cData);
		break;

	case NOTIFY_ADMININFO:
		Push(cp, (uint32)player->m_iAdminUserLevel);
		Push(cp, player->m_GMFlags);
		
		iRet = player->m_pXSock->iSendMsg(cData, cp - cData);
		break;

	case NOTIFY_MAILRECEIVED:
	case NOTIFY_GUILDBOARDPOST:
		Push(cp, pString);

		iRet = player->m_pXSock->iSendMsg(cData, cp - cData);
		break;

	case NOTIFY_MONSTERCOUNT:
		Push(cp, (uint16)sV1);
		npc = (CNpc*)sV2;
		if(npc)
		{
			Push(cp, (uint16)npc->m_sX);
			Push(cp, (uint16)npc->m_sY);
		} else {
			Push(cp, (uint16)-1);
			Push(cp, (uint16)-1);
		}
		iRet = player->m_pXSock->iSendMsg(cData, cp - cData);
		break;

	case NOTIFY_GUILDCONTRIBUTERSP:
		Push(cp, (uint8)sV1);
		Push(cp, sV2);

		iRet = player->m_pXSock->iSendMsg(cData, cp - cData);
		break;

	case NOTIFY_ITEMTOGUILDBANK:
		pItem = (CItem*)sV1;
		if (!pItem) return;

		Push(cp, sV1);
		Push(cp, sV2); // warehouseVer

		WriteItemData(cp, pItem);

		Push(cp, (uint16)pItem->m_sItemEffectValue2);
		Push(cp, pItem->m_dwAttribute);
		Push(cp, (uint8)pItem->m_sItemSpecEffectValue2);
		
		for(i = 0; i < MAXITEMSOCKETS; i++)
		{
			Push(cp, pItem->m_sockets[i]);
		}
		iRet = player->m_pXSock->iSendMsg(cData, cp - cData);
		break;

	case NOTIFY_SOCCERVICTORY: 
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;
		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_SOCCER:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;
		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SOCCERBEGIN:					
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_HELDENIANVICTORY: //0x0BEB
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;
		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case NOTIFY_HELDENIANSTART:
	case NOTIFY_HELDENIANEND:					
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;
	case NOTIFY_HELDENIANCOUNT:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV3;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV4;		
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV5;		
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV6;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV7;		
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV8;		
		cp += 2;
		iRet = player->m_pXSock->iSendMsg(cData, 22);
		break;

	case NOTIFY_APOCGATECLOSE:
	case NOTIFY_APOCGATEOPEN:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;
		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;
		memcpy(cp,pString,10);
		cp += 10;
		iRet = player->m_pXSock->iSendMsg(cData, 24);
		break;

	case NOTIFY_ABADDONKILLED:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		iRet = player->m_pXSock->iSendMsg(cData, 16);
		break;

	case NOTIFY_APOCGATESTARTMSG:
	case NOTIFY_APOCGATEENDMSG:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_LGNPTS:
		dwp = (uint32*)cp;
		*dwp = sV1;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_RESPONSE_HUNTMODE:
		memcpy(cp, pString, 10);
		cp += 10;

		iRet = player->m_pXSock->iSendMsg(cData, 16);
		break;

	case NOTIFY_REQGUILDNAMEANSWER:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_TCLOC:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV4;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV5;
		cp += 2;

		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = player->m_pXSock->iSendMsg(cData, 34);
		break;

	case NOTIFY_SLATE_STATUS:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_QUESTCOUNTER:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 24);
		break;

	case NOTIFY_SLATE_EXP:
	case NOTIFY_SLATE_MANA:
	case NOTIFY_SLATE_INVINCIBLE:
	case NOTIFY_RESURRECTPLAYER:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SLATE_CREATEFAIL:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SLATE_CREATESUCCESS:
		dwp  = (uint32 *)cp;
		*dwp = sV1;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_PARTY:
		switch (sV1) {
		case 4:
		case 6:
			wp  = (uint16 *)cp;
			*wp = (uint16)sV1;
			cp += 2;
			wp  = (uint16 *)cp;
			*wp = (uint16)sV2;
			cp += 2;
			wp  = (uint16 *)cp;
			*wp = (uint16)sV3;
			cp += 2;
			memcpy(cp, pString, 10);
			cp += 10;
			iRet = player->m_pXSock->iSendMsg(cData, 12 + 10);
			break;

		case 5:
			wp  = (uint16 *)cp;
			*wp = (uint16)sV1;
			cp += 2;
			wp  = (uint16 *)cp;
			*wp = (uint16)sV2;
			cp += 2;
			wp  = (uint16 *)cp;
			*wp = (uint16)sV3;
			cp += 2;
			memcpy(cp, pString, sV3*11);
			cp += sV3*11;
			iRet = player->m_pXSock->iSendMsg(cData, 12 + sV3*11);
			break;

		default:
			wp  = (uint16 *)cp;
			*wp = (uint16)sV1;
			cp += 2;
			wp  = (uint16 *)cp;
			*wp = (uint16)sV2;
			cp += 2;
			wp  = (uint16 *)cp;
			*wp = (uint16)sV3;
			cp += 2;
			wp  = (uint16 *)cp;
			*wp = (uint16)sV4;
			cp += 2;
			iRet = player->m_pXSock->iSendMsg(cData, 14);
			break;
		}
		break;

	case NOTIFY_PARTY_COORDS:
		memcpy(cp, pString, 10);
		cp+= 10;
		sp  = (short *)cp;
		*sp = sV1;
		cp += 2;
		sp  = (short *)cp; 
		*sp = sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 20);
		break;

	case NOTIFY_GRANDMAGICRESULT:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV4;
		cp += 2;

		//		sp = (short *)cp;
		//		*sp = (short)sV9;
		//		cp += 2;

		if (sV9 > 0)  {
			memcpy(cp,pString2, (sV9+1)*2) ;
			cp += (sV9+1)*2;
		}
		else 
		{
			sp = (short *)cp;
			*sp = (short)0;
			cp += 2;
		}

		iRet = player->m_pXSock->iSendMsg(cData, 24 + (sV9+1)*2 );
		break;

	case NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = player->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = player->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = player->m_pXSock->iSendMsg(cData, 18);
		break;

	case NOTIFY_BUILDITEMSUCCESS:
	case NOTIFY_BUILDITEMFAIL:
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 38);
		break;

	case NOTIFY_CANNOTCONSTRUCT:
	case NOTIFY_METEORSTRIKECOMING:
	case NOTIFY_METEORSTRIKEHIT:
	case NOTIFY_SPECIALABILITYENABLED:
	case NOTIFY_FORCEDISCONN:
	case NOTIFY_OBSERVERMODE:
	case NOTIFY_QUESTCOMPLETED:
	case NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 44);
		break;

	case NOTIFY_GIZONITEMUPGRADELEFT:
	case NOTIFY_ITEMATTRIBUTECHANGE:

		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		dwp = (uint32 *)cp;
		*dwp = (uint32)sV2;
		cp += 4;

		dwp = (uint32 *)cp;
		*dwp = (uint32)sV3;
		cp += 4;

		dwp = (uint32 *)cp;
		*dwp = (uint32)sV4;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 20);
		break; 

	case NOTIFY_ITEMUPGRADEFAIL:

		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);

		break ;

	case NOTIFY_GIZONEITEMCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		*cp = (char)sV2;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		*cp = (char)sV6;
		cp++;

		*cp = (char)sV7;
		cp++;


		dwp  = (uint32 *)cp;
		*dwp = (uint32)sV8;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;


		iRet = player->m_pXSock->iSendMsg(cData, 41);
		break;

	case NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_ENERGYSPHERECREATED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 30);
		break;

	case NOTIFY_ITEMSOCKETCHANGE:
		Push(cp, (uint16)sV1);

		pItem = (CItem*)sV2;
		for(i = 0; i < MAXITEMSOCKETS; i++)
		{
			Push(cp, pItem->m_sockets[i]);
		}

		iRet = player->m_pXSock->iSendMsg(cData, cp - index);
		break;

	case NOTIFY_NOMOREAGRICULTURE:	   
	case NOTIFY_AGRICULTURESKILLLIMIT: 
	case NOTIFY_AGRICULTURENOAREA:     
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_NOMORECRUSADESTRUCTURE:
	case NOTIFY_EXCHANGEITEMCOMPLETE:
	case NOTIFY_CANCELEXCHANGEITEM:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		pItem = (CItem*)sV2;
		
		Push(cp, (uint16)pItem->m_sSprite);
		Push(cp, (uint16)pItem->m_sSpriteFrame);
		Push(cp, sV3); // amount
		Push(cp, (uint8)pItem->m_cItemColor);
		Push(cp, (uint16)pItem->m_wCurLifeSpan);
		Push(cp, (uint16)pItem->m_wMaxLifeSpan);
		Push(cp, (uint16)(pItem->m_sItemSpecEffectValue2 + 100));
		Push(cp, pItem->m_cName, 20);

		Push(cp, m_pClientList[iFromH]->m_cCharName, 10);
		Push(cp, pItem->m_dwAttribute);
		for(i = 0; i < MAXITEMSOCKETS; i++)
		{
			Push(cp, pItem->m_sockets[i]);
		}
		iRet = player->m_pXSock->iSendMsg(cData, 57 + MAXITEMSOCKETS);
		break;

	case NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		pItem = (CItem*)sV2;
		
		Push(cp, (uint16)pItem->m_sSprite);
		Push(cp, (uint16)pItem->m_sSpriteFrame);
		Push(cp, sV3); // amount
		Push(cp, (uint8)pItem->m_cItemColor);
		Push(cp, (uint16)pItem->m_wCurLifeSpan);
		Push(cp, (uint16)pItem->m_wMaxLifeSpan);
		Push(cp, (uint16)(pItem->m_sItemSpecEffectValue2 + 100));
		Push(cp, pItem->m_cName, 20);

		Push(cp, m_pClientList[iFromH]->m_cCharName, 10);
		Push(cp, pItem->m_dwAttribute);
		for(i = 0; i < MAXITEMSOCKETS; i++)
		{
			Push(cp, pItem->m_sockets[i]);
		}

		iRet = player->m_pXSock->iSendMsg(cData, 57 + MAXITEMSOCKETS);
		break;

	case NOTIFY_NOTFLAGSPOT:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_ITEMPOSLIST:
		for (i = 0; i < MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = player->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = player->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = player->m_pXSock->iSendMsg(cData, 6 + MAXITEMS*4);
		break;

	case NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		ip++;
		*ip = (int)sV2;

		iRet = player->m_pXSock->iSendMsg(cData, 14);
		break;

	case NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 22);
		break;

	case NOTIFY_CONSTRUCTIONPOINT:
	case NOTIFY_SPECIALABILITYSTATUS:
	case NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 12);
		break;

	case NOTIFY_DOWNSKILLINDEXSET:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (uint32 *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (uint32 *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = player->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 64);
		break;
	case NOTIFY_EVENTILLUSION:
	case NOTIFY_EVENTTP:
		*cp = (char)sV1;
		cp++;
		*cp = (char)sV2;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_EVENTSPELL:
		*cp = sV1;
		cp++;
		*cp = sV2;
		cp++;
		*cp = player->IsGM();
		cp++;
		iRet = player->m_pXSock->iSendMsg(cData, 9);
		break;

	case NOTIFY_EVENTARMOR:
	case NOTIFY_EVENTSHIELD:
	case NOTIFY_EVENTCHAT:
	case NOTIFY_EVENTPARTY:
		*cp = sV1;
		cp++;
		*cp = player->IsGM();
		cp++;
		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_EVENTRESET:
	case NOTIFY_CRAFTING_SUCCESS:
	case NOTIFY_PORTIONSUCCESS:
	case NOTIFY_LOWPORTIONSKILL:
	case NOTIFY_PORTIONFAIL:
	case NOTIFY_NOMATCHINGPORTION:
	case NOTIFY_CRAFTING_FAIL:
	case NOTIFY_NOMATCHINGCRAFTING:
	case NOTIFY_NO_CRAFT_CONTRIB: 
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = player->m_iSuperAttackLeft;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_SAFEATTACKMODE:
		*cp = player->m_bIsSafeAttackMode;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_QUERY_JOINPARTY:
	case NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = player->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;

	case NOTIFY_REWARDGOLD:
		dwp = (uint32 *)cp;
		*dwp = player->m_iRewardGold;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_GLOBALATTACKMODE:
	case NOTIFY_WEATHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_MONSTEREVENT_POSITION:
		*cp = (char)sV3;
		cp++;

		sp = (short*)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short*)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 11);
		break;


	case NOTIFY_FISHCANCELED:
	case NOTIFY_FISHSUCCESS:
	case NOTIFY_FISHFAIL:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_DEBUGMSG:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_FISHCHANCE:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_ENERGYSPHEREGOALIN:
	case NOTIFY_EVENTFISHMODE:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = NULL;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case NOTIFY_CANNOTRATING:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = player->m_reputation;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 22);
		break;

	case NOTIFY_ADMINUSERLEVELLOW:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_PLAYERSHUTUP:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = player->m_pXSock->iSendMsg(cData, 19);
		break;

	case NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_TOBERECALLED:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;

	case NOTIFY_PLAYERONGAME:
	case NOTIFY_FRIENDONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		if (pString != NULL) {
			memcpy(cp, pString2, 14);
			cp += 14;
		}
		iRet = player->m_pXSock->iSendMsg(cData, 31);
		break;

	case NOTIFY_WHISPERMODEON:
	case NOTIFY_WHISPERMODEOFF:
	case NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;
		memcpy(cp, "             ", 10);
		cp += 10;
		iRet = player->m_pXSock->iSendMsg(cData, 27);
		break;

	case NOTIFY_ITEMSOLD:
	case NOTIFY_ITEMREPAIRED:
		dwp = (uint32 *)cp;
		*dwp = (uint32)sV1;
		cp += 4;
		dwp = (uint32 *)cp;
		*dwp = (uint32)sV2;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 14);
		break;

	case NOTIFY_REPAIRITEMPRICE:
	case NOTIFY_SELLITEMPRICE:
		dwp = (uint32 *)cp;
		*dwp = (uint32)sV1;
		cp += 4;
		dwp = (uint32 *)cp;
		*dwp = (uint32)sV2;
		cp += 4;
		dwp = (uint32 *)cp;
		*dwp = (uint32)sV3;
		cp += 4;
		dwp = (uint32 *)cp;
		*dwp = (uint32)sV4;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 42);
		break;

	case NOTIFY_CANNOTREPAIRITEM:
	case NOTIFY_CANNOTSELLITEM:
		wp = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		wp = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 30);

		break;

		//(word)sV1, sV2
	case NOTIFY_SHOWMAP:
		wp  = (uint16 *)cp;  
		*wp = (uint16)sV1;
		cp += 2;

		wp  = (uint16 *)cp;  
		*wp = (uint16)sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

		//(word)sV1
	case NOTIFY_SKILLUSINGEND:
		wp  = (uint16 *)cp;  
		*wp = (uint16)sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_TOTALUSERS:
		wp  = (uint16 *)cp;    
		*wp = (uint16)(m_iTotalGameServerClients + m_onlineCntAdd) ; //_iGetTotalClients();
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

		// (char)sV1
	case NOTIFY_EVENTSTART:
	case NOTIFY_EVENTSTARTING:
	case NOTIFY_EVENTSTARTING2:
	case NOTIFY_EVENTSTARTING3:
	case NOTIFY_RELICINALTAR:
		*cp = (char)sV1;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_EVENTWINNER:
		// event
		*cp = (char)sV1;
		cp++;

		// winner
		*cp = (char)sV2;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_CASUALTIES:
		wp  = (uint16 *)cp;  
		*wp = (uint16)sV1; // Aresden deaths
		cp += 2;

		wp  = (uint16 *)cp;  
		*wp = (uint16)sV2; // Elvine
		cp += 2;

		wp  = (uint16 *)cp;  
		*wp = (uint16)sV3; // Istria
		cp += 2;

		wp  = (uint16 *)cp;  
		*wp = (uint16)sV4; // Aresden kills
		cp += 2;

		wp  = (uint16 *)cp;  
		*wp = (uint16)sV5; // Elvine
		cp += 2;

		wp  = (uint16 *)cp;  
		*wp = (uint16)sV6; // Istria
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 18);
		break;

	case NOTIFY_SHIELDHP:
		Push(cp, (uint8)sV1);
		Push(cp, (uint16)sV2);
		
		iRet = player->m_pXSock->iSendMsg(cData, 9);
		break;

	case NOTIFY_RELICPOSITION:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1; //Relic X
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV2; //Relic Y
		cp += 2;
		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_RELICGRABBED:
		memcpy(cp, pString, 10);
		cp += 10;
		iRet = player->m_pXSock->iSendMsg(cData, 17);
		break;

	case NOTIFY_MAGICEFFECTOFF:
	case NOTIFY_MAGICEFFECTON:
		wp  = (uint16 *)cp;  
		*wp = (uint16)sV1;
		cp += 2;

		dwp  = (uint32 *)cp;  
		*dwp = (uint32)sV2;
		cp += 4;

		dwp  = (uint32 *)cp;  
		*dwp = (uint32)sV3;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 16);
		break;

	case NOTIFY_CANNOTITEMTOBANK:
	case NOTIFY_SETTING_FAILED:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_SERVERCHANGE:
		memcpy(cp, player->m_cMapName, 10);
		cp += 10;

		if (m_iGameServerMode == 1) // LAN
			memcpy(cp, m_cGameServerAddrExternal, 15);
		else // INTERNET
			memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;

		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 16 +19);
		break;

	case NOTIFY_SKILL:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SETITEMCOUNT:
		wp  = (uint16 *)cp;  
		*wp = (uint16)sV1;
		cp += 2;

		dwp  = (uint32 *)cp;  
		*dwp = (uint32)sV2;
		cp += 4;

		*cp = (char)sV3;
		cp++;

		iRet = player->m_pXSock->iSendMsg(cData, 13);
		break;

	case NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		wp = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 12);
		break;

	case NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 12);
		break;

	case NOTIFY_CANNOTGIVEITEM:
	case NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 32);
		break;

	case NOTIFY_ENEMYKILLREWARD:
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iExp;
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)player->m_iWarContribution;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 48);
		break;

	case NOTIFY_PKCAPTURED:

		wp  = (uint16 *)cp;
		*wp = (uint16)sV1;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iRewardGold;
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = player->m_iExp;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 28);
		break;

	case NOTIFY_PKPENALTY:

		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iExp;
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->GetStr();
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iVit;
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->GetDex();
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->GetInt();
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->GetMag();
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iCharisma;
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iPKCount;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 38);
		break;

	case NOTIFY_TRAVELERLIMITEDLEVEL:
	case NOTIFY_LIMITEDLEVEL:

		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iExp;
		cp += 4;
		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_ITEMRELEASED:
	case NOTIFY_ITEMLIFESPANEND:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_KILLED:

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = player->m_pXSock->iSendMsg(cData, 26);
		break;

	case NOTIFY_EXP:
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = player->m_reputation;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 14);
		break;

	case NOTIFY_HP:
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iHP;
		cp += 4;
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iMP; 
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 14);
		break;

	case NOTIFY_MP:
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iMP;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SP:
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iSP;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_CHARISMA:
		dwp  = (uint32 *)cp;
		*dwp = (uint32)player->m_iCharisma;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SETTING_SUCCESS:
	case NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = player->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = player->GetStr();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = player->m_iVit;
		cp  += 4;

		ip   = (int *)cp;
		*ip  = player->GetDex();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = player->GetInt();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = player->GetMag();
		cp  += 4;

		ip   = (int *)cp;
		*ip  = player->m_iCharisma;
		cp  += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 34);
		break;

	case NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case NOTIFY_CANNOTJOINMOREGUILDSMAN:

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = player->m_pXSock->iSendMsg(cData, 16);
		break;

	case COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = GUILDSTARTRANK;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 28);
		break;

	case COMMONTYPE_JOINGUILDREJECT:
	case COMMONTYPE_DISMISSGUILDAPPROVE:
	case COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = GUILDSTARTRANK;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 28);
		break;

	case NOTIFY_GUILDDISBANDED:

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, player->m_cLocation, 10);
		cp += 10;

		iRet = player->m_pXSock->iSendMsg(cData, 36);
		break;

	case NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break; 

	case NOTIFY_NOGUILDMASTERLEVEL:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_CANNOTBANGUILDMAN:
		iRet = player->m_pXSock->iSendMsg(cData, 6);
		break;

	case NOTIFY_CANNOTRECALL:
	case NOTIFY_CANNOTCRUSADE:
		Push(cp, (uint8)sV1);
		iRet = player->m_pXSock->iSendMsg(cData, 7);
		break;

	case NOTIFY_FORCERECALLTIME:
		sp = (short *)cp ;
		*sp = (short )sV1;
		cp += 2;

		iRet = player->m_pXSock->iSendMsg(cData, 8);
		break;

	case NOTIFY_TELEPORT_REJECTED:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;
		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;

	case NOTIFY_SPELL_SKILL:
		for (i = 0; i < MAXMAGICTYPE; i++) {
			*cp = player->m_cMagicMastery[i];
			cp++;
		}

		for (i = 0; i < MAXSKILLTYPE; i++) {
			*cp = player->m_cSkillMastery[i];
			cp++;
		}

		iRet = player->m_pXSock->iSendMsg(cData, 6 + MAXMAGICTYPE + MAXSKILLTYPE);
		break;

	case NOTIFY_REPAIRALLPRICE:
		Push(cp, (uint32)sV1);
		iRet = player->m_pXSock->iSendMsg(cData, 10);
		break;
	}

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:

		//DeleteClient(iToH, true, true);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			if (m_pClientList[i]->m_side != m_pClientList[iClientH]->m_side ) return;

			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);

			m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

			ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
			strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

			m_pClientList[i]->m_iGuildRank = GUILDSTARTRANK;

			m_pClientList[iClientH]->m_guild->MemberLogin(m_pClientList[i]);


			SendNotifyMsg(iClientH, i, COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_JOINGUILD,i,(char *)NULL,NULL) ;
#endif

			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_CLEARGUILDNAME, 
				m_pClientList[i]->m_cMapIndex,m_pClientList[i]->m_sX, m_pClientList[i]->m_sY,0, 0, 0);

			SendGuildMsg(i, NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
			return;
		}
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
			SendNotifyMsg(iClientH, i, COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
			return;
		}
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {

			m_pClientList[i]->WithdrawFromGuild();
			SendNotifyMsg(iClientH, i, COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
			return;
		}

}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {


			SendNotifyMsg(iClientH, i, COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
			return;
		}
}


uint32 CGame::dwGetItemCount(int iClientH, char * pName)
{
	int i;
	char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
			return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, uint32 dwCount)
{
	int i;
	char cTmpName[21];
	uint16 wWeight;

	if (m_pClientList[iClientH] == NULL) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < MAXITEMS; i++)
		if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {

			wWeight = m_pClientList[iClientH]->m_pItemList[i]->GetWeight(1);

			if (dwCount == 0) {
				ItemDepleteHandler(iClientH, i, false);
			}
			else {
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETITEMCOUNT, i, dwCount, (char)true, NULL);
			}

			return wWeight;
		}

		return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, uint32 dwCount)
{
	uint16 wWeight;

	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;

	wWeight = m_pClientList[iClientH]->m_pItemList[iItemIndex]->GetWeight(1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;


	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, false);
	}
	else {

		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)true, NULL);
	}

	return wWeight;
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, bool bNotice)
{
	char cEquipPos;
	short sTemp;
	int   iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_EQUIP) return;

	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == false) return;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	switch (cEquipPos) {
	case EQUIPPOS_RHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		m_pClientList[iClientH]->m_iApprColor = iTemp;


		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		break;

	case EQUIPPOS_LHAND:
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;			
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xF0FFFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_TWOHAND:

		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;			
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0x0FFFFFFF; 		
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;


		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFF0FFFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;			
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFF0FFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFF0FF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_BOOTS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFF0F; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;			
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFFFFFF0; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	case EQUIPPOS_FULLBODY: 
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;
		//		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; 
		iTemp = iTemp & 0xFFF0FFFF; 
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	case EQUIPPOS_LFINGER:
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != NULL) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_STR) {//AngelicPendant(STR)
				m_pClientList[iClientH]->SetAngelStr(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
			else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_DEX) {//AngelicPendant(DEX)
				m_pClientList[iClientH]->SetAngelDex(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
			else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_INT) {//AngelicPendant(INT)
				m_pClientList[iClientH]->SetAngelInt(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				if(CheckMagicInt(iClientH)){
					SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
				}
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
			else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_ANGELICPENDANT_MAG) {//AngelicPendant(MAG)
				m_pClientList[iClientH]->SetAngelMag(0);
				SetAngel(iClientH, OWNERTYPE_PLAYER, 0);
				SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);
			}
		}
		break;
	}


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS10) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == ITEM_RESURWAND_MS20)) {
			m_pClientList[iClientH]->m_cMagicMastery[94] = false; //Resurrection
			SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
	}

	if (bNotice == true)
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);

	CalcTotalItemEffect(iClientH, sItemIndex, true);
}


bool CGame::_bDecodeNpcConfigFileContents(char * pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iNpcConfigListIndex = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				// NPC Name
				if (strlen(token) > 20) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
					delete[] pContents;
					return false;
				}
				ZeroMemory(m_npcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_npcConfigList[iNpcConfigListIndex]->m_cNpcName));
				memcpy(m_npcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
				cReadModeB++;
				break;
			case 2:
				// NPC Type
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
				cReadModeB++;
				break;
			case 3:
				// Hit Dice (Health)
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
				cReadModeB++;
				break;
			case 4:
				// Defense Ratio
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
				cReadModeB++;
				break;
			case 5:
				// Hit Ratio
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
				cReadModeB++;
				break;
			case 6:
				// NPC Bravery
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
				cReadModeB++;
				break;
			case 7:
				// Exp Dice
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iExpDice = atoi(token) * EXPMULTIPLIER;
				cReadModeB++;
				break;

			case 8:
				// Attack Dice Throw
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
				cReadModeB++;
				break;

			case 9:
				// Attack Dice Range
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
				cReadModeB++;
				break;

			case 10:
				// Size
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
				cReadModeB++;
				break;

			case 11:
				// NPC Side
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_side = (Side)atoi(token);
				cReadModeB++;
				break;

			case 12:
				// Action Limit 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
				cReadModeB++;
				break;

			case 13:
				// Action Time
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
				cReadModeB++;
				break;

			case 14:
				// Resist Magic
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
				cReadModeB++;
				break;

			case 15:
				// Magic Level
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
				cReadModeB++;
				break;

			case 16:
				// Generate Day/Week
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
				cReadModeB++;
				break;

			case 17:
				// Chat Message Preference
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);

				if (m_npcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {


				}
				cReadModeB++;
				break;

			case 18:
				// Target Search Range
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);

				cReadModeB++;
				break;

			case 19:
				// Regeneration Time
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);

				cReadModeB++;
				break;

			case 20:
				// Attribute
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_element = (Element)atoi(token);

				cReadModeB++;
				break;

			case 21:
				// Absorb Damage
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);

				cReadModeB++;
				break;

			case 22:
				// Maximum Mana Point
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);

				cReadModeB++;
				break;

			case 23:
				// Magic Hit Ratio
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);

				cReadModeB++;
				break;

			case 24:
				// Attack Range
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);

				cReadModeB++;
				break;

			case 25:
				// Gold drop value
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_npcConfigList[iNpcConfigListIndex]->dwGoldDropValue = atoi(token) * GOLDDROPMULTIPLIER;

				cReadModeA = 0;
				cReadModeB = 0;
				iNpcConfigListIndex++;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_npcConfigList[iNpcConfigListIndex] = new class CNpc(iNpcConfigListIndex);
			}
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return true;
}

void CGame::OnStartGameSignal()
{
	int i;

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) 
			_bReadMapInfoFiles(i);


	bReadCrusadeStructureConfigFile("Crusade.cfg");

	_LinkStrikePointMapIndex();

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");	
	ReadSoccerFile("GameData\\Soccer.txt");
	bReadSchedulerConfigFile("Scheduler.cfg");

	PutLogList("");
	PutLogList("(!) Game Server Activated.");

	m_pGold = new class CItem;
	m_pGold->InitItemAttr("Gold");

	m_bIsGameStarted = true;
	bSendMsgToLS(MSGID_GAMESERVERINITALIZED, NULL);
}

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{
	int ix, iy, iExp;
	short sOwnerH;
	char cOwnerType;

	return;

	if (m_pClientList[sAttackerH] == NULL) return;

	switch (cVictimType) {

	case OWNERTYPE_NPC:
		if (m_pNpcList[iVictimH] == NULL) return;

		for (ix = m_pNpcList[iVictimH]->m_sX-2; ix <= m_pNpcList[iVictimH]->m_sX+2; ix++)
			for (iy = m_pNpcList[iVictimH]->m_sY-2; iy <= m_pNpcList[iVictimH]->m_sY+2; iy++) {

				m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);

				if ( (cOwnerType == OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
					(memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
					(m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel) ) {

						if (dice(1,3) == 2) {
							iExp = (m_pNpcList[iVictimH]->m_iExp / 3);

							//				if (m_pClientList[sAttackerH]->m_iLevel >= ) iExp = 0;

							if (iExp > 0) {

								m_pClientList[sOwnerH]->m_iExp += iExp;
								if (bCheckLimitedUser(sOwnerH) == false) {

									SendNotifyMsg(NULL, sOwnerH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
								}
								bCheckLevelUp(sOwnerH);
							}
						}
				}
			}												     
			break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
	int iMaxHP, iTemp, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == true) return; 

	//iMaxHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->GetStr()/2); 
	iMaxHP = m_pClientList[iClientH]->GetMaxHP();

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {


		iTemp = dice(3, (m_pClientList[iClientH]->m_iVit/3));
		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);


		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
			iTemp = iTemp - (iTemp/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;


		iTotal +=  m_pClientList[iClientH]->m_iHPStatic_stock;

		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->AddHP(iTotal); 
	}

	m_pClientList[iClientH]->m_iHPstock = 0;
}

void CGame::TimeManaPointsUp(int iClientH)
{
	int iMaxMP, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == true) return;

	iMaxMP = m_pClientList[iClientH]->GetMaxMP();

	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {

		iTotal = dice(3, (m_pClientList[iClientH]->GetMag()/3));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;

		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}


void CGame::TimeStaminarPointsUp(int iClientH)
{
	int iMaxSP, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == true) return; 

	iMaxSP = m_pClientList[iClientH]->GetMaxSP();
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = 10 + dice(4, (m_pClientList[iClientH]->m_iVit/17)); 
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}


		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if ( m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}  else if ( m_pClientList[iClientH]->m_iLevel <= 60) {
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::SendGuildMsg(int iClientH, uint16 wNotifyMsgType, short sV1, short sV2, char * pString)
{
	char cData[500];
	uint32 * dwp;
	uint16  * wp;
	char  * cp;
	int i, iRet;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;


	ZeroMemory(cData, sizeof(cData));

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = wNotifyMsgType;

	cp = (char *)(cData	+ INDEX2_MSGTYPE + 2);


	switch (wNotifyMsgType) {
	case NOTIFY_GUILDDISBANDED:
		memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
		cp += 20;

		m_pClientList[iClientH]->m_guild->Broadcast(cData, 26);
		break;

	case NOTIFY_EVENTMSGSTRING:
		strcpy(cp, pString);
		cp += strlen(pString);
		
		m_pClientList[iClientH]->m_guild->Broadcast(cData, 6 + strlen(pString) + 1);
		break;

	case NOTIFY_NEWGUILDSMAN:
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		
		m_pClientList[iClientH]->m_guild->Broadcast(cData, 6 + 10 + 1);
		break;

	case NOTIFY_DISMISSGUILDSMAN:
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		
		m_pClientList[iClientH]->m_guild->Broadcast(cData, 6 + 10 + 1);
		break;
	}


}

void CGame::GuildNotifyHandler(char * pData, uint32 dwMsgSize)
{

	char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;


}



void CGame::ToggleCombatModeHandler(int iClientH)
{
	short sAppr2;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == true) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = true; 

	if (sAppr2 == 0) {
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
}

int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
	char cData[100];
	uint32 * dwp;
	uint16  * wp;
	int     iRet;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IncPlayerActivity(m_pClientList[iClientH]);
	}

	if(m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*0,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, sX, sY);
	}

	ClearSkillUsingStatus(iClientH);

	m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

	m_pClientList[iClientH]->m_cDir = cDir;

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}


int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1)
{
	short sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic;
	char   cData[120], cDir, cOwnerType, cNpcWaypoint[11], cNpcName[21], cRemainItemColor;
	double dV1, dV2, dV3, dV4;
	int    i, iErr, ix, iy, iResult, diceRes, iFollowersNum, iEraseReq, iWeatherBonus, pNo;
	int    tX, tY, iManaCost, iItemID;
	const int crossPnts[5][2] = {{0,0},{-1,0},{1,0},{0,-1},{0,1}};
	class  CItem * pItem;
	uint32  dwTime = timeGetTime();
	uint16  wWeaponType;
	CMagic * spell = NULL;
	Unit * target = NULL;
	CNpc * targetNpc = NULL;
	CClient * targetPlr = NULL;
	CClient * caster = m_pClientList[iClientH];
	
	if (!caster || !caster->m_bIsInitComplete) return;

	// ### BUG POINT!!!  	caster->m_cMapIndex == -1 ???
	if (caster->m_cMapIndex < 0) return;
	if (m_pMapList[caster->m_cMapIndex] == NULL) return;

	if ((dX < 0) || (dX >= m_pMapList[caster->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[caster->m_cMapIndex]->m_sSizeY)) return;

	caster->m_hasPrecasted = false;

	if (abs(dX - caster->m_sX) > 11 || abs(dY - caster->m_sY) > 11) {
		wsprintf(cData, "Player (%s) casted further than maximum range (%d,%d)->(%d,%d)", 
			caster->m_cCharName, caster->m_sX, caster->m_sY, dX, dY);
		PutLogList(cData);
		PutLogFileList(cData, HACK_LOGFILE);
		return;
	}

	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	spell =	m_pMagicConfigList[sType];

	if ((bItemEffect == false) && (caster->m_cMagicMastery[sType] != 1)) return;

	if (m_pMapList[ caster->m_cMapIndex ]->m_bIsAttackEnabled == false 
		&& spell->m_sType != MAGICTYPE_CREATE
		&& spell->m_sType != MAGICTYPE_TELEPORT
		&& !caster->IsGM()) return;

	if (m_pMapList[ caster->m_cMapIndex ]->m_magicLimited[sType] == true && !caster->IsGM()) return;

	if (caster->m_cMagicEffectStatus[MAGICTYPE_INHIBITION] != 0) return;

	if (caster->m_sItemEquipmentStatus[ EQUIPPOS_RHAND ] != -1) {
		wWeaponType = ((caster->m_sAppr2 & 0x0FF0) >> 4);
		if(wWeaponType < 34 || wWeaponType > 39) return;
	}

	if ((caster->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ]   != -1) ||
		(caster->m_sItemEquipmentStatus[ EQUIPPOS_TWOHAND ] != -1)) return;


	if(!bCheckClientMagicFrequency(caster->m_handle)) return;

	if ((dwTime - caster->m_dwRecentAttackTime) < 100) return; 
	caster->m_dwRecentAttackTime = dwTime;
	caster->m_dwLastActionTime = dwTime;

	sX = caster->m_sX;
	sY = caster->m_sY;

	//         1      2     3     4     5	 6     7	 8	  9    10
	sMagicCircle = (sType / 10) + 1;
	if (caster->m_cSkillMastery[SKILL_MAGIC] == 0)
		dV1 = 1.0f;
	else dV1 = (double)caster->m_cSkillMastery[SKILL_MAGIC];


	if (bItemEffect == true) dV1 = (double)100.0f;

	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];

	dV1 = dV2 * dV3;
	iResult = (int)dV1;


	if (caster->GetInt() > 50)
		iResult += (caster->GetInt() - 50)/2;


	sLevelMagic = (caster->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(caster->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5*abs(sMagicCircle - sLevelMagic); 
		}
	}

	switch (m_pMapList[caster->m_cMapIndex]->m_weather) 
	{
	case WEATHER_LIGHTRAIN:		iResult = iResult - (iResult / 24); break; 
	case WEATHER_MEDIUMRAIN:	iResult = iResult - (iResult / 12); break;
	case WEATHER_HEAVYRAIN:		iResult = iResult - (iResult / 5);  break;
	}

	if (caster->m_iSpecialWeaponEffectType == ITEMSTAT_CASTPROB) {
		dV1 = (double)iResult;
		dV2 = (double)(caster->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWeatherBonus = iGetWeatherMagicBonusEffect(spell, m_pMapList[caster->m_cMapIndex]->m_weather);

	iManaCost = spell->m_manaCost;
	if ((caster->m_bIsSafeAttackMode == true) && 
		(m_pMapList[caster->m_cMapIndex]->m_bIsFightZone == false)) {

			iManaCost *= 1.1;
	}

	if (caster->m_iMPSaveRatio > 0) {
		dV1 = (double)caster->m_iMPSaveRatio;
		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)iManaCost;
		dV1 = dV2 * dV3; 		
		dV2 = dV3 - dV1; 
		iManaCost = (int)dV2;

		if (iManaCost <= 0) iManaCost = 1;
	}

	if (iResult < 100) {

		diceRes = dice(1,100);
		if (iResult < diceRes) {
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_DAMAGE, 0, -1, NULL);
			return;
		}
	}

	if (((caster->m_iHungerStatus <= 10) || (caster->m_iSP <= 0)) && (dice(1,1000) <= 100)) {
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_DAMAGE, 0, -1, NULL);
		return;
	}


	if (caster->m_iMP < iManaCost) {
		return;
	}

	iResult = caster->m_cSkillMastery[SKILL_MAGIC];

	if (caster->GetMag() > 50) iResult += (caster->GetMag() - 50); 


	sLevelMagic = (caster->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(caster->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}


	iResult += caster->m_iAddAR;

	if (iResult <= 0) iResult = 1;
	if (sType >= 80) iResult += 10000;


	if (spell->m_cCategory == 1) {
		if (m_pMapList[caster->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}


	caster->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

	target = m_pMapList[caster->m_cMapIndex]->GetOwner(dX, dY);

	if (spell->m_dwDelayTime == 0) {

		switch (spell->m_sType) 
		{
		case MAGICTYPE_RESURRECTION: 
			//if(!target) goto MAGIC_NOEFFECT;
			target = m_pMapList[caster->m_cMapIndex]->GetDeadOwner(dX, dY); 
			if(target && target->IsPlayer())
			{
				if (!target->IsDead()) goto MAGIC_NOEFFECT; 
				if (!caster->IsGM()){
					if (caster->m_side != target->m_side) goto MAGIC_NOEFFECT;
					if (caster->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
					caster->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
					m_pClientList[iClientH]->m_cMagicMastery[94] = false; //Resurrection
					SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 1,  55, caster->m_iSpecialAbilityTime, NULL);
				}
				//target->m_bIsKilled = false; 
				m_pClientList[target->m_handle]->m_bIsBeingResurrected = true;
				SendNotifyMsg(NULL, target->m_handle, NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
			} 
			break;

		case MAGICTYPE_SCAN:
			if(!target) break;
			if (CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
				if(target->IsPlayer()){
					wsprintf(g_msg, " Player: %s HP:%d MP:%d.", m_pClientList[target->m_handle]->m_cCharName, target->m_iHP, target->m_iMP);
					ShowClientMsg(iClientH, g_msg);
				}else if(target->IsNPC()){
					wsprintf(g_msg, " NPC: %s HP:%d MP:%d", m_pNpcList[target->m_handle]->m_cNpcName, target->m_iHP, target->m_iMP);
					ShowClientMsg(iClientH, g_msg);
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, caster->m_cMapIndex,
					caster->m_sX, caster->m_sY, dX, dY, 10, 10);
			}
			break;

		case MAGICTYPE_POLYMORPH:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (1) { // CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				switch (cOwnerType) 
				{
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
					m_pClientList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_POLYMORPH ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
					m_pNpcList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_NPC, MSGID_MOTION_NULL, NULL, NULL, NULL);
					break;
				}


				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_POLYMORPH, dwTime + (spell->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

				if (cOwnerType == OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_POLYMORPH, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
			}
			break;



		case MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
			}
			break;

		case MAGICTYPE_DAMAGE_SPOT_SPDOWN:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
				Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
			}

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
						Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
					}
			}
			break;

		case MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
			sX = caster->m_sX;
			sY = caster->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
				for(pNo = 0; pNo < 5; pNo++){
					target = g_mapList[caster->m_cMapIndex]->GetOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
						
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}
				
					target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false){

						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}
				}
				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					target = g_mapList[caster->m_cMapIndex]->GetOwner(ix, iy);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
						
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}

					target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(ix, iy);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false){
						
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
						if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER,  target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
							Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER,  target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
						}
					}
				}

			target = g_mapList[caster->m_cMapIndex]->GetOwner(dX, dY);
			if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
		
				if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
					Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
					Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER,  target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
			}

			target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(dX, dY);
			if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false){

				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, false, spell->m_element, spell);
				if (target && !target->IsDead() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
					Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
					Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
			}

			break;

		case MAGICTYPE_CANCELLATION:
			if(target){
				target->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);
				target->RemoveMagicEffect(MAGICTYPE_PROTECT);
				target->RemoveMagicEffect(MAGICTYPE_HOLDOBJECT);
				target->RemoveMagicEffect(MAGICTYPE_BERSERK);
				target->RemoveMagicEffect(MAGICTYPE_ICE);
				target->RemoveMagicEffect(MAGICTYPE_POLYMORPH);
				target->RemoveMagicEffect(MAGICTYPE_INHIBITION);
				if (!g_mapList[caster->m_cMapIndex]->m_isPermIllusionOn)
					target->RemoveMagicEffect(MAGICTYPE_CONFUSE);
			}
			break;

		case MAGICTYPE_INHIBITION:
			if(target && target->IsPlayer() && !m_pClientList[target->m_handle]->IsInvincible() &&
				target->m_cMagicEffectStatus[MAGICTYPE_PROTECT] != MAGICPROTECT_AMP)
			{
				target->AddMagicEffect(spell->m_sType, spell->m_dwLastTime);
			}
			break;

		case MAGICTYPE_DAMAGE_LINEAR:
			sX = caster->m_sX;
			sY = caster->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				for(int pNo=0; pNo < 5; pNo++){
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
					}
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
					}
				}

				// dX, dY
				m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell); 

				m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {

						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell); 
				}
				break;


		case MAGICTYPE_ICE_LINEAR:
			sX = caster->m_sX;
			sY = caster->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				for(pNo = 0; pNo < 5; pNo++) {
					target = m_pMapList[caster->m_cMapIndex]->GetOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}

					target = g_mapList[caster->m_cMapIndex]->GetDeadOwner(tX+crossPnts[pNo][0], tY+crossPnts[pNo][1]);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false){
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}
				}
				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					target = m_pMapList[caster->m_cMapIndex]->GetOwner(ix, iy);
					if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}

					target = m_pMapList[caster->m_cMapIndex]->GetDeadOwner(ix, iy);
					if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false){
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
						
						if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) 
							target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
					}
				}


			target = m_pMapList[caster->m_cMapIndex]->GetOwner(dX, dY);
			if (target && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) {
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell); 

				if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) 
					target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
			}

			target = m_pMapList[caster->m_cMapIndex]->GetDeadOwner(dX, dY);
			if (target && !target->IsDead() && target->IsPlayer() && CheckResistingMagicSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false){
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, target->m_handle, target->m_ownerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell); 

				if (target && !target->IsDead() && checkResistingIceSuccess(caster->m_cDir, target->m_handle, target->m_ownerType, iResult) == false) 
					target->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
			}
			break;

		case MAGICTYPE_HPUP_SPOT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS]);
			break;

		case MAGICTYPE_TREMOR: 
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
					}
				}
				break;

		case MAGICTYPE_DAMAGE_AREA:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);

			m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				(m_pClientList[sOwnerH]->m_iHP > 0) ) {

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);
			}


			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
					}
				}
				break;

		case MAGICTYPE_DAMAGE_AREA_NOSPOT:
			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
					}
				}
				break;
		case MAGICTYPE_DAMAGE_AREA_MOVE:
			if ((dX >= sX) && (dY >= sY))
				{	for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
					for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, true, spell->m_element, spell);
					}					
				}else if ((dX >= sX) && (dY < sY)) 
				{	for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
					for (iy = dY + spell->m_vRange; iy >= dY - spell->m_vRange; iy--)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, true, spell->m_element, spell);
					}	
				}else if((dX < sX) && (dY >= sY))  
				{	for (ix = dX + spell->m_hRange; ix >= dX - spell->m_hRange; ix--) 
					for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, true, spell->m_element, spell);
					}	
				}else //if((dX < sX) && (dY < sY)) 
				{	for (ix = dX + spell->m_hRange; ix >= dX - spell->m_hRange; ix--) 
					for (iy = dY + spell->m_vRange; iy >= dY - spell->m_vRange; iy--)
					{	m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, true, spell->m_element, spell);
					}
				}
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
				{	m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (   (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) 
						&& (m_pClientList[sOwnerH]->m_iHP > 0) ) 
					{	if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, true, spell->m_element, spell);
					}
				}
			break;	

		case MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, false, spell->m_element, spell);
						Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
					}

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, false, spell->m_element, spell);
								Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
							}
					}
				}
				break;

		case MAGICTYPE_SPDOWN_AREA:

			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS]);

			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_SpDown_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
				break;

		case MAGICTYPE_SPUP_AREA:
			spell->Effect_RecSP(caster, target, spell->m_sValue[MAGICV_THROW], 
				spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS]);

			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
			{
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					target = g_mapList[caster->m_cMapIndex]->GetOwner(ix, iy);
					spell->Effect_RecSP(caster, target, spell->m_sValue[MAGICV_LINEARTHROW], 
						spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS]);
				}
			}
			break;

		case MAGICTYPE_TELEPORT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1:
				if(cOwnerType == OWNERTYPE_PLAYER && sOwnerH == iClientH)
				{
					if((dwTime - caster->m_lastDamageTime) > 15 _s || caster->IsGM())
					{
						if (caster->m_nextRecallPoint != 0 && strcmp(caster->m_cMapName, sideMap[ caster->m_side ]) == 0)
						{
							RequestTeleportHandler(iClientH, 3, caster->m_cMapName,
								m_pMapList[caster->m_cMapIndex]->m_pInitialPoint[caster->m_nextRecallPoint].x,
								m_pMapList[caster->m_cMapIndex]->m_pInitialPoint[caster->m_nextRecallPoint].y);
						}
						else{
							RequestTeleportHandler(iClientH, 1);
						}
					}else{
						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTRECALL, 0, NULL, NULL, NULL);
						goto MAGIC_NOEFFECT;
					}
				}
				break;
			}
			break; 

		case MAGICTYPE_SUMMON:
			if (m_pMapList[caster->m_cMapIndex]->m_bIsFightZone == true) return;
			if ((m_bHeldenianMode) && (m_pMapList[caster->m_cMapIndex]->m_bIsHeldenianMap == true)) return;

			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			if ((sOwnerH != NULL) && (cOwnerType == OWNERTYPE_PLAYER) && (
				caster->m_side == m_pClientList[sOwnerH]->m_side)) 
			{
				iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

				if (iFollowersNum >= (caster->m_cSkillMastery[SKILL_MAGIC]/20) && !caster->IsGM()) break;

				ZeroMemory(cNpcName, sizeof(cNpcName));

				switch (iV1) {
				case NULL: 						
					iResult = dice(1, caster->m_cSkillMastery[SKILL_MAGIC] / 10);

					if (iResult < caster->m_cSkillMastery[SKILL_MAGIC] / 20) 
						iResult = caster->m_cSkillMastery[SKILL_MAGIC] / 20;

					switch (iResult) {
					case 1: strcpy(cNpcName, "Slime"); break;
					case 2: strcpy(cNpcName, "Giant-Ant"); break;
					case 3: strcpy(cNpcName, "Amphis"); break;
					case 4: strcpy(cNpcName, "Orc"); break;
					case 5: strcpy(cNpcName, "Skeleton"); break;
					case 6: strcpy(cNpcName, "Clay-Golem"); break;
					case 7: strcpy(cNpcName, "Stone-Golem"); break;
					case 8: strcpy(cNpcName, "Orc-Mage"); break;
					case 9: strcpy(cNpcName, "Hellbound"); break;
					case 10:strcpy(cNpcName, "Cyclops"); break;
					}
					break;

				case 1: strcpy(cNpcName, "Orc"); break;
				case 2: strcpy(cNpcName, "Skeleton"); break;
				case 3: strcpy(cNpcName, "Clay-Golem"); break;
				case 4: strcpy(cNpcName, "Stone-Golem"); break;
				case 5: strcpy(cNpcName, "Hellbound"); break;
				case 6: strcpy(cNpcName, "Cyclops"); break;
				case 7: strcpy(cNpcName, "Troll"); break;
				case 8: strcpy(cNpcName, "Orge"); break;
				}

				if(CNpc * npc = CreateNpc(cNpcName, caster->m_cMapIndex, 0, 
					MOVETYPE_RANDOM, &dX, &dY, caster->m_side, cNpcWaypoint, NULL, NULL, false, true)) 
				{
					npc->Follow( m_pClientList[sOwnerH] );
#ifdef TAIWANLOG
					_bItemLog(ITEMLOG_SUMMONMONSTER,iClientH,cNpcName,NULL) ;
#endif
				}
			}
			break;

		case MAGICTYPE_CREATE:
			if ( m_pMapList[caster->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == false )
				goto MAGIC_NOEFFECT;

			pItem = new class CItem;

			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1:
				if (dice(1,2) == 1)
					iItemID = ITEM_MEAT ;
				else iItemID = ITEM_BAGUETTE ;
				break;
			}

			pItem->InitItemAttr(iItemID);


			pItem->m_sTouchEffectType   = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
			pItem->m_sTouchEffectValue3 = timeGetTime();


			if(m_pMapList[caster->m_cMapIndex]->bSetItem(dX, dY, pItem))
			{
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, caster->m_cMapIndex,
					dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
				_bItemLog(ITEMLOG_DROP, iClientH, (int) -1, pItem);
			}
			break;

		case MAGICTYPE_PROTECT:
			target = m_pMapList[caster->m_cMapIndex]->GetOwner(dX, dY);

			if(!target) goto MAGIC_NOEFFECT;
			if(target->IsNPC())
			{
				targetNpc = (CNpc*)target;
				if(targetNpc->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
			}

			switch(target->m_cMagicEffectStatus[MAGICTYPE_PROTECT])
			{
			case MAGICPROTECT_PFM:
				if(spell->m_sValue[MAGICV_TYPE] == MAGICPROTECT_AMP)
				{
					RemoveFromDelayEventList(target, MAGICTYPE_PROTECT);
					break;
				}
				else
					goto MAGIC_NOEFFECT;

			case MAGICPROTECT_DS:
				if(spell->m_sValue[MAGICV_TYPE] == MAGICPROTECT_GDS)
				{
					RemoveFromDelayEventList(target, MAGICTYPE_PROTECT);
					break;
				}
				else
					goto MAGIC_NOEFFECT;

			case NULL:
				break;

			default:
				goto MAGIC_NOEFFECT;
			}

			target->m_cMagicEffectStatus[MAGICTYPE_PROTECT] = (char)spell->m_sValue[MAGICV_TYPE];
			switch (spell->m_sValue[MAGICV_TYPE]){
			case MAGICPROTECT_PFA:
				target->SetStatusFlag(STATUS_PFA, true);
				break;
			case MAGICPROTECT_PFM:
			case MAGICPROTECT_AMP:
				target->SetStatusFlag(STATUS_PFM,  true);
				break;
			case MAGICPROTECT_DS:
			case MAGICPROTECT_GDS:
				target->SetStatusFlag(STATUS_DEFENSESHIELD, true);
				break;
			}


			RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_PROTECT, dwTime + (spell->m_dwLastTime*1000), 
				target->m_handle, target->m_ownerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

			if(target->IsPlayer())
			{
				targetPlr = (CClient*)target;
				targetPlr->Notify(NULL, NOTIFY_MAGICEFFECTON, MAGICTYPE_PROTECT, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
			}
			break;

		case MAGICTYPE_HOLDOBJECT:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

				switch (cOwnerType) 
				{
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;

					if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					
					if (caster->GetParty() && caster->GetParty() == m_pClientList[sOwnerH]->GetParty()) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;

					if( caster->m_side == m_pClientList[sOwnerH]->m_side && 
						m_bIsCrusadeMode == false && caster->m_iAdminUserLevel == 0 &&
						(
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ISTRIA]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[NEUTRAL]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ARESDEN]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ELVINE]) == 0 ||
						strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ISTRIA]) == 0
						))
					{
						goto MAGIC_NOEFFECT; 
					}

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = (char)spell->m_sValue[MAGICV_TYPE];
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; 
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = (char)spell->m_sValue[MAGICV_TYPE];
					break;
				}

				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_HOLDOBJECT, dwTime + (spell->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

				if (cOwnerType == OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_HOLDOBJECT, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
			}
			break;

		case MAGICTYPE_INVISIBILITY:
			switch (spell->m_sValue[MAGICV_TYPE]) 
			{
			case 1:

				m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->IsInvisible()) goto MAGIC_NOEFFECT;
					if (m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[sOwnerH]) goto MAGIC_NOEFFECT;

					//	if (caster->IsNeutral()) goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = (char)spell->m_sValue[MAGICV_TYPE];
					m_pClientList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, true);
					RemoveFromTarget(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_INVISIBILITY);
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->IsInvisible()) goto MAGIC_NOEFFECT;

					if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = (char)spell->m_sValue[MAGICV_TYPE];
						m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, true);
						RemoveFromTarget(sOwnerH, OWNERTYPE_NPC, MAGICTYPE_INVISIBILITY);
					}
					break;
				}

				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_INVISIBILITY, dwTime + (spell->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

				if (cOwnerType == OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_INVISIBILITY, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
				break;

			case 2:

				//	if (caster->IsNeutral()) goto MAGIC_NOEFFECT;

				for (ix = dX - 8; ix <= dX + 8; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) {
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != NULL) {
							switch (cOwnerType) 
							{
							case OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

								if (m_pClientList[sOwnerH]->IsInvisible()) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = NULL;
									m_pClientList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, false);
									RemoveFromDelayEventList(sOwnerH, cOwnerType, MAGICTYPE_INVISIBILITY);
								}
								break;

							case OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->IsInvisible()) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_INVISIBILITY ] = NULL;
									m_pNpcList[sOwnerH]->SetStatusFlag(STATUS_INVISIBILITY, false);
									RemoveFromDelayEventList(sOwnerH, cOwnerType, MAGICTYPE_INVISIBILITY);
								}
								break;
							}
						}
					}
					break;
			}
			break;

		case MAGICTYPE_CREATE_DYNAMIC:
			if (!m_bIsCrusadeMode) {
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ARESDEN]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ELVINE]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMap[ISTRIA]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ARESDEN]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ELVINE]) == 0) return;
				if (strcmp(m_pMapList[caster->m_cMapIndex]->m_cName, sideMapFarm[ISTRIA]) == 0) return;
			}

			switch (spell->m_sValue[MAGICV_DYNAMICOBJ])
			{
			case DYNAMICOBJECT_PCLOUD_BEGIN: 
			case DYNAMICOBJECT_FIRE:   
			case DYNAMICOBJECT_SPIKE:  
				switch (spell->m_sValue[MAGICV_DYNAMICTYPE]) 
				{
				case 1: 
					// wall - type
					cDir = CMisc::cGetNextMoveDir(caster->m_sX, caster->m_sY, dX, dY);
					switch (cDir) 
					{
					case 1:	rx = 1; ry = 0;   break;
					case 2: rx = 1; ry = 1;   break;
					case 3: rx = 0; ry = 1;   break;
					case 4: rx = -1; ry = 1;  break;
					case 5: rx = 1; ry = 0;   break;
					case 6: rx = -1; ry = -1; break;
					case 7: rx = 0; ry = -1;  break;
					case 8: rx = 1; ry = -1;  break;
					}

					iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
						dX, dY, spell->m_dwLastTime*1000);

					bAnalyzeCriminalAction(iClientH, dX, dY);

					for (i = 1; i <= spell->m_hRange; i++) {
						iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
							dX + i*rx, dY + i*ry, spell->m_dwLastTime*1000);
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
							dX - i*rx, dY - i*ry, spell->m_dwLastTime*1000);
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					bool bFlag = false;
					int cx, cy;
					for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++) {
						for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++)
							iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
							ix, iy, spell->m_dwLastTime*1000, spell->m_sValue[MAGICV_THROW]);

						if (bAnalyzeCriminalAction(iClientH, ix, iy, true) == true) {
							bFlag = true;
							cx = ix;
							cy = iy;
						}
					}
					if (bFlag == true) bAnalyzeCriminalAction(iClientH, cx, cy);
					break;
				}
				break;

			case DYNAMICOBJECT_ICESTORM:
				iAddDynamicObjectList(iClientH, OWNERTYPE_PLAYER_INDIRECT, spell->m_sValue[MAGICV_DYNAMICOBJ], caster->m_cMapIndex, 
					dX, dY, spell->m_dwLastTime*1000,
					caster->m_cSkillMastery[SKILL_MAGIC]);
				break;

			default:
				break;
			}
			break;

		case MAGICTYPE_POSSESSION:
			if(target) break;

			pItem = m_pMapList[caster->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
			
			if (!pItem) break;

			if(!pItem->m_disabled && _bAddClientItemList(iClientH, pItem, &iEraseReq))
			{
				if(m_astoria.get() && m_astoria->IsRelicGenuine(pItem))
					m_astoria->PlayerGetRelic(caster);

				_bItemLog(ITEMLOG_GET, iClientH, (int) -1, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, caster->m_cMapIndex,
					dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
				if (iEraseReq == 1) delete pItem;

			}
			else 
			{
				m_pMapList[caster->m_cMapIndex]->bSetItem(dX, dY, pItem);

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			}
			break;

		case MAGICTYPE_CONFUSE:
			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1: 
			case 2: // Confusion, Mass Confusion 
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == NULL) continue; 
							if (m_pClientList[sOwnerH]->m_side == caster->m_side) continue; 
							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0) continue; 
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = (char)spell->m_sValue[MAGICV_TYPE];

								RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_CONFUSE, dwTime + (spell->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
							}
						}
				}
				break;

			case 3: // Ilusion, Mass-Ilusion
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == NULL) continue;
							if (m_pClientList[sOwnerH]->m_side == caster->m_side) continue; 
							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0) continue; 
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = (char)spell->m_sValue[MAGICV_TYPE];
								m_pClientList[sOwnerH]->SetStatusFlag(STATUS_ILLUSION, true);
								RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_CONFUSE, dwTime + (spell->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, spell->m_sValue[MAGICV_TYPE], iClientH, NULL);
							}
						}
					}
				break;
			case 4:
				for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
					for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) 
					{	
						m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == OWNERTYPE_PLAYER) 
						{	
							if (m_pClientList[sOwnerH] == NULL) continue;
							if (m_pClientList[sOwnerH]->m_side == caster->m_side) continue; 
							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0) continue;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = (char)spell->m_sValue[MAGICV_TYPE];
								m_pClientList[sOwnerH]->SetStatusFlag(STATUS_ILLUSIONMOVEMENT, true);

								RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_CONFUSE, dwTime + (spell->m_dwLastTime*1000), 
									sOwnerH, cOwnerType, NULL, NULL, NULL, spell->m_sValue[MAGICV_TYPE], NULL, NULL);
								SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, spell->m_sValue[MAGICV_TYPE], iClientH, NULL);
							}
						}							
					}
				break;	

			}
			break;

		case MAGICTYPE_POISON:
			m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			if (spell->m_sValue[MAGICV_TYPE] == 1) {

				switch (cOwnerType) {
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					bAnalyzeCriminalAction(iClientH, dX, dY);

					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						if (checkResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {

							m_pClientList[sOwnerH]->m_bIsPoisoned  = true;
							m_pClientList[sOwnerH]->m_iPoisonLevel = spell->m_sValue[MAGICV_POISONLVL];
							m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
							m_pClientList[sOwnerH]->SetStatusFlag(STATUS_POISON, true);

							SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_POISON, spell->m_sValue[MAGICV_POISONLVL], NULL, NULL);
#ifdef TAIWANLOG
							_bItemLog(ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
						}
					}
				break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						if (checkResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {

						}
					}
			break;
				}
			}
			else if (spell->m_sValue[MAGICV_TYPE] == 0) {
				switch (cOwnerType) {
				case OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_bIsPoisoned == true) {
						m_pClientList[sOwnerH]->m_bIsPoisoned = false;
						m_pClientList[sOwnerH]->SetStatusFlag(STATUS_POISON, false);
						SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_POISON, NULL, NULL, NULL);
					}
					break;

				case OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					break;
				}
			}
			break;

		case MAGICTYPE_BERSERK:
			switch (spell->m_sValue[MAGICV_TYPE]) {
			case 1:
				target = m_pMapList[caster->m_cMapIndex]->GetOwner(dX, dY);

				if (!target) goto MAGIC_NOEFFECT;
				if (target->GetStatusFlag(STATUS_BERSERK) != 0) goto MAGIC_NOEFFECT;

				if (target->IsNPC()) {
					if ( m_pNpcList[target->m_handle]->m_cActionLimit != 0 ) goto MAGIC_NOEFFECT;
					if ( caster->m_side != target->m_side ) goto MAGIC_NOEFFECT;
					switch (target->m_sType) {
						case NPC_BG:
						case NPC_GHK:
						case NPC_GHKABS:	//Crusade summons
						case NPC_TK:
						case NPC_LWB:
							goto MAGIC_NOEFFECT;
					}
				}
				target->AddMagicEffect(spell->m_sType, spell->m_dwLastTime);
				break;
			}
			break;

		case MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:

			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {
					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
						ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, spell->m_sValue[MAGICV_ARMORDEC]);
					}

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_LINEARTHROW], spell->m_sValue[MAGICV_LINEARRANGE], spell->m_sValue[MAGICV_LINEARBONUS] + iWeatherBonus, false, spell->m_element, spell);
								ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, spell->m_sValue[MAGICV_ARMORDEC]);
							}
					}
				}
				break;

		case MAGICTYPE_ICE:
			for (iy = dY - spell->m_vRange; iy <= dY + spell->m_vRange; iy++)
				for (ix = dX - spell->m_hRange; ix <= dX + spell->m_hRange; ix++) {

					m_pMapList[caster->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);

						switch (cOwnerType) 
						{
						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

							if (m_pClientList[sOwnerH]->IsNeutral()) goto MAGIC_NOEFFECT;

							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (checkResistingIceSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								m_pClientList[sOwnerH]->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (checkResistingIceSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								m_pNpcList[sOwnerH]->AddMagicEffect(spell->m_sType, spell->m_sValue[MAGICV_ICEDURATION]);
							}
							break;
						}

					}

					m_pMapList[caster->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							if (CheckResistingMagicSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

								Effect_Damage_Spot(iClientH, OWNERTYPE_PLAYER, sOwnerH, cOwnerType, spell->m_sValue[MAGICV_THROW], spell->m_sValue[MAGICV_RANGE], spell->m_sValue[MAGICV_BONUS] + iWeatherBonus, true, spell->m_element, spell);

								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (checkResistingIceSuccess(caster->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] = 1;
										m_pClientList[sOwnerH]->SetStatusFlag(STATUS_FROZEN, true);
										RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_ICE, dwTime + (spell->m_sValue[MAGICV_ICEDURATION]*1000), 
											sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_ICE, 1, NULL, NULL);
									}
								}
							}
					}
				}
				break;

		default:
			break;
		}
	}
	else {


	}

MAGIC_NOEFFECT:;

	if (caster == NULL) return;

	//Mana Slate
	if ((caster->m_iStatus & STATUS_BLUESLATE) != 0) {
		iManaCost = 0;
	}


	caster->m_iMP -= iManaCost; 
	if (caster->m_iMP < 0) 
		caster->m_iMP = 0;

	CalculateSSN_SkillIndex(iClientH, SKILL_MAGIC, 1 );

	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_MAGIC, caster->m_cMapIndex,
		caster->m_sX, caster->m_sY, dX, dY, (sType+100), caster->m_sType);

	SendNotifyMsg(NULL, iClientH, NOTIFY_MP, NULL, NULL, NULL, NULL);
}


void CGame::RequestTeleportHandler(int iClientH, char teleportType, char * cMapName, int dX, int dY)
{
	char  cTempMapName[21];
	char  cDestMapName[11], cDir, cMapIndex;
	short sX, sY;
	int   i, iDestX, iDestY, iExH, iMapSide;
	bool    bRet, bIsLockedMapNotify;
	bool setRecallTime = true;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (player->m_bIsKilled == true) return;
	if (player->m_bIsOnWaitingProcess == true) return;

	if((teleportType == 1 || teleportType == 3) && 
		(player->IsInFoeMap() || 
		 (m_pMapList[player->m_cMapIndex]->m_bIsApocalypseMap && m_pMapList[ player->m_cMapIndex ]->m_cDynamicGateType != 4)
		))
	{
		player->Notify(NULL, NOTIFY_CANNOTRECALL, 1, NULL, NULL, NULL);
		return;
	}

	sX = player->m_sX;
	sY = player->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[player->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	if(!bRet && teleportType == 4){
		SendObjectMotionRejectMsg(iClientH);
		SendNotifyMsg(NULL, iClientH, NOTIFY_TELEPORT_REJECTED,sX,sY,NULL,NULL);
		return;
	}
	
	if(player->m_cMapIndex == m_iAstoriaMapIndex	&& m_astoria.get())
	{
		int index = player->HasItem(ITEM_RELIC);
		if(index != ITEM_NONE)
		{
			DropItemHandler(player->m_handle, index, 1, player->m_pItemList[index]->m_cName, false);
		}
	}

	bIsLockedMapNotify = false;

	if (player->m_isExchangeMode == true) {
		iExH = player->m_exchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	RemoveFromTarget(iClientH, OWNERTYPE_PLAYER);

	m_pMapList[player->m_cMapIndex]->ClearOwner(/*13,*/ iClientH, OWNERTYPE_PLAYER, sX, sY);

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_EVENT_REJECT, NULL, NULL, NULL);

	iMapSide = iGetMapLocationSide(cDestMapName);
	if ((strcmp(player->m_cLockedMapName, "NONE") != 0) && (player->m_iLockedMapTime > 0)) {

		int tmp_mapSide = iMapSide;
		if (tmp_mapSide >= 11) tmp_mapSide -= 10 ;

		if (tmp_mapSide == 0 || player->m_side != tmp_mapSide) {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = true;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, player->m_cLockedMapName);
		}
	}

	if(player->IsNeutral() && memcmp(player->m_cMapName, "default2", 8) == 0)
	{
		int tmp_mapSide = iMapSide;
		if (tmp_mapSide >= 11) tmp_mapSide -= 10 ;
		if((Side)tmp_mapSide != NEUTRAL)
		{
			ChangeNation(player->m_handle, (Side)tmp_mapSide);
			wsprintf(g_cTxt, "Istrian %s chose %s!", player->m_cCharName, sideName[tmp_mapSide]);
			PutLogList(g_cTxt);
		}
		else
		{
			bRet = true;
			memcpy(cDestMapName, "default2", 9);
			iDestX = iDestY = -1;
			cDir = SOUTH;
		}
	}

	if(player->m_cMapIndex == m_iAstoriaMapIndex && memcmp(cDestMapName, "astoria", 7) == 0)
	{
		uint32 baseNumber = cDestMapName[7] - '0';
		ZeroMemory(cDestMapName, sizeof(cDestMapName));
		if(player->m_side == m_astoriaBasePos[baseNumber])
		{
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, sideMap[ m_astoriaBasePos[baseNumber] ]);
		}else
		{
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, player->m_cMapName);
			iDestX = player->m_sX;
			iDestY = player->m_sY;
			setRecallTime = false;
		}
	}
	
	if(m_pMapList[player->m_cMapIndex]->m_isPermIllusionOn) {
		player->RemoveMagicEffect(MAGICTYPE_CONFUSE);
	}

	cMapIndex = iGetMapIndex(cDestMapName);
	
	if(bRet)
	{
		if(cMapIndex == -1 || 
			(bRet && iMapSide && iMapSide <= 10 &&
			strcmp(m_pMapList[cMapIndex]->m_cLocationName, player->m_cLocation) != 0 &&
			!player->IsGM() && !player->IsNeutral() )
			)
		{
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, player->m_cMapName);
			iDestX = player->m_sX;
			iDestY = player->m_sY;
			setRecallTime = false;
		}
	}

	if (bRet && !cMapName) {
		for (i = 0; i < MAXMAPS; i++)
		{
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
					player->m_sX   = iDestX;	  
					player->m_sY   = iDestY;
					player->m_cDir = cDir;
					player->m_cMapIndex = i; 
					ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
					memcpy(player->m_cMapName, m_pMapList[i]->m_cName, 10);  
					goto RTH_NEXTSTEP;
				}
			}
		}

		player->m_sX   = iDestX;	  
		player->m_sY   = iDestY;
		player->m_cDir = cDir;
		ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
		memcpy(player->m_cMapName, cDestMapName, 10);

		// Slate
		SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_CONFUSE,
			player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ], NULL, NULL);
		SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, false);

		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false);  

		player->m_bIsOnServerChange = true;
		player->m_bIsOnWaitingProcess = true;
		return;
	}
	else {
		switch (teleportType) {
		case 0: // Forced Recall. 
		case 1: // Normal Recall 
			//if (memcmp(m_pMapList[ player->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;
			ZeroMemory(cTempMapName, sizeof(cTempMapName));

			if (player->m_iLevel > 80)
				strcpy(cTempMapName, sideMap[ player->m_side ]);
			else
				strcpy(cTempMapName, sideMapFarm[ player->m_side ]);

			if ((strcmp(player->m_cLockedMapName, "NONE") != 0) && (player->m_iLockedMapTime > 0)) {

				bIsLockedMapNotify = true;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, player->m_cLockedMapName);
			}
			
			for (i = 0; i < MAXMAPS; i++)
			{
				if (m_pMapList[i] != NULL) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {

						GetMapInitialPoint(i, &player->m_sX, &player->m_sY, player->m_cLocation);

						player->m_cMapIndex = i; 
						ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
						memcpy(player->m_cMapName, m_pMapList[i]->m_cName, 10);  
						goto RTH_NEXTSTEP;
					}
				}
			}

			player->m_sX   = -1;	  
			player->m_sY   = -1;	  

			ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			memcpy(player->m_cMapName, cTempMapName, 10);  
			// Slate
			SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_CONFUSE,
				player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ], NULL, NULL);
			SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, false);

			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); 

			player->m_bIsOnServerChange   = true;
			player->m_bIsOnWaitingProcess = true;
			return;

		case 2: // Forced teleport  
		case 3: // Player requested teleport 
			if ((strcmp(player->m_cLockedMapName, "NONE") != 0) && (player->m_iLockedMapTime > 0) && (memcmp(cMapName, "resurr", 6) != 0)) {
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = true;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, player->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}

			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				player->m_sX   = dX; //-1;	  			
				player->m_sY   = dY; //-1;	  

				ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
				memcpy(player->m_cMapName, cTempMapName, 10);  
				// Slate
				SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_CONFUSE,
					player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, false);

				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); 

				player->m_bIsOnServerChange   = true;
				player->m_bIsOnWaitingProcess = true;
				return;
			}

			player->m_cMapIndex = cMapIndex;

			if (dX == -1 || dY == -1)
				GetMapInitialPoint(cMapIndex, &player->m_sX, &player->m_sY, player->m_cLocation);
			else 
			{
				player->m_sX   = dX;
				player->m_sY   = dY;
			}

				ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
			memcpy(player->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		}
	}

RTH_NEXTSTEP:;

	PlayerMapEntry(iClientH, setRecallTime);
	if (bIsLockedMapNotify == true) SendNotifyMsg(NULL, iClientH, NOTIFY_LOCKEDMAP, player->m_iLockedMapTime, NULL, NULL, player->m_cLockedMapName);
}


void CGame::RequestTeleportListHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == true) return;

	char	*cp, cData[512];
	int		iRet;
	uint32	*dwp;
	uint16	*wp;
	int		iMapSide = -1;
	int		*listCount;
	char	cNpcName[21];
	int		*ip;

	if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sideMap[ARESDEN]) == 0)
		iMapSide = ARESDEN;
	else if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sideMap[ELVINE]) == 0)
		iMapSide = ELVINE;
	else if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sideMap[ISTRIA]) == 0)
		iMapSide = ISTRIA;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strncpy(cNpcName, cp, 20);
	cp += 20;

	ZeroMemory(cData, sizeof(cData));
	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_TELEPORT_LIST;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	cp = cData + 6;

	listCount = (int*) cp; 
	*listCount = 0;
	cp += 4; // sizeof(int)

	int	index;
	for(index = 0; index < MAXTELEPORTLIST; index++)
	{
		if( m_pTeleportConfigList[index] == NULL ) continue;


		if( strncmp( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName,
			m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
			continue;

		if( strncmp( m_pTeleportConfigList[index]->m_cNpcname, cNpcName, 20) != 0 )
			continue;

		if( m_pTeleportConfigList[index]->m_iMinLvl > m_pClientList[iClientH]->m_iLevel ||
			m_pTeleportConfigList[index]->m_iMaxLvl < m_pClientList[iClientH]->m_iLevel)
			continue;

		if(!m_pTeleportConfigList[index]->m_bNetural &&	m_pClientList[iClientH]->IsNeutral())
			continue;

		if(!m_pTeleportConfigList[index]->m_bCriminal && m_pClientList[iClientH]->m_iPKCount > 0 )
			continue;

		SYSTEMTIME currTime;
		GetLocalTime(&currTime);
		if(!m_astoria.get() && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0 &&
			(currTime.wDayOfWeek == FRIDAY || 
			currTime.wDayOfWeek == SATURDAY ||
			currTime.wDayOfWeek == SUNDAY))
		{
			continue;
		}

		if(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "middleland") == 0 && 
			m_eventWinner[ET_CAPTURE] != m_pClientList[iClientH]->m_side)
		{
			continue;
		}
		if (!m_bHeldenianMode && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "BtField") == 0 && 
			m_iHeldenianType1Winner != m_pClientList[iClientH]->m_side)
		{
			continue;
		}
		if( (
			m_pClientList[iClientH]->IsNeutral() &&
			( m_pTeleportConfigList[index]->m_iSide == ALLSIDES ||
			m_pTeleportConfigList[index]->m_iSide == iMapSide )
			) || (
			m_pTeleportConfigList[index]->m_iSide == ALLSIDES ||
			m_pTeleportConfigList[index]->m_iSide == m_pClientList[iClientH]->m_side
			)
			)
		{
			ip = (int*) cp;
			*ip = index;
			cp += 4;

			memcpy(cp, m_pTeleportConfigList[index]->m_cTargetMap, 10);
			cp += 10;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iX;
			cp += 4;

			ip = (int*) cp;
			*ip = m_pTeleportConfigList[index]->m_iY;
			cp += 4;

			ip = (int*) cp;
			if((m_astoria.get() && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0) ||
				(m_bHeldenianMode && 
					(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "BtField") == 0 ||
					strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "HRampart") == 0))
					)
				*ip = 0;
			else
				*ip = m_pTeleportConfigList[index]->m_cost;
			cp += 4;

			*cp = m_pTeleportConfigList[index]->m_donateEvent;
			cp++;
		}
		else continue;

		(*listCount) ++;
	} // for


	if ( (*listCount) == 0 )
		*wp  = MSGTYPE_REJECT;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) * 27 );

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
} // RequestTeleportListHandler


void CGame::RequestChargedTeleportHandler(int iClientH, char *pData, uint32 dwMsgSize)
{
	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (player->m_bIsKilled == true) return;
	if (player->m_bIsOnWaitingProcess == true) return;

	char	*cp, cData[64];
	int		iRet;
	uint32	*dwp;
	uint16	*wp;
	int		iMapSide = -1;
	int		index;
	uint16	wConfirm = MSGTYPE_CONFIRM;
	short	sError = 0;


	if( strcmp(m_pMapList[player->m_cMapIndex]->m_cLocationName, sideMap[ARESDEN]) == 0)
		iMapSide = ARESDEN;
	else if( strcmp(m_pMapList[player->m_cMapIndex]->m_cLocationName, sideMap[ELVINE]) == 0)
		iMapSide = ELVINE;
	else if( strcmp(m_pMapList[player->m_cMapIndex]->m_cLocationName, sideMap[ISTRIA]) == 0)
		iMapSide = ISTRIA;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	index = (int) (*cp);
	cp += 4;

	if( index < 0 || index >= MAXTELEPORTLIST)
		return;

	if( m_pTeleportConfigList[index] == NULL )
		return;


	if( strncmp( m_pMapList[player->m_cMapIndex]->m_cName,
		m_pTeleportConfigList[index]->m_cSourceMap, 10) != 0 )
		return;

	if( m_pTeleportConfigList[index]->m_iMinLvl > player->m_iLevel ||
		m_pTeleportConfigList[index]->m_iMaxLvl < player->m_iLevel)
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 1;
	}

	if( wConfirm == MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_bNetural == false &&
		player->IsNeutral())
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 3;
	}

	if( wConfirm == MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_bCriminal == false &&
		player->m_iPKCount > 0 )
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 4;
	}


	if( wConfirm == MSGTYPE_CONFIRM &&
		player->IsNeutral() &&
		( 
		m_pTeleportConfigList[index]->m_iSide != ALLSIDES && 
		m_pTeleportConfigList[index]->m_iSide != iMapSide 
		) )
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 5;
	}
	else if (wConfirm == MSGTYPE_CONFIRM &&
		m_pTeleportConfigList[index]->m_iSide != ALLSIDES &&
		m_pTeleportConfigList[index]->m_iSide != player->m_side )
	{
		wConfirm = MSGTYPE_REJECT;
		sError = 5;
	}

	if( wConfirm == MSGTYPE_CONFIRM )
	{

		uint32 cost;

		if((m_astoria.get() && strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0) ||
			(m_bHeldenianMode && 
				(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "BtField") == 0 ||
				strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "HRampart") == 0))
			)
			cost = 0;
		else
			cost = m_pTeleportConfigList[index]->m_cost;

		if(m_pTeleportConfigList[index]->m_donateEvent)
		{
			uint32 legiontokens = dwGetItemCount(iClientH, "LegionTokens");
			if( legiontokens >= cost )
			{
				SetItemCount(iClientH, "LegionTokens", legiontokens - cost);
				iCalcTotalWeight(iClientH);
				
				m_donateEventPot += 5;

				CClient * gm = objMgr.FindPlayer( m_donateEventHolder );
				if(gm)
					gm->Notify(NULL, NOTIFY_DONATEEVENTINFO);

			} else {
				wConfirm = MSGTYPE_REJECT;
				sError = 7;			
			}
		} else {
			uint32 goldCount = dwGetItemCount(iClientH, "Gold");

			if(goldCount >= cost)
			{
				SetItemCount(iClientH, "Gold", goldCount - cost);

				iCalcTotalWeight(iClientH);
				m_stCityStatus[player->m_side].iFunds += cost;
			} else {
				wConfirm = MSGTYPE_REJECT;
				sError = 6;			
			}
		}
	}

	// Invalid Charged-teleport
	if ( wConfirm == MSGTYPE_REJECT )
	{
		ZeroMemory(cData, sizeof(cData));
		dwp  = (uint32 *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CHARGED_TELEPORT;
		wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
		*wp  = wConfirm;

		cp = cData + INDEX2_MSGTYPE + 2;

		short	*sp;
		sp	= (short*) cp;
		*sp	= sError;
		cp += 2;


		iRet = player->m_pXSock->iSendMsg(cData, 6 + 2 );

		switch (iRet) 
		{
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
		return;
	}

	uint32 x,y;

	if(strcmp(m_pTeleportConfigList[index]->m_cTargetMap, "astoria") == 0)
	{
		uint32 i;
		for(i=0; i < MAXALTARS; i++)
		{
			if(player->m_side == m_astoriaBasePos[i])
				break;
		}
		x = astoriaStartPos[i].x;
		y = astoriaStartPos[i].y;

		if (m_astoria.get()) 
			SetSlateFlag(iClientH, NOTIFY_SLATECLEAR, false);
	}
	else
	{
		x = m_pTeleportConfigList[index]->m_iX;
		y = m_pTeleportConfigList[index]->m_iY;
	}

	RequestTeleportHandler(iClientH, 2,
		m_pTeleportConfigList[index]->m_cTargetMap, x, y);

} // RequestChargedTeleportHandler


void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
	int i;

	for (i = 0; i < MAXNPCS; i++)
		if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
			if ((m_pNpcList[i]->m_cMoveType == MOVETYPE_FOLLOW) &&
				(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
				(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {

					m_pNpcList[i]->m_cMoveType = MOVETYPE_RANDOMWAYPOINT;
			}
		}
}

void CGame::RequestUpdateFriendsHandler(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = ", ";
	char   * token, friendName[11], cBuff[256], nameBuff[256];
	int i;
	bool friendFound;
	char *cp;
	uint16 *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	StrTok pStrTok(new CStrTok(pData+6, seps));
	token = pStrTok->pGet();

	ZeroMemory(nameBuff, sizeof(nameBuff));
	for (int j = 0;token != NULL && j < 13; j++) {
		friendFound = false;
		if(strlen(token) == 0) continue;
		ZeroMemory(friendName, sizeof(friendName));
		if (strlen(token) > 10)	memcpy(friendName, token, 10);
		else memcpy(friendName, token, strlen(token));
		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, friendName, 10) == 0)) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_FRIENDONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName, NULL, NULL, NULL, NULL, NULL, NULL, "");
				friendFound = true;
				break;
			}
			if(!friendFound){
				strcat(nameBuff,token);
				strcat(nameBuff," ");
			}
			token = pStrTok->pGet();
	}

	if(strlen(nameBuff) > 0){
		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDFRIEND;
		cp++;

		wp = (uint16 *)cp;
		*wp = GSID;
		cp += 2;

		wp = (uint16 *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		wp  = (uint16 *)cp;
		*wp = (uint16)strlen(nameBuff);
		cp += 2;

		strcpy(cp, nameBuff);
		cp += strlen(nameBuff);

		bStockMsgToGateServer(cBuff, 17 + strlen(nameBuff));
	}


}

bool CGame::_bDecodeMagicConfigFileContents(char * pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iMagicConfigListIndex = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					if (m_pMagicConfigList[atoi(token)] != NULL) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB++;
					break;

				case 2:
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB++;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB++;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB++;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB++;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_manaCost = atoi(token);
					cReadModeB++;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_hRange = atoi(token)/2;
					cReadModeB++;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_vRange = atoi(token)/2;
					cReadModeB++;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[0] = atoi(token);
					cReadModeB++;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[1] = atoi(token);
					cReadModeB++;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[2] = atoi(token);
					cReadModeB++;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[3] = atoi(token);
					cReadModeB++;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[4] = atoi(token);
					cReadModeB++;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[5] = atoi(token);
					cReadModeB++;
					break;

				case 15:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[6] = atoi(token);
					cReadModeB++;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue[7] = atoi(token);
					cReadModeB++;
					break;

				case 17:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB++;
					break;

				case 18:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);

					cReadModeB++;
					break;

				case 19:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB++;
					break;

				case 20:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_element = (Element)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return true;

}



bool CGame::_bDecodeSkillConfigFileContents(char * pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSkillConfigListIndex = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				if (m_pSkillConfigList[atoi(token)] != NULL) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[atoi(token)] = new class CSkill;
				iSkillConfigListIndex = atoi(token);

				cReadModeB++;
				break;

			case 2:
				ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
				memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
				cReadModeB++;
				break;

			case 3:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
				cReadModeB++;
				break;

			case 4:
				// m_sValue1
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
				cReadModeB++;
				break;

			case 5:
				// m_sValue2
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
				cReadModeB++;
				break;

			case 6:
				// m_sValue3
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
				cReadModeB++;
				break;

			case 7:
				// m_sValue4
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
				cReadModeB++;
				break;

			case 8:
				// m_sValue5
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
				cReadModeB++;
				break;

			case 9:
				// m_sValue6
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return true;
}



bool CGame::_bDecodeTeleportListConfigFileContents(char * pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	uint32 count = 0;

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1: 
					m_pTeleportConfigList[count] = new class CTeleport;
					memcpy(m_pTeleportConfigList[count]->m_cNpcname, token, strlen(token));
					cReadModeB++;
					break;

				case 2: // SOURCE MAP
					memcpy(m_pTeleportConfigList[count]->m_cSourceMap, token, strlen(token));
					cReadModeB++;
					break;

				case 3: // TARGET MAP
					memcpy(m_pTeleportConfigList[count]->m_cTargetMap, token, strlen(token));
					cReadModeB++;
					break;

				case 4: // TARGET MAP X
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pTeleportConfigList[count]->m_iX = atoi(token);
					cReadModeB++;
					break;

				case 5: // TARGET MAP Y
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pTeleportConfigList[count]->m_iY = atoi(token);
					cReadModeB++;
					break;

				case 6: // COST
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pTeleportConfigList[count]->m_cost = atoul(token);
					cReadModeB++;
					break;

				case 7: // Minimum Level
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pTeleportConfigList[count]->m_iMinLvl = atoi(token);
					cReadModeB++;
					break;

				case 8: // Maximum Level
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pTeleportConfigList[count]->m_iMaxLvl = atoi(token);
					cReadModeB++;
					break;

				case 9: // Side (aresden, elvine, istria)
					if( strcmp(token, sideMap[ARESDEN]) == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ARESDEN;
					}
					else if( strcmp(token, sideMap[ELVINE]) == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ELVINE;
					}
					else if( strcmp(token, sideMap[ISTRIA]) == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ISTRIA;
					}
					else if( strcmp(token, "all") == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ALLSIDES;
					}
					else if( strcmp(token, "attacker") == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = ATTACKER;
					}
					else if( strcmp(token, "defender") == 0 )
					{
						m_pTeleportConfigList[count]->m_iSide = DEFENDER;
					}
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cReadModeB++;
					break;

				case 10: // Netural
					if( strcmp(token,"FALSE") == 0 )
						m_pTeleportConfigList[count]->m_bNetural = false;
					else if( strcmp(token,"TRUE") == 0 )
						m_pTeleportConfigList[count]->m_bNetural = true;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cReadModeB++;
					break;

				case 11: // Criminal
					if( strcmp(token,"FALSE") == 0 )
						m_pTeleportConfigList[count]->m_bCriminal = false;
					else if( strcmp(token,"TRUE") == 0 )
						m_pTeleportConfigList[count]->m_bCriminal = true;
					else
					{
						PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cReadModeA = 0;
					cReadModeB = 0;
					count++;
					break;
				}
				break;
			default:
				break;
			}
		}
		else
		{
			if (memcmp(token, "teleport", 8) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			else if (memcmp(token, "[END]", 5) == 0)
			{
				cReadModeA = 0;
				cReadModeB = 0;
				break; // Stop While Loop
			}
		}

		token = pStrTok->pGet();

	} // while

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! TELEPORT-LIST configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) TELEPORT-LIST(Total:%d) configuration - success!", count);
	PutLogList(cTxt);

	return true;
} // _bDecodeTeleportListConfigFileContents



bool CGame::RequestStudyMagicHandler(int iClientH, char * pName, bool bIsPurchase)
{
	char  * cp, cMagicName[31], cData[100];
	uint32 * dwp, dwGoldCount;
	uint16  * wp;
	int   * ip, iReqInt, iCost, iRet;
	bool bMagic = true ;

	if (m_pClientList[iClientH] == NULL) return false;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return false;

	ZeroMemory(cData, sizeof(cData));

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);

	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet != -1) {
		if (bIsPurchase == true) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = false ; 
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((uint32)iCost > dwGoldCount)  bMagic = false ; 
			if (!m_pClientList[iClientH]->m_bIsOnTower && 
				(!m_pClientList[iClientH]->IsNeutral() && !m_pClientList[iClientH]->m_bIsOnShop)
				) bMagic = false ;
		}

		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return false;

		if ((iReqInt <= m_pClientList[iClientH]->GetInt()) && (bMagic == true) ) {

			if (bIsPurchase == true) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);

			iCalcTotalWeight(iClientH);

			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;

			dwp  = (uint32 *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + INDEX2_MSGTYPE + 2);

			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;


			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

#ifdef TAIWANLOG 
			_bItemLog(ITEMLOG_MAGICLEARN,iClientH, cMagicName, NULL);
#endif
			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
			}
			return true;
		}
		else {

			dwp  = (uint32 *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;

			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case XSOCKEVENT_QUENEFULL:
			case XSOCKEVENT_SOCKETERROR:
			case XSOCKEVENT_CRITICALERROR:
			case XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
			}
			return false;
		}
	}
	return false;
}

int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
	int i;
	char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < MAXMAGICTYPE; i++) 
		if (m_pMagicConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {

				*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
				*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;

				return i;
			}
		}

	return -1;
}

void CGame::TrainSkillResponse(bool bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
	char  * cp, cData[100];
	uint32 * dwp;
	uint16  * wp;
	int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((iSkillNum < 0)	|| (iSkillNum >= MAXSKILLTYPE)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess == true) {
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] >= iSkillLevel) return;

		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		m_pClientList[iClientH]->CheckTotalSkillMasteryPoints(iSkillNum);

		dwp  = (uint32 *)(cData + INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
		*wp  = NOTIFY_SKILLTRAINSUCCESS;

		cp = (char *)(cData + INDEX2_MSGTYPE + 2);

		*cp = iSkillNum;
		cp++;

		*cp = iSkillLevel;
		cp++;

#ifdef TAIWANLOG
		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL) 
			_bItemLog(ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,NULL) ;
#endif


		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

int CGame::_iGetSkillNumber(char * pSkillName)
{
	int i;
	char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < MAXSKILLTYPE; i++) 
		if (m_pSkillConfigList[i] != NULL) {
			if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {

				return i;
			}
		}

	return 0;
}

void CGame::VariableAdd(CClient * player, CItem * item)
{
	switch(item->m_sItemEffectValue1)
	{
	case 1: // reputation
		player->m_reputation += item->m_dwAttribute;
		break;
	}
}

bool CGame::_bReadMapInfoFiles(int iMapIndex)
{
	char * pContents, * token, cTxt[250], cFn[255];	 
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iTeleportLocIndex  = 0;
	int  iWayPointCfgIndex  = 0;
	int  iTotalNpcSetting   = 0;
	int  iMGARCfgIndex      = 0;
	int  iSMGRCfgIndex      = 0;
	int  iNMRCfgIndex       = 0;
	int  iFishPointIndex 	 = 0;
	int  iMineralPointIndex = 0;
	int  iStrategicPointIndex = 0;
	int  iIndex = 0;
	int  iNumMob = 0;

	HANDLE hFile;
	uint32  dwFileSize, dwReadSize;
	FILE * pFile;

	char cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10];
	short sIPindex;
	SYSTEMTIME SysTime;


	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fight", 5) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = true;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = true;

	GetLocalTime(&SysTime);
	if( SysTime.wYear == 2002 && SysTime.wMonth == 12 && SysTime.wDay == 25 ) {
		m_pMapList[iMapIndex]->m_bIsFixedSnowMode = true;
	}

	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return false;
	}
	else {
		//wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		//PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) 
			{
			case 1:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete[] pContents;

						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:

					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:

					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:

				switch (cReadModeB) 
				{
				case 1:

					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					if(!CreateNpc(cNpcName, iMapIndex, 0, cNpcMoveType, NULL, NULL, (Side)-1, cNpcWaypointIndex, NULL, NULL, false))
					{
						ERR("Failed to create default NPC!");
						break;
					}

					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = atoi(token) ? true : false;
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:

				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete[] pContents;
						return false;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 7:

				switch (cReadModeB) 
				{
				case 1:

					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == true) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = true;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
					break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 8:
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);

				/*if(!m_pMapList[iMapIndex]->m_chatZone){
					if( strcmp(m_pMapList[iMapIndex]->m_cLocationName, sideMap[ARESDEN]) == 0)
						m_pMapList[iMapIndex]->m_chatZone = ARESDEN;
					else if( strcmp(m_pMapList[iMapIndex]->m_cLocationName, sideMap[ELVINE]) == 0)
						m_pMapList[iMapIndex]->m_chatZone = ELVINE;
				}*/
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) 
				{
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 10:

				switch (cReadModeB) 
				{
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = atoi(token) ? true : false;


				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == true)
					m_pMapList[iMapIndex]->m_bIsFixedSnowMode = false;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				switch (cReadModeB)
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = atoi(token) ? true : false;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList_aresdenX = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList_aresdenY = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList_elvineX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList_elvineY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
						wsprintf(g_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(g_cTxt);
						delete[] pContents;
						return false;
					}

					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);

					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);

					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);

					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);

					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);

					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);

					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);

					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);

					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);

					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);

					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;

					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			case 24: // item event
				/*
				; mapdata  
				;item-event = index	item_name	amount	TotalNumber	month	day	type	mob_list[Max:5]
				;	type = 0 :       .
				;	       1 : Item Event       .

				item-event = 	1		1	10		11	1	0	Cannibal-Plant Ettin EOL
				item-event = 	2		1	10		11	1	0	Giant-Frog Scorpion EOL
				*/
				switch (cReadModeB) 
				{
				case 1: //  index
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						wsprintf(g_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(g_cTxt);
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;

				case 2: // item_name
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3: // amount
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4: // total number
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);

					cReadModeB = 5;
					break;

				case 5: // month
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);

					cReadModeB = 6;
					break;

				case 6: // day
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);

					cReadModeB = 7;
					break;

				case 7: // type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iType = atoi(token);

					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob = 0;

					cReadModeB = 8;
					break;

				case 8: // monster list
					if( strcmp(token, "EOL") == 0 ) {
						cReadModeA = 0;
						cReadModeB = 0;
					} else {
						iNumMob = m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob;

						if( iNumMob >= 5 ) {
							cReadModeA = 0;
							cReadModeB = 0;
							PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
							break;
						}

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob] = new char[21];

						ZeroMemory(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob],
							sizeof(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob]) );

						strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cMob[iNumMob], token);

						m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iNumMob ++;

						cReadModeB = 8;
					}
					break;
				}
				break;
			case 25:
				switch (cReadModeB) 
				{
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

			case 26: 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
				delete[] pContents;
						return false;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = (ApocMobGenType)atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: 
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;					
					break;
				case 2: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.left = atoi(token);
					cReadModeB = 3;					
					break;
				case 3: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.top = atoi(token);
					cReadModeB = 4;					
					break;
				case 4: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.right = atoi(token);
					cReadModeB = 5;					
					break;
				case 5: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRect.bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;					
					break;
				}
				break;

			case 28: 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete[] pContents;
					return false;
					return false;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				// DynamicGateType = 1: Opens Gate when Apoc begins
				// DynamicGateType = 2: Open the gate when map is empty
				// DynamicGateType = 3: Gate stays closed will change to 4 value to open it, along with a boss spawn.
				// DynamicGateType = 4: Gate is openned. (set by server when Abaddon is spawning)
				// DynamicGateType = 5: Gate is used by GM command
				cReadModeA = 0;
				cReadModeB = 0;
				break;
								
			case 29: 
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: 
					ZeroMemory(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, sizeof(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap));
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 30: 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = (bool) atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			case 31: 
				if (_bGetIsStringIsNumber(token) == false) 
				{	PutLogList("(!!!) CRITICAL ERROR! Map Info file error HeldenianMap -  Wrong Data format.");
				delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 32: 
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 33: 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_sHeldenianWinningZoneY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: 
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
					delete[] pContents;
					return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
						break;
				}
				break;

			case 36:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error - Chat-zone - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_chatZone = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}

			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;
			if (memcmp(token, "strategic-point", 15) == 0) {
				cReadModeA = 20;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}

			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) 
			{	cReadModeA = 26;
				cReadModeB = 1;
			}
			if (memcmp(token, "ApocalypseBossMob", 17) == 0) 
			{	cReadModeA = 27;
				cReadModeB = 1;
			}
			if (memcmp(token, "DynamicGateType", 15) == 0) 
			{	cReadModeA = 28;
				cReadModeB = 1;
			}
			if (memcmp(token, "DynamicGateCoord", 16) == 0) 
			{	cReadModeA = 29;
				cReadModeB = 1;
			}
						
			if (memcmp(token, "ApocalypseMap", 13) == 0) 
			{	cReadModeA = 30;
				cReadModeB = 1;
			}	
			
			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "chat-zone", 9) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}
			

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}

RMI_SKIPDECODING:;

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);

	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return true;

}

void CGame::Quit()
{
	int i;


	Sleep(300);

	m_astoria.reset(NULL);

	for (i = 0; i < MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < MAXNPCTYPES; i++)
		if (m_npcConfigList[i] != NULL) delete m_npcConfigList[i];

	for (i = 0; i < MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < MAXFISHS; i++)
		if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < MAXMINERALS; i++)
		if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < MAXPORTIONTYPES; i++)
		if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

	for (i = 0; i < MAXCRAFTING; i++)
		if (m_pCraftingConfigList[i] != NULL) delete m_pCraftingConfigList[i];

	for (i = 0; i < MAXBUILDITEMS; i++) 
		if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < MAXDUPITEMID; i++)
		if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	for (i = 0; i < MAXTELEPORTLIST; i++)
		if (m_pTeleportConfigList[i] != NULL) delete m_pTeleportConfigList[i];
	
	if (m_pNoticementData != NULL) delete [] m_pNoticementData;

	if (m_eventsIni != NULL) delete m_eventsIni;

	if (m_pGold != NULL) delete m_pGold;

}

int CGame::iGetLevelExp(int iLevel)
{
	int iRet;

	if (iLevel == 0) return 0;
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
	int iRet;

	if (iLevel < 1) return 1;

	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * iLevel ) / 10;
	}

	return iRet;
}

bool CGame::bCheckLevelUp(int iClientH)
{
	char cLoopCnt;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return false;

	if (m_pClientList[iClientH]->m_iLevel >= PLAYERMAXLEVEL) {
		while(m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[PLAYERMAXLEVEL + 1])
		{
				m_pClientList[iClientH]->m_iExp -= (m_iLevelExpTable[PLAYERMAXLEVEL+1] - m_iLevelExpTable[PLAYERMAXLEVEL]);
				SendNotifyMsg(NULL, iClientH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
		}
		return false;
	}

	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return false;

	cLoopCnt = 0;
	while (1) {
		if (cLoopCnt++ > 100) return false; 		
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			if (m_pClientList[iClientH]->m_iLevel >= PLAYERMAXLEVEL) {
				while(m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[PLAYERMAXLEVEL + 1])
				{
					m_pClientList[iClientH]->m_iExp -= (m_iLevelExpTable[PLAYERMAXLEVEL+1] - m_iLevelExpTable[PLAYERMAXLEVEL]);
					SendNotifyMsg(NULL, iClientH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;
					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
				}
				return false;
			}
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3;

			if (m_pClientList[iClientH]->m_iLevel >= 1 && m_pClientList[iClientH]->m_iLevel <= 50) {
				pItem = new class CItem;
				pItem->InitItemAttr("Gold");
				pItem->m_dwCount = (uint32)50;
				bAddItem(iClientH, pItem);
			}

			if (m_pClientList[iClientH]->GetBaseStr() > CHARPOINTLIMIT)      
				m_pClientList[iClientH]->SetStr(CHARPOINTLIMIT);
			if (m_pClientList[iClientH]->GetBaseDex() > CHARPOINTLIMIT) 
				m_pClientList[iClientH]->SetDex(CHARPOINTLIMIT);
			if (m_pClientList[iClientH]->m_iVit > CHARPOINTLIMIT)
				m_pClientList[iClientH]->m_iVit = CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->GetBaseInt() > CHARPOINTLIMIT)
				m_pClientList[iClientH]->SetInt(CHARPOINTLIMIT);
			if (m_pClientList[iClientH]->GetBaseMag() > CHARPOINTLIMIT)
				m_pClientList[iClientH]->SetMag(CHARPOINTLIMIT);
			if (m_pClientList[iClientH]->m_iCharisma > CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = CHARPOINTLIMIT;

			SendNotifyMsg(NULL, iClientH, NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);


			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);


			CalcTotalItemEffect(iClientH, -1, false);

			if (m_pClientList[iClientH]->m_iLevel > PLAYERMAXLEVEL) {
				wsprintf(g_cTxt, "(!) Player(%s) above max level!", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(g_cTxt);
			}
		}
		else return true;
	}

	return false;
}



void CGame::LevelUpSettingsHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChr;
	int iTotalSetting = 0;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) 
	{

		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChr = *cp;
	cp++;

	//	if(m_pClientList[iClientH]->m_iLU_Pool < 3) {
	//		m_pClientList[iClientH]->m_iLU_Pool = 3;
	//	}


	if ( (cStr + cVit + cDex + cInt + cMag + cChr) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseStr() + cStr > 
		CHARPOINTLIMIT) || (cStr < 0)) 
		return;

	if ((m_pClientList[iClientH]->GetBaseDex() + cDex > 
		CHARPOINTLIMIT) || (cDex < 0)) 
		return;

	if ((m_pClientList[iClientH]->GetBaseInt() + cInt > 
		CHARPOINTLIMIT) || (cInt < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > CHARPOINTLIMIT) || (cVit < 0)) 
		return;

	if ((m_pClientList[iClientH]->GetBaseMag() + cMag > 
		CHARPOINTLIMIT) || (cMag < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + cChr > CHARPOINTLIMIT) || (cChr < 0)) 
		return;

	iTotalSetting = m_pClientList[iClientH]->GetBaseStr() + m_pClientList[iClientH]->GetBaseDex() + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->GetBaseInt() + m_pClientList[iClientH]->GetBaseMag() + m_pClientList[iClientH]->m_iCharisma;

	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3 > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70))
	{
		m_pClientList[iClientH]->m_iLU_Pool = 3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;

		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}


	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChr)
		>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChr);

	m_pClientList[iClientH]->SetStr(m_pClientList[iClientH]->GetBaseStr() + cStr);
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->SetDex(m_pClientList[iClientH]->GetBaseDex() + cDex);
	m_pClientList[iClientH]->SetInt(m_pClientList[iClientH]->GetBaseInt() + cInt);
	m_pClientList[iClientH]->SetMag(m_pClientList[iClientH]->GetBaseMag() + cMag);
	m_pClientList[iClientH]->m_iCharisma  += cChr;

	SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

}


void CGame::FightzoneReserveHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char cData[100];
	int iFightzoneNum ,* ip ,  iEnableReserveTime ;
	uint32 * dwp, dwGoldCount ;
	uint16  * wp, wResult;
	int     iRet, iResult=1, iCannotReserveDay;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	GetLocalTime(&SysTime);

	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;

	dwGoldCount = dwGetItemCount(iClientH, "Gold");

	ip = (int *)(pData + INDEX2_MSGTYPE + 2);
	iFightzoneNum = *ip;

	if ((iFightzoneNum < 1) || (iFightzoneNum > MAXFIGHTZONE)) return;


	//if ((iFightzoneNum >= 1) && (iFightzoneNum <= 4)) return;

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_side + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		wResult = MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		wResult = MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		wResult = MSGTYPE_REJECT;
		iResult = -2 ;
	} else if( iCannotReserveDay ) {
			wResult = MSGTYPE_REJECT;
			iResult = -3 ;
		} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
			wResult = MSGTYPE_REJECT;
			iResult = -4 ;
		} else {

			wResult = MSGTYPE_CONFIRM;

			SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
			iCalcTotalWeight(iClientH);

			m_iFightZoneReserve[iFightzoneNum-1] = iClientH;

			m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
			m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_RESERVEFIGZONE,iClientH,(char *)NULL,NULL) ;
#endif

			if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;			
			else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    
			wsprintf(g_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);
			PutLogFileList(g_cTxt);
			PutLogList(g_cTxt);

			m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
			iResult = 1 ;
		}  

		ZeroMemory(cData, sizeof(cData));

		dwp = (uint32 *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

		wp = (uint16 *)(cData + INDEX2_MSGTYPE);
		*wp =  wResult ;

		ip  = (int *)(cData + INDEX2_MSGTYPE+2) ; 
		*ip =  iResult ;
		ip+= 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);

		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
}


bool CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return false;

	if (m_pClientList[iClientH]->IsNeutral() && 
		(m_pClientList[iClientH]->m_iExp >= m_iLevelExp51 ) ) {

			m_pClientList[iClientH]->m_iExp = m_iLevelExp51 - 1;
			SendNotifyMsg(NULL, iClientH, NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
			return true;
	}

	return false;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
	char * cp, cData[100];
	uint32 * dwp;
	uint16 * wp, wResult;
	int  iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (!m_pClientList[iClientH]->IsNeutral() || m_pClientList[iClientH]->m_iLevel < 5 ||
		m_pClientList[iClientH]->m_iEnemyKillCount > 0) 
	{
		wResult = 0;
	} else {
		wResult = 1;
	}

	if (wResult == 1) {
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);

#ifdef TAIWANLOG
		_bItemLog(ITEMLOG_APPLY, iClientH, (char) 0 , NULL) ;
#endif
	}

	iSetSide(iClientH);
	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = wResult;


	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);

	partyMgr.RemoveFromParty( m_pClientList[iClientH] );
}


void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
	char * cp, cBankItemIndex, cMsg[100];
	int i, j, iRet, iItemWeight;
	uint32 * dwp;
	uint16 * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;


	if (m_pClientList[iClientH]->m_bIsOnWarehouse == false) return ;


	if ((cBankItemIndex < 0) || (cBankItemIndex >= MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		ZeroMemory(cMsg, sizeof(cMsg));

		dwp  = (uint32 *)(cMsg + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (uint16 *)(cMsg + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {

		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {
		//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		if(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_disabled)
			return;

		iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->GetWeight(
			m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			return;
		}

		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_CONSUME) || 
			(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

				for (i = 0; i < MAXITEMS; i++)
					if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
						(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
						(memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {


							SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

							delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
							m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;


							if (m_pClientList[iClientH]->m_pItemList[i] != NULL)
							{
								_bItemLog(ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], 
									(m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == ITEM_ZEM) );
							}



							for ( j = 0; j <= MAXBANKITEMS - 2; j++) {
								if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
									m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];

									m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
								}
							}

							ZeroMemory(cMsg, sizeof(cMsg));

							dwp  = (uint32 *)(cMsg + INDEX4_MSGID);
							*dwp = MSGID_RESPONSE_RETRIEVEITEM;
							wp   = (uint16 *)(cMsg + INDEX2_MSGTYPE);
							*wp  = MSGTYPE_CONFIRM;

							cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
							*cp = cBankItemIndex;
							cp++;
							*cp = i;
							cp++;

							iCalcTotalWeight(iClientH);
							m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);

							m_pClientList[iClientH]->m_bIsBankModified = true ;

							switch (iRet) {
							case XSOCKEVENT_QUENEFULL:
							case XSOCKEVENT_SOCKETERROR:
							case XSOCKEVENT_CRITICALERROR:
							case XSOCKEVENT_SOCKETCLOSED:
								DeleteClient(iClientH, true, true);
								return;
							}
							return;
					}


					goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {

					m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];

					m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
					m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

					m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;

					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;


					if(m_pClientList[iClientH]->m_pItemList[i])
					{
						_bItemLog(ITEMLOG_RETRIEVE, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[i], 
							(m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == ITEM_ZEM ));
					}

					for ( j = 0; j <= MAXBANKITEMS - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];
							m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
						}
					}

					ZeroMemory(cMsg, sizeof(cMsg));

					dwp  = (uint32 *)(cMsg + INDEX4_MSGID);
					*dwp = MSGID_RESPONSE_RETRIEVEITEM;
					wp   = (uint16 *)(cMsg + INDEX2_MSGTYPE);
					*wp  = MSGTYPE_CONFIRM;

					cp = (char *)(cMsg + INDEX2_MSGTYPE + 2);
					*cp = cBankItemIndex;
					cp++;
					*cp = i;
					cp++;

					iCalcTotalWeight(iClientH);

					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);

					m_pClientList[iClientH]->m_bIsBankModified = true ;

					switch (iRet) {
					case XSOCKEVENT_QUENEFULL:
					case XSOCKEVENT_SOCKETERROR:
					case XSOCKEVENT_CRITICALERROR:
					case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
					}
					return;
				}

				ZeroMemory(cMsg, sizeof(cMsg));

				dwp  = (uint32 *)(cMsg + INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (uint16 *)(cMsg + INDEX2_MSGTYPE);
				*wp  = MSGTYPE_REJECT;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
}

void CGame::PK_KillRewardHandler(short sAttackerH, short sVictimH)
{
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictimH] == NULL)   return;

	_bPKLog(PKLOG_BYPLAYER,sAttackerH,sVictimH,NULL) ;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {

	}
	else {

		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictimH]->m_iExp) * 3;

		if (m_pClientList[sAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(NULL, sAttackerH, NOTIFY_PKCAPTURED, m_pClientList[sVictimH]->m_iPKCount, m_pClientList[sVictimH]->m_iLevel, NULL, m_pClientList[sVictimH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	int iRewardExp, iEK_Level;

	if (m_pClientList[iAttackerH] == NULL) return;
	if (m_pClientList[iClientH] == NULL)   return;

	_bPKLog(PKLOG_BYENERMY,iAttackerH,iClientH,NULL) ;

	iEK_Level = 30;
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;

	if (m_pClientList[iAttackerH]->m_iPKCount != 0)
		return;

	if (m_pClientList[iClientH]->m_iGuildRank == GUILDRANK_NONE)
	{
		iRewardExp = (dice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

		if (m_bIsCrusadeMode == true) {
			m_pClientList[iAttackerH]->m_iExp += iRewardExp;
			m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;

			if (m_pClientList[iAttackerH]->m_iWarContribution > MAXWARCONTRIBUTION)
				m_pClientList[iAttackerH]->m_iWarContribution = MAXWARCONTRIBUTION;

			m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

			if (m_pClientList[iAttackerH]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
				m_pClientList[iAttackerH]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;


			SendNotifyMsg(NULL, iAttackerH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

			if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
				m_pClientList[iAttackerH]->m_iEnemyKillCount++;
				m_pClientList[iAttackerH]->m_iEnemyKillTotalCount++;
				m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
			}

			m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
			if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
				m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
			if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
				m_pClientList[iAttackerH]->m_iRewardGold = 0;
		}
		else {
			m_pClientList[iAttackerH]->m_iExp += iRewardExp;


			if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
				m_pClientList[iAttackerH]->m_iEnemyKillCount++;
				m_pClientList[iAttackerH]->m_iEnemyKillTotalCount++;
				m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
			}

			m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
			if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
				m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
			if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
				m_pClientList[iAttackerH]->m_iRewardGold = 0;
		}
	}
	else 
	{
		iRewardExp = (dice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

		if (m_bIsCrusadeMode == true) {
			m_pClientList[iAttackerH]->m_iExp += iRewardExp;
			m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp)*5;

			if (m_pClientList[iAttackerH]->m_iWarContribution > MAXWARCONTRIBUTION)
				m_pClientList[iAttackerH]->m_iWarContribution = MAXWARCONTRIBUTION;

			m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

			if (m_pClientList[iAttackerH]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
				m_pClientList[iAttackerH]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

			SendNotifyMsg(NULL, iAttackerH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

			if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
				m_pClientList[iAttackerH]->m_iEnemyKillCount++;
				m_pClientList[iAttackerH]->m_iEnemyKillTotalCount++;
				m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
			}

			m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
			if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
				m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
			if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
				m_pClientList[iAttackerH]->m_iRewardGold = 0;
		}
		else {
			m_pClientList[iAttackerH]->m_iExp += iRewardExp;

			if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
				m_pClientList[iAttackerH]->m_iEnemyKillCount++;
				m_pClientList[iAttackerH]->m_iEnemyKillTotalCount++;
				m_pClientList[iAttackerH]->ApplyElo(m_pClientList[iClientH]);
			}

			m_pClientList[iAttackerH]->m_iRewardGold += dice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
			if (m_pClientList[iAttackerH]->m_iRewardGold > MAXREWARDGOLD) 
				m_pClientList[iAttackerH]->m_iRewardGold = MAXREWARDGOLD;
			if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
				m_pClientList[iAttackerH]->m_iRewardGold = 0;
		}
	}

	SendNotifyMsg(NULL, iAttackerH, NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);

	if (bCheckLimitedUser(iAttackerH) == false) {

		SendNotifyMsg(NULL, iAttackerH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	bCheckLevelUp(iAttackerH);


	m_stCityStatus[m_pClientList[iAttackerH]->m_side].iWins++;
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
	int iEraseReq, iWeightLeft, iRewardGoldLeft;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);

	if (iWeightLeft <= 0) return;

	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	pItem->InitItemAttr("Gold");
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;

	
	if ((iWeightLeft / pItem->GetWeight(1)) >= m_pClientList[iClientH]->m_iRewardGold) {

		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		
		pItem->m_dwCount = (iWeightLeft / pItem->GetWeight(1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / pItem->GetWeight(1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) {

		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

		if (iEraseReq == 1) delete pItem;

		SendNotifyMsg(NULL, iClientH, NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return 0;
	return (m_pClientList[iClientH]->GetStr() * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, uint32 dwLastTime, int iV1)
{
	int i;
	short sPreType;
	uint32 dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	switch (sType) {
	case DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == false)
			return NULL;

		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_weather) {
			case WEATHER_LIGHTRAIN:		dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case WEATHER_MEDIUMRAIN:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case WEATHER_HEAVYRAIN:		dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;

	case DYNAMICOBJECT_FISHOBJECT:
	case DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == false)
			return NULL;
		break;

	case DYNAMICOBJECT_MINERAL1:
	case DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == false)
			return NULL;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, false);
		break;
	case DYNAMICOBJECT_ARESDENFLAG:
	case DYNAMICOBJECT_ELVINEFLAG:
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, false);
		break;
	}


	for (i = 1; i < MAXDYNAMICOBJECTS; i++) 
		if (m_pDynamicObjectList[i] == NULL) {
			dwTime = timeGetTime();

			if (dwLastTime != NULL) 
				dwLastTime += (dice(1,4)*1000);

			m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
			m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

			return i;
		}

	return NULL;
}

void CGame::CheckDynamicObjectList()
{
	int i;
	uint32 dwTime = timeGetTime(), dwRegisterTime;
	short sType;

	for (i = 1; i < MAXDYNAMICOBJECTS; i++) {
		if (m_pDynamicObjectList[i] && m_pDynamicObjectList[i]->m_dwLastTime != 0) 
		{

			switch (m_pDynamicObjectList[i]->m_sType) 
			{
			case DYNAMICOBJECT_FIRE:

				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_weather) 
				{
				case WEATHER_LIGHTRAIN: 
				case WEATHER_MEDIUMRAIN:
				case WEATHER_HEAVYRAIN:
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
						(m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_weather;
					break;
				}
				break;
			}

			if (dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime >= m_pDynamicObjectList[i]->m_dwLastTime) 
			{
				m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );

				if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
					SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
				}

				switch (sType) 
				{
				case DYNAMICOBJECT_FISHOBJECT:
				case DYNAMICOBJECT_FISH:
					bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); 
					break;
				}

				delete m_pDynamicObjectList[i];
				m_pDynamicObjectList[i] = NULL;
			}
		}
	}
}

void CGame::MobGenerator()
{
	int i, j, iResult, iTotalMob;
	char cNpcName[21], cWaypoint[11];
	char cSA;
	int  pX, pY, iMapLevel, iProbSA, iKindSA, iFirmSAType;
	bool bFirmBerserk, bIsSpecialEvent;
	short sNpcType = 0 ;


	if (m_bOnExitProcess == true) return;

	for (i = 0; i < MAXMAPS; i++)
	{
		if(!m_pMapList[i]) 
			continue;

		if(m_pMapList[i]->m_bIsHeldenianMap && m_bHeldenianMode && m_iHeldenianType == 1)
			continue;
			
		if(m_iMiddlelandMapIndex != -1 && m_iMiddlelandMapIndex == i && m_bIsCrusadeMode) 
			continue;

		if(m_pMapList[i]->m_bRandomMobGenerator && 
			m_pMapList[i]->m_iMaximumObject - 30 > m_pMapList[i]->m_iTotalActiveObject)
		{
			ZeroMemory(cNpcName, sizeof(cNpcName));

			iFirmSAType  = NULL;
			bFirmBerserk = false;
			iResult = dice(1,100);
			switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) 
			{
			case 1:
				if ((iResult >= 1) && (iResult < 20)) {
					iResult = 1;  					}
				else if ((iResult >= 20) && (iResult < 40)) {
					iResult = 2;  
				}
				else if ((iResult >= 40) && (iResult < 85)) {
					iResult = 24; 					}
				else if ((iResult >= 85) && (iResult < 95)) {
					iResult = 25; 
				}
				else if ((iResult >= 95) && (iResult <= 100)) {
					iResult = 3;  					}

				iMapLevel = 1;
				break;

			case 2:
				if ((iResult >= 1) && (iResult < 40)) {
					iResult = 1;
				}
				else if ((iResult >= 40) && (iResult < 80)) {
					iResult = 2;
				}
				else iResult = 10;
				iMapLevel = 1;
				break;

			case 3:     
				if ((iResult >= 1) && (iResult < 20)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 3; break;
					case 2: iResult = 4; break;
					}
				}
				else if ((iResult >= 20) && (iResult < 25)) {
					iResult = 30;  
				}
				else if ((iResult >= 25) && (iResult < 50)) {
					switch ( dice(1,3) ) {
					case 1: iResult = 5; break;
					case 2:	iResult = 6; break;
					case 3: iResult = 7; break;
					}
				}
				else if ((iResult >= 50) && (iResult < 75)) {

					switch ( dice(1,7) ) {
					case 1: 
					case 2: iResult = 8;  break;
					case 3:	iResult = 11; break;
					case 4:	iResult = 12; break;
					case 5: iResult = 18; break;
					case 6: iResult = 26; break;
					case 7: iResult = 28; break;	// Ettin
					}
				}
				else if ((iResult >= 75) && (iResult <= 100)) {

					switch ( dice(1,5) ) {
					case 1:
					case 2:	iResult = 9;  break;
					case 3:	iResult = 13; break;
					case 4: iResult = 14; break;
					case 5: iResult = 27; break;	// Mountain-Giant
					}
				}
				iMapLevel = 4;
				break;

			case 4:
				if ((iResult >= 1) && (iResult < 50)) {
					switch ( dice(1,2) ) {
					case 1:	iResult = 2; break;
					case 2: iResult = 10; break;
					}
				}
				else if ((iResult >= 50) && (iResult < 80)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 8; break;
					case 2: iResult = 11; break;
					}
				}
				else if ((iResult >= 80) && (iResult < 100)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 14; break;
					case 2:	iResult = 9; break;
					}
				}
				iMapLevel = 2;
				break;

			case 5:
				if ((iResult >= 1) && (iResult < 30)) {
					switch ( dice(1,5) ) {
					case 1:
					case 2: 
					case 3:
					case 4: 
					case 5: iResult = 2; break;
					}
				}
				else if ((iResult >= 30) && (iResult < 60)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 3; break;
					case 2: iResult = 4; break;
					}
				}
				else if ((iResult >= 60) && (iResult < 80)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 5; break;
					case 2: iResult = 7; break;
					}
				}
				else if ((iResult >= 80) && (iResult < 95)) {
					switch ( dice(1,3) ) {
					case 1:
					case 2: iResult = 8;  break;
					case 3:	iResult = 11; break;
					}
				}
				else if ((iResult >= 95) && (iResult <= 100)) {
					switch ( dice(1,3) ) {
					case 1: iResult = 11; break;
					case 2: iResult = 14; break;
					case 3: iResult = 9; break;
					}
				}
				iMapLevel = 3;
				break;

			case 6: // huntzone 2,4
				if ((iResult >= 1) && (iResult < 60)) {
					switch ( dice(1,4) ) {
					case 1: iResult = 5; break;
					case 2:	iResult = 6; break;
					case 3: iResult = 7; break;
					case 4: iResult = 4; break;
					}
				}
				else if ((iResult >= 60) && (iResult < 90)) {
					switch ( dice(1,4) ) {
					case 1:
					case 2: iResult = 8;  break;
					case 3:	iResult = 11; break;
					case 4:	iResult = 12; break;
					}
				}
				else if ((iResult >= 90) && (iResult <= 100)) {


					switch ( dice(1,7) ) {
					case 1: iResult = 26; break;
					case 2:	iResult = 9;  break;
					case 3:	iResult = 13; break;
					case 4: iResult = 14; break;
					case 5: iResult = 18; break;
					case 6: iResult = 28; break;	// Ettin
					case 7: iResult = 27; break;	// Mountain-Giant
					}
				}
				iMapLevel = 4;
				break;

			case 7: // areuni, elvuni
				if ((iResult >= 1) && (iResult < 25)) {
					switch (dice(1,5)) {
					case 1: iResult = 3;  break; // Orc
					case 2: iResult = 6;  break; // Orc-Mage
					case 3: iResult = 10; break; // Amphis
					case 4: iResult = 3;  break; // Orc
					case 5: iResult = 50; break; // Giant-Tree
					}
				}
				else if ((iResult >= 25) && (iResult < 40)) {
					iResult = 30; // Rudolph
				}
				else if ((iResult >= 40) && (iResult < 90)) {
					switch (dice(1,4)) {
					case 1: iResult = 50; break; // Giant-Tree
					case 2: 
					case 3: iResult = 6;  break; // Orc-Mage
					case 4: iResult = 12; break; // Troll
					}
				}
				else if ((iResult >= 95) && (iResult <= 100)) {
					iResult = 17; // Unicorn
				}
				iMapLevel = 4;
				break;

			case 8:
				if ((iResult >= 1) && (iResult < 70)) {
					switch ( dice(1,2) ) {
					case 1:	iResult = 4;  break;
					case 2: iResult = 5;  break;
					}
				}
				else if ((iResult >= 70) && (iResult < 90)) {
					switch ( dice(1,3) ) {
					case 1: iResult = 8;  break;
					case 2: iResult = 11; break;
					case 3: iResult = 14; break;
					}
				}
				else if ((iResult >= 90) && (iResult < 100)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 9;  break;
					case 2: iResult = 14; break;
					}
				}
				iMapLevel = 4;
				break;

			case 9:
				if ((iResult >= 1) && (iResult < 70)) {
					switch ( dice(1,2) ) {
					case 1:	iResult = 4;  break;
					case 2: iResult = 5;  break;
					}
				}
				else if ((iResult >= 70) && (iResult < 95)) {
					switch ( dice(1,3) ) {
					case 1: iResult = 8;  break;
					case 2: iResult = 9;  break;
					case 3: iResult = 13; break;
					}
				}
				else if ((iResult >= 95) && (iResult < 100)) {
					switch ( dice(1,6) ) {
					case 1:
					case 2:
					case 3: iResult = 9;  break;
					case 4:
					case 5: iResult = 14; break;
					case 6: iResult = 15; break;
					}
				}


				if ((dice(1,3) == 1) && (iResult != 16)) bFirmBerserk = true;

				iMapLevel = 4;
				break;

			case 10:
				if ((iResult >= 1) && (iResult < 70)) {
					switch ( dice(1,2) ) {
					case 1:	iResult = 4; break;
					case 2: iResult = 5; break;
					}
				}
				else if ((iResult >= 70) && (iResult < 95)) {
					// 
					switch ( dice(1,3) ) {
					case 1:
					case 2:	iResult = 13; break;
					case 3: iResult = 14; break;
					}
				}
				else if ((iResult >= 95) && (iResult < 100)) {
					switch (dice(1,3)) {
					case 1:
					case 2: iResult = 14; break;
					case 3: iResult = 15; break;
					}
				}


				if ((dice(1,3) == 1) && (iResult != 16)) bFirmBerserk = true;

				iMapLevel = 5;
				break;

			case 11:
				if ((iResult >= 1) && (iResult < 30)) {
					switch ( dice(1,5) ) {
					case 1:
					case 2: 
					case 3:
					case 4: 
					case 5: iResult = 2; break;
					}
				}
				else if ((iResult >= 30) && (iResult < 60)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 3; break;
					case 2: iResult = 4; break;
					}
				}
				else if ((iResult >= 60) && (iResult < 80)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 5; break;
					case 2: iResult = 7; break;
					}
				}
				else if ((iResult >= 80) && (iResult < 95)) {
					switch ( dice(1,3) ) {
					case 1:
					case 2: iResult = 10;  break;
					case 3:	iResult = 11; break;
					}
				}
				else if ((iResult >= 95) && (iResult <= 100)) {
					switch ( dice(1,3) ) {
					case 1: iResult = 11; break;
					case 2: iResult = 7; break;
					case 3: iResult = 8; break;
					}
				}
				iMapLevel = 4;
				break;

			case 12: // middled1n
				if ((iResult >= 1) && (iResult < 50)) {
					switch ( dice(1,3) ) {
					case 1:	iResult = 1 ; break;
					case 2: iResult = 2 ; break;
					case 3: iResult = 10; break;
					}
				}
				else if ((iResult >= 50) && (iResult < 85)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 5; break;
					case 2: iResult = 4; break;
					}
				}
				else if ((iResult >= 85) && (iResult < 100)) {
					switch ( dice(1,3) ) {
					case 1: iResult = 8; break;
					case 2: iResult = 11; break;
					case 3: iResult = 26; break;
					}
				}
				iMapLevel = 4;
				break;

			case 13: 					
				if ((iResult >= 1) && (iResult < 15)) {
					iResult = 4;
					bFirmBerserk = true;
					iFirmSAType  = 4 - (dice(1,2)-1);
				}
				else if ((iResult >= 15) && (iResult < 40)) {
					iResult = 14;
					bFirmBerserk = true;
					iFirmSAType  = 4 - (dice(1,2)-1);
				}

				else if ((iResult >= 40) && (iResult < 60)) {
					iResult = 9;
					bFirmBerserk = true;
					iFirmSAType  = 4 - (dice(1,2)-1);
				}
				else if ((iResult >= 60) && (iResult < 75)) {
					iResult = 13;
					bFirmBerserk = true;
					iFirmSAType  = 4 - (dice(1,2)-1);
				}
				else if ((iResult >= 75) && (iResult < 95)) {

					iResult = 23;
				}
				else if ((iResult >= 95) && (iResult < 100)) {

					iResult = 22;
				}
				iMapLevel = 4;
				break;

			case 14: 					
				if ((iResult >= 1) && (iResult < 30)) {
					iResult = 23;
				}
				else if ((iResult >= 30) && (iResult < 50)) {

					iResult = 22;
				}
				else if ((iResult >= 50) && (iResult < 70)) {
					iResult = 15;
					bFirmBerserk = true;
					iFirmSAType  = 4 - (dice(1,2)-1);
				}
				else if ((iResult >= 70) && (iResult < 90)) {
					iResult = 16;
				}
				else if ((iResult >= 90) && (iResult < 100)) {

					iResult = 21;
				}
				iMapLevel = 4;
				break;

			case 15: 
				if ((iResult >= 1) && (iResult < 35)) {

					iResult = 23;
					bFirmBerserk = true;
				}
				else if ((iResult >= 35) && (iResult < 50)) {

					iResult = 22;
					bFirmBerserk = true;
				}
				else if ((iResult >= 50) && (iResult < 80)) {
					iResult = 16;
					bFirmBerserk = true;
				}
				else if ((iResult >= 80) && (iResult < 100)) {

					iResult = 21;
				}
				iMapLevel = 4;
				break;
			case 16: 
				if ((iResult >= 1) && (iResult < 40)) {
					switch ( dice(1,3) ) {
					case 1:	iResult = 1 ; break;
					case 2: iResult = 2 ; break;
					case 3: iResult = 10; break;
					}
				}
				else if ((iResult >= 40) && (iResult < 50)) {
					iResult = 30;
				}
				else if ((iResult >= 50) && (iResult < 85)) {
					switch ( dice(1,2) ) {
					case 1: iResult = 5; break;
					case 2: iResult = 4; break;
					}
				}
				else if ((iResult >= 85) && (iResult < 100)) {
					switch ( dice(1,3) ) {
					case 1: iResult = 8; break;
					case 2: iResult = 11; break;
					case 3: iResult = 26; break;
					}
				}
				iMapLevel = 1 ;
				break;
			case 17:
				if ((iResult >= 1) && (iResult < 30)) {
					switch ( dice(1,4) ) {
					case 1:	iResult = 22 ; break;
					case 2: iResult = 8; break;
					case 3: iResult = 24 ; break;
					case 4: iResult = 5; break;
					}
				}
				else if ((iResult >= 30) && (iResult < 40)) {
					iResult = 30;
				}
				else if ((iResult >= 40) && (iResult < 70)) {
					iResult = 32;

				}
				else if ((iResult >= 70) && (iResult < 90)) {
					iResult = 31;
					if (dice(1,5) == 1) bFirmBerserk = true;
				}
				else if ((iResult >= 90) && (iResult <= 100)) {
					iResult = 33;
				}
				iMapLevel = 1 ;
				break;
			case 18:
				if ((iResult == 1) || (iResult == 2)) 
				{	iResult = 35; // Hellclaw
				}else if ((iResult > 2) && (iResult <= 12)) 
				{	iResult = 48; // Nizie
				}else if ((iResult > 12) && (iResult <= 50)) 
				{	iResult = 44; // ClawTurtle
				}else if ((iResult > 50) && (iResult <= 85)) 
				{	iResult = 45; // Giant-Crayfish
				}else if ((iResult > 85) && (iResult <= 95)) 
				{	iResult = 34; // Stalker							
				}else if ((iResult > 95) && (iResult <= 100)) 
				{	iResult = 26; // Frog
				}
				break;

			case 19: // Maze Map from HBChina351
				if ((iResult >= 1) && (iResult <= 15)) 
				{	iResult = 40; // Centaur
				}else if ((iResult > 15) && (iResult <= 25)) 
				{	iResult = 42; // Minaus
				}else if ((iResult > 25) && (iResult <= 35)) 
				{	iResult = 21; // Gagoyle
				}else if ((iResult > 35) && (iResult <= 60)) 
				{	iResult = 43; // Tentocle					
				}else if ((iResult > 60) && (iResult < 90)) 
				{	iResult = 23; // Dark-Elf					
				}else if ((iResult >= 90) && (iResult <= 100)) 
				{	iResult = 22; // Beholder
				}
				break;

			case 20: // Heldenian Map from HBChina351
				if (iResult == 1)  
				{	iResult = 37; // Fire-Wyvern
				}else if ((iResult > 1) && (iResult <=3)) 
				{	iResult = 36; // Wyvern
				}else if ((iResult > 3) && (iResult <= 8)) 
				{	iResult = 49; // TigerWorm
				}else if ((iResult == 9)) 
				{	iResult = 38; // HC
				}else if ((iResult > 9) && (iResult <= 20)) 
				{	iResult = 21; // Gagoyle
				}else if ((iResult > 20) && (iResult <= 35)) 
				{	iResult = 16; // Demon
				}else if ((iResult > 35) && (iResult <= 45)) 
				{	iResult = 40; // Centaurus
				}else if ((iResult > 45) && (iResult <= 55)) 
				{	iResult = 41; // Giant Lizard
				}else if ((iResult > 55) && (iResult <= 75)) 
				{	iResult = 28; // Ettin					
				}else if ((iResult > 75) && (iResult <= 95)) 
				{	iResult = 43; // Tentocle
				}else if ((iResult > 95) && (iResult <= 100)) 
				{	iResult = 22; // Beholder
				}
				break;
					
			case 21: // ????????
				if ((iResult >= 1) && (iResult < 94)) 
				{	iResult = 17; // Unicorn
					bFirmBerserk = true;
				}else if ((iResult >= 94) && (iResult < 95)) 
				{	iResult = 36; // Wyvern
				}else if ((iResult >= 95) && (iResult < 96)) 
				{	iResult = 37; // Fire-Wyvern
				}else if ((iResult >= 96) && (iResult < 97)) 
				{	iResult = 47; // MasterMage-Orc
				}else if ((iResult >= 97) && (iResult < 98)) 
				{	iResult = 35; // Hellclaw
				}else if ((iResult >= 98) && (iResult < 99)) 
				{	iResult = 49; // Tigerworm
				}else if ((iResult >= 99) && (iResult <= 100)) 
				{	iResult = 51; // Abaddon
				}
				break;

			case 22: // middleland
				iResult = 27; // Mountain Giant
				iMapLevel = 3;
				break;
			}

			pX = NULL;
			pY = NULL;


			bIsSpecialEvent = false;
			if ((m_bIsSpecialEventTime == true) && (dice(1,10) == 3)) bIsSpecialEvent = true;

			if (bIsSpecialEvent == true) {
				switch (m_cSpecialEventType) {
				case 1:
					if (m_pMapList[i]->m_iMaxPx != 0) {
						pX = m_pMapList[i]->m_iMaxPx*20 +10;
						pY = m_pMapList[i]->m_iMaxPy*20 +10;

						if (pX < 0) pX = 0;
						if (pY < 0) pY = 0;

						if (m_bIsCrusadeMode == true) {
							if (strcmp(m_pMapList[i]->m_cName, sideMap[ARESDEN]) == 0)
								iResult = 20;
							else if (strcmp(m_pMapList[i]->m_cName, sideMap[ELVINE]) == 0)
								iResult = 19;
						}

						wsprintf(g_cTxt, "(!) Mob-Event Map(%s) Loc(%d,%d)", m_pMapList[i]->m_cName, pX, pY);
						PutLogList(g_cTxt);
					}
					break;

				case 2:
					if (dice(1,3) == 2) {
						if ((memcmp(m_pMapList[i]->m_cName, sideMap[ARESDEN], 7)   == 0) ||
							(memcmp(m_pMapList[i]->m_cName, "middled1n", 9) == 0) ||
							(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ||
							(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
							(memcmp(m_pMapList[i]->m_cName, sideMap[ELVINE], 6)    == 0)) {
								if (dice(1,30) == 5) 
									iResult = 16;
								else iResult = 5;
						}
						else iResult = 16;
					}
					else iResult = 17;

					m_bIsSpecialEventTime = false;
					break;
				}
			}

			ZeroMemory(cNpcName, sizeof(cNpcName));
			switch (iResult) {
			case 1:  strcpy(cNpcName, "Slime");     sNpcType = 10 ;   iProbSA = 5;  iKindSA = 1; break;
			case 2:  strcpy(cNpcName, "Giant-Ant"); sNpcType = 16 ;   iProbSA = 10; iKindSA = 2; break;
			case 3:  strcpy(cNpcName, "Orc");       sNpcType = 14 ;   iProbSA = 15; iKindSA = 1; break;
			case 4:  strcpy(cNpcName, "Zombie");    sNpcType = 18 ;   iProbSA = 15; iKindSA = 3; break;
			case 5:  strcpy(cNpcName, "Skeleton");  sNpcType = 11 ;   iProbSA = 35; iKindSA = 8; break;
			case 6:  strcpy(cNpcName, "Orc-Mage");  sNpcType = 14 ;   iProbSA = 30; iKindSA = 7; break;
			case 7:  strcpy(cNpcName, "Scorpion");  sNpcType = 17 ;   iProbSA = 15; iKindSA = 3; break;
			case 8:  strcpy(cNpcName, "Stone-Golem"); sNpcType = 12 ; iProbSA = 25; iKindSA = 5; break;
			case 9:  strcpy(cNpcName, "Cyclops");    sNpcType = 13 ;  iProbSA = 35; iKindSA = 8; break;
			case 10: strcpy(cNpcName, "Amphis");     sNpcType = 22 ;  iProbSA = 20; iKindSA = 3; break;
			case 11: strcpy(cNpcName, "Clay-Golem"); sNpcType = 23 ;  iProbSA = 20; iKindSA = 5; break;
			case 12: strcpy(cNpcName, "Troll");      sNpcType = 28 ;  iProbSA = 25; iKindSA = 3; break; 
			case 13: strcpy(cNpcName, "Orge");       sNpcType = 29 ;  iProbSA = 25; iKindSA = 1; break;
			case 14: strcpy(cNpcName, "Hellbound");  sNpcType = 27 ;  iProbSA = 25; iKindSA = 8; break;
			case 15: strcpy(cNpcName, "Liche");		 sNpcType = 30 ;  iProbSA = 30; iKindSA = 8; break;
			case 16: strcpy(cNpcName, "Demon");		 sNpcType = 31 ;  iProbSA = 20; iKindSA = 8; break;
			case 17: strcpy(cNpcName, "Unicorn");	 sNpcType = 32 ;  iProbSA = 35; iKindSA = 7; break;
			case 18: strcpy(cNpcName, "WereWolf");	 sNpcType = 33 ;  iProbSA = 25; iKindSA = 1; break;
			case 19: strcpy(cNpcName, "YB-Aresden"); sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
			case 20: strcpy(cNpcName, "YB-Elvine");	 sNpcType = 1 ;   iProbSA = 15; iKindSA = 1; break;
			case 21: strcpy(cNpcName, "Gagoyle");	 sNpcType = 52 ;  iProbSA = 20; iKindSA = 8; break;
			case 22: strcpy(cNpcName, "Beholder");	 sNpcType = 53 ;  iProbSA = 20; iKindSA = 5; break;
			case 23: strcpy(cNpcName, "Dark-Elf");	 sNpcType = 54 ;  iProbSA = 20; iKindSA = 3; break;

			case 24: strcpy(cNpcName, "Rabbit");	 sNpcType = 55 ;  iProbSA =  5; iKindSA = 1; break;
			case 25: strcpy(cNpcName, "Cat");		 sNpcType = 56 ;  iProbSA = 10; iKindSA = 2; break;
			case 26: strcpy(cNpcName, "Giant-Frog"); sNpcType = 57 ;  iProbSA = 10; iKindSA = 2; break;

			case 27: strcpy(cNpcName, "Mountain-Giant");  sNpcType = 58 ; 	iProbSA = 25; iKindSA = 1; break;
			case 28: strcpy(cNpcName, "Ettin");			  sNpcType = 59 ;	iProbSA = 20; iKindSA = 8; break;
			case 29: strcpy(cNpcName, "Cannibal-Plant");  sNpcType = 60 ; 	iProbSA = 20; iKindSA = 5; break;

			case 30: strcpy(cNpcName, "Rudolph");    sNpcType = 61 ; 	iProbSA = 20; iKindSA = 5; break;
			case 31: strcpy(cNpcName, "Ice-Golem");  sNpcType = 65 ;    iProbSA = 35; iKindSA = 8; break;
			case 32: strcpy(cNpcName, "DireBoar");  sNpcType = 62 ; 	iProbSA = 20; iKindSA = 5; break;
			case 33: strcpy(cNpcName, "Frost");		 sNpcType = 63 ;    iProbSA = 30; iKindSA = 8; break;

			case 34: strcpy(cNpcName, "Stalker");           sNpcType = 48; iProbSA = 20; iKindSA = 1; break;
			case 35: strcpy(cNpcName, "Hellclaw");			sNpcType = 49; iProbSA = 20; iKindSA = 1; break;
			case 36: strcpy(cNpcName, "Wyvern");			sNpcType = 66; iProbSA = 20; iKindSA = 10; break;
			case 37: strcpy(cNpcName, "Fire-Wyvern");		sNpcType = 73; iProbSA = 20; iKindSA = 10; break; 
			case 38: strcpy(cNpcName, "Barlog");			sNpcType = 70; iProbSA = 20; iKindSA = 1; break;
			case 39: strcpy(cNpcName, "Tentocle");			sNpcType = 80; iProbSA = 20; iKindSA = 1; break;
			case 40: strcpy(cNpcName, "Centaurus");			sNpcType = 71; iProbSA = 20; iKindSA = 1; break;
			case 41: strcpy(cNpcName, "Giant-Lizard");		sNpcType = 75; iProbSA = 20; iKindSA = 1; break;
			case 42: strcpy(cNpcName, "Minotaurs");			sNpcType = 78; iProbSA = 20; iKindSA = 1; break;
			case 43: strcpy(cNpcName, "Tentocle");			sNpcType = 80; iProbSA = 20; iKindSA = 1; break;
			case 44: strcpy(cNpcName, "Claw-Turtle");		sNpcType = 72; iProbSA = 20; iKindSA = 1; break;
			case 45: strcpy(cNpcName, "Giant-Crayfish");	sNpcType = 74; iProbSA = 20; iKindSA = 1; break;
			case 46: strcpy(cNpcName, "Giant-Plant");		sNpcType = 76; iProbSA = 20; iKindSA = 1; break;
			case 47: strcpy(cNpcName, "MasterMage-Orc");	sNpcType = 77; iProbSA = 20; iKindSA = 1; break;
			case 48: strcpy(cNpcName, "Nizie");				sNpcType = 79; iProbSA = 20; iKindSA = 1; break;
			case 49: strcpy(cNpcName, "Tigerworm");			sNpcType = 50; iProbSA = 20; iKindSA = 1; break;
			case 50: strcpy(cNpcName, "Giant-Plant");		sNpcType = 76; iProbSA = 20; iKindSA = 1; break;
			case 51: strcpy(cNpcName, "Abaddon");			sNpcType = 81; iProbSA = 20; iKindSA = 10; break;
			default: strcpy(cNpcName, "Orc");		      sNpcType = 14 ; 	iProbSA = 15; iKindSA = 1; break;
			}

			cSA = 0;
			if (iFirmSAType == NULL) {
				if (dice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
			}
			else cSA = (char)iFirmSAType;

			CNpc * master = CreateNpc(cNpcName, i, cSA, MOVETYPE_RANDOM, &pX, &pY, (Side)-1, 
				cWaypoint, NULL, NULL, false, false, bFirmBerserk, true);

			if(!master)
			{
				iResult = 0;
			}

			switch (iResult) 
			{
			case 1:	 iTotalMob = dice(1,5)-1; break;  // Slime 
			case 2:	 iTotalMob = dice(1,5)-1; break; // Giant-Ant
			case 3:	 iTotalMob = dice(1,5)-1; break; // Orc
			case 4:	 iTotalMob = dice(1,3)-1; break; // Zombie
			case 5:	 iTotalMob = dice(1,3)-1; break;
			case 6:  iTotalMob = dice(1,3)-1; break; // Skeleton
			case 7:  iTotalMob = dice(1,3)-1; break; // Scorpion
			case 8:  iTotalMob = dice(1,2)-1; break; // Stone-Golem
			case 9:  iTotalMob = dice(1,2)-1; break;
			case 10: iTotalMob = dice(1,5)-1; break; // Amphis
			case 11: iTotalMob = dice(1,3)-1; break; // Clay-Golem
			case 12: iTotalMob = dice(1,5)-1; break; // Troll
			case 13: iTotalMob = dice(1,3)-1; break; // Orge
			case 14: iTotalMob = dice(1,3)-1; break; // Rabbit
			case 15: iTotalMob = dice(1,3)-1; break; // Cat
			case 16: iTotalMob = dice(1,2)-1; break; // Giant-Frog
			case 17: iTotalMob = dice(1,2)-1; break; // Mountain-Giant
			case 18: iTotalMob = dice(1,5)-1; break; // Ettin
			case 21: iTotalMob = dice(1,2)-1; break; // Cannibal-Plant
			case 22: iTotalMob = dice(1,2)-1; break;
			case 23: iTotalMob = dice(1,5)-1; break;

			case 24: iTotalMob = dice(1,2)-1; break;
			case 25: iTotalMob = dice(1,2)-1; break;
			case 26: iTotalMob = dice(1,4)-1; break;
				// 2002-09-12 #1
			case 27: iTotalMob = dice(1,2)-1; break;
			case 28: iTotalMob = dice(1,3)-1; break;
			case 29: iTotalMob = dice(1,3)-1; break;

			case 30: iTotalMob = dice(1,3)-1; break;

			case 31: iTotalMob = dice(1,5)-1; break;
			case 32: iTotalMob = dice(1,3)-1; break;
			case 33: iTotalMob = dice(1,3)-1; break;
			case 34: iTotalMob = 1; break;
			case 35: iTotalMob = 1; break;
			case 36: iTotalMob = 1; break;

			case 37: iTotalMob = 1; break;
			case 38: iTotalMob = 1; break;
			case 39: iTotalMob = 1; break;
			case 40: iTotalMob = 1; break;
			case 41: iTotalMob = 1; break;

			case 42: iTotalMob = dice(1,3)-1; break;
			case 43: iTotalMob = 1; break;
			case 44: iTotalMob = dice(1,3)-1; break; 
			case 45: iTotalMob = 1; break;

			default: iTotalMob = 0; break;
			}

			//if ((iTotalMob >= 2) && (dice(1,2) == 1)) iTotalMob = 0;


			if (iTotalMob >= 2) 
			{
				switch (iResult) 
				{
				case 1:   // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
				case 24: // Rabbit
				case 25: // Cat
				case 26: // Giant-Frog
				case 27: // Mountain-Giant
				case 28: // Ettin
				case 29: // Cannibal-Plant

				case 30:
				case 32: // DireBoar
				case 33: // Frost
					if (dice(1,5) != 1) iTotalMob = 0;  
					break;

				case 9:  // Cyclops
				case 6:  // Orc-Mage
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 31: // Ice-Golem
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 44:
				case 45:
				case 46:
				case 47:
				case 48:
				case 49:
					if (dice(1,5) == 1) iTotalMob = 0;  
					break;

				default: 					break;
				}
			}

			// 2002-7-4
			if (bIsSpecialEvent == true) {
				switch (m_cSpecialEventType) {
				case 1:
					if ((iResult != 15) && (iResult != 16) && (iResult != 21))
						iTotalMob = m_pMapList[i]->sMobEventAmount;

					for (j = 1; j < MAXCLIENTS; j++) 
						if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == true) && (m_pClientList[j]->m_cMapIndex == i)) 
							SendNotifyMsg(NULL, j, NOTIFY_MONSTEREVENT_POSITION, pX, pY, sNpcType, NULL);

					break;

				case 2:
					if ( (memcmp(m_pMapList[i]->m_cName, sideMap[ARESDEN], 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cName, sideMap[ELVINE],  6) == 0) ||
						(memcmp(m_pMapList[i]->m_cName, "elvfarm", 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cName, "arefarm", 7) == 0) ) {

							iTotalMob = 0;
					}
					break;
				}
				m_bIsSpecialEventTime = false;
			}

			for (j = 0; j < iTotalMob; j++) 
			{
				cSA = 0;
				if (iFirmSAType == NULL) {
					if (dice(1,100) <= iProbSA) cSA = _cGetSpecialAbility(iKindSA);
				}
				else cSA = (char)iFirmSAType;

				CNpc * minion = CreateNpc(cNpcName, i, cSA, MOVETYPE_RANDOM, &pX, &pY, (Side)-1, 
					cWaypoint, NULL, NULL, false, false, bFirmBerserk);

				if(!minion)
					break;

				minion->Follow( master );
			}
		}
		// random mob generator	^

		// spot mob generator 
		if(!(m_bIsApocalypseMode && m_pMapList[i]->m_iApocalypseMobGenType != AMGT_NONE) && 
			m_pMapList[i]->m_iMaximumObject > m_pMapList[i]->m_iTotalActiveObject)
		{
			for (j = 1; j < MAXSPOTMOBGENERATOR; j++)
			{
				if ( (dice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == true) &&
					(m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) 
				{
					ZeroMemory(cNpcName, sizeof(cNpcName));
					switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) 
					{
					case 10:  strcpy(cNpcName,"Slime");        iProbSA = 5;  iKindSA = 1; break;
					case 16:  strcpy(cNpcName,"Giant-Ant");    iProbSA = 10; iKindSA = 2; break;
					case 14:  strcpy(cNpcName,"Orc");          iProbSA = 15; iKindSA = 1; break;
					case 18:  strcpy(cNpcName,"Zombie");       iProbSA = 15; iKindSA = 3; break;
					case 11:  strcpy(cNpcName,"Skeleton");     iProbSA = 35; iKindSA = 8; break;
					case 6:   strcpy(cNpcName,"Orc-Mage");     iProbSA = 30; iKindSA = 7; break;
					case 17:  strcpy(cNpcName,"Scorpion");     iProbSA = 15; iKindSA = 3; break;
					case 12:  strcpy(cNpcName,"Stone-Golem");  iProbSA = 25; iKindSA = 5; break;
					case 13:  strcpy(cNpcName,"Cyclops");      iProbSA = 35; iKindSA = 8; break;
					case 22:  strcpy(cNpcName,"Amphis");       iProbSA = 20; iKindSA = 3; break;
					case 23:  strcpy(cNpcName,"Clay-Golem");   iProbSA = 20; iKindSA = 5; break;
					case 24:  strcpy(cNpcName,"Guard-Aresden");iProbSA = 20; iKindSA = 1; break;
					case 25:  strcpy(cNpcName,"Guard-Elvine"); iProbSA = 20; iKindSA = 1; break;
					case 26:  strcpy(cNpcName,"Guard-Neutral");iProbSA = 20; iKindSA = 1; break;
					case 27:  strcpy(cNpcName,"Hellbound");    iProbSA = 20; iKindSA = 1; break;
					case 28:  strcpy(cNpcName,"Troll");			 iProbSA = 20; iKindSA = 1; break;
					case 29:  strcpy(cNpcName,"Orge");         iProbSA = 20; iKindSA = 1; break;
					case 30:  strcpy(cNpcName,"Liche");        iProbSA = 30; iKindSA = 8; break;
					case 31:  strcpy(cNpcName,"Demon");        iProbSA = 20; iKindSA = 8; break;
					case 32:  strcpy(cNpcName,"Unicorn");      iProbSA = 35; iKindSA = 7; break;
					case 33:  strcpy(cNpcName,"WereWolf");     iProbSA = 25; iKindSA = 1; break;
					case 34:  strcpy(cNpcName,"Dummy");        iProbSA = 5;  iKindSA = 1; break;
					case 35:  strcpy(cNpcName,"Attack-Dummy"); iProbSA = 5;  iKindSA = 1; break;
					case 48:  strcpy(cNpcName,"Stalker");      iProbSA = 20; iKindSA = 3; break;
					case 49:  strcpy(cNpcName,"Hellclaw");	   iProbSA = 20; iKindSA = 8; break;
					case 50:  strcpy(cNpcName,"Tigerworm");    iProbSA = 20; iKindSA = 8; break;
					case 52:  strcpy(cNpcName,"Gagoyle");     iProbSA = 20; iKindSA = 8; break;
					case 53:  strcpy(cNpcName,"Beholder");      iProbSA = 20; iKindSA = 8; break;
					case 54:  strcpy(cNpcName,"Dark-Elf");      iProbSA = 20; iKindSA = 8; break;
					case 57:   strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2; break;
					case 58:   strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1; break;
					case 59:   strcpy(cNpcName,"Ettin");			iProbSA = 20; iKindSA = 8; break;
					case 60:   strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5; break;
					case 61:   strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1; break;
					case 62:   strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1; break;
					case 63:   strcpy(cNpcName,"Frost");			iProbSA = 20; iKindSA = 8; break;
					case 65:   strcpy(cNpcName,"Ice-Golem");		iProbSA = 20; iKindSA = 8; break;
					case 66:   strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 10; break;
					case 55:   strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1; break;
					case 67:   strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1; break;
					case 68:   strcpy(cNpcName,"Perry");			iProbSA = 20; iKindSA = 1; break;
					case 69:   strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1; break;
					case 73:   strcpy(cNpcName,"Fire-Wyvern");		iProbSA = 20; iKindSA = 10;  break;
					case 70:   strcpy(cNpcName,"Barlog");			iProbSA = 20; iKindSA = 1;  break;
					case 80:   strcpy(cNpcName,"Tentocle");			iProbSA = 20; iKindSA = 1;  break;
					case 71:   strcpy(cNpcName,"Centaurus");			iProbSA = 20; iKindSA = 1;  break;
					case 75:   strcpy(cNpcName,"Giant-Lizard");		iProbSA = 20; iKindSA = 1;  break;
					case 78:   strcpy(cNpcName,"Minotaurs");			iProbSA = 20; iKindSA = 1;  break;
					case 81:   strcpy(cNpcName,"Abaddon");			iProbSA = 20; iKindSA = 10;  break;
					case 72:   strcpy(cNpcName,"Claw-Turtle");		iProbSA = 20; iKindSA = 1;  break;
					case 74:   strcpy(cNpcName,"Giant-Crayfish");	iProbSA = 20; iKindSA = 1;  break;
					case 76:   strcpy(cNpcName,"Giant-Plant");		iProbSA = 20; iKindSA = 1;  break;
					case 77:   strcpy(cNpcName,"MasterMage-Orc");	iProbSA = 20; iKindSA = 1;  break;
					case 79:   strcpy(cNpcName,"Nizie");				iProbSA = 20; iKindSA = 1; break;
					case 82:   strcpy(cNpcName,"Guard-Istria"); iProbSA = 20; iKindSA = 1; break;
					default:
						strcpy(cNpcName, "Orc");
						iProbSA = 15; 
						iKindSA = 1; 
						break;
					}

					bFirmBerserk = false;
					if ((m_pMapList[i]->m_cRandomMobGeneratorLevel >= 9) &&(iMapLevel >= 4) && (dice(1,3) == 1)  ) bFirmBerserk = true;

					cSA = 0;
					if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (dice(1,100) <= iProbSA)) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) 
					{
					case 1:
						// RANDOMAREA
						if(CreateNpc(cNpcName, i, cSA, MOVETYPE_RANDOMAREA, &pX, &pY, (Side)-1, 
							cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, false, false, bFirmBerserk)) 
						{
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
						}
						break;

					case 2:
						// RANDOMWAYPOINT
						if(CreateNpc(cNpcName, i, cSA, MOVETYPE_RANDOMWAYPOINT, NULL, NULL, (Side)-1, 
							m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, false, false, bFirmBerserk)) 
						{
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
						}
						break;
					}
				}
			}
		}
		// spot mob generator ^
	}
}

void CGame::DeleteNpc(int iNpcH)
{
	int  i, iNumItem, iItemID, iItemIDs[MAX_NPCITEMDROP], iSlateID;
	char cItemName[21];
	class CItem * pItem, * pItem2;
	uint32 dwCount, dwTime;
   Point ItemPositions[MAX_NPCITEMDROP];
	char cTemp[256];
	SYSTEMTIME SysTime;

	CNpcPtr npc(m_pNpcList[iNpcH]);

	dwTime = timeGetTime();

	//Init number of items to 1 unless its a multidrop;
	iNumItem = 0;
	iItemID = 0; // No current item

	SendEventToNearClient_TypeA(iNpcH, OWNERTYPE_NPC, MSGID_MOTION_EVENT_REJECT, NULL, NULL, NULL);
	m_pMapList[npc->m_cMapIndex]->ClearOwner(/*11,*/ iNpcH, OWNERTYPE_NPC, npc->m_sX, npc->m_sY);

	m_pMapList[npc->m_cMapIndex]->m_iTotalActiveObject--;

	if(m_pMapList[npc->m_cMapIndex]->m_bIsApocalypseMap)
	{
		if(npc->m_sType == m_pMapList[npc->m_cMapIndex]->m_iApocalypseBossMobNpcID)
		{
			RegisterDelayEvent(DELAYEVENTTYPE_END_APOCALYPSE, 0, timeGetTime() + 5 _m, 
				0, 0, npc->m_cMapIndex, 0, 0, 0, 0, 0);
			// open gate back to town
			if (m_pMapList[npc->m_cMapIndex] != NULL) 
			{	
				m_pMapList[npc->m_cMapIndex]->m_cDynamicGateType = 4;

				int iShortCutIndex = 0;
				while(int i = m_iClientShortCut[iShortCutIndex++])
				{
					Notify_ApocalypseGateState(i);		
				} 
			}	
		}
		else if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject == 0) 
		{	
			if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == AMGT_OPENGATE)
			{	
				int iShortCutIndex = 0;
				while(int i = m_iClientShortCut[iShortCutIndex++])
				{
					Notify_ApocalypseGateState(i);		
				} 
			}
			else if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType == AMGT_SPAWNBOSS)
			{	
				GenerateApocalypseBoss(m_pNpcList[iNpcH]->m_cMapIndex);
			}	
		}
	}


	if ( npc->m_iSpotMobIndex != NULL )
		m_pMapList[npc->m_cMapIndex]->m_stSpotMobGenerator[npc->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, OWNERTYPE_NPC);

	switch (npc->m_sType) 
	{
	case NPC_AGT:
	case NPC_CGT:
	case NPC_MS:
	case NPC_DT:
	case NPC_MANASTONE:
		m_pMapList[npc->m_cMapIndex]->bRemoveCrusadeStructureInfo(npc->m_sX, npc->m_sY);

		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == npc->m_iGuildGUID) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				m_pGuildTeleportLoc[i].m_iV2--;
				if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
				break;
			}
		}
		break;

	case NPC_LWB:
	case NPC_GHK:
	case NPC_GHKABS:
	case NPC_TK:
	case NPC_BG:
	case NPC_CP:
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == npc->m_iGuildGUID) {
				m_pGuildTeleportLoc[i].m_iNumSummonNpc--;
				if (m_pGuildTeleportLoc[i].m_iNumSummonNpc < 0) m_pGuildTeleportLoc[i].m_iNumSummonNpc = 0;
				break;
			}
		}
		break;

	case NPC_CROPS:
		m_pMapList[npc->m_cMapIndex]->bRemoveCropsTotalSum();
		break;
	}


	RemoveFromDelayEventList(iNpcH, OWNERTYPE_NPC, NULL);
	
	m_pNpcList[iNpcH] = NULL;

#ifdef NO_SECONDDROP
	return;
#endif

	if (npc->m_bIsSummoned) 
		return;

	pItem = new CItem;
	ZeroMemory(cItemName, sizeof(cItemName));

	if(drops.HasSecondaryDrop(npc.get()))
	{
		if(drops.GetSecDropNum(npc->m_sType) == 1)
			iItemID = drops.Roll(npc.get(), ONNPCDELETE);
		else
			iNumItem = RollMultiple( npc.get(),ITEMSPREAD_FIXED, 4, iItemIDs, ItemPositions);
	}

	dwCount = 1;


	if (iNumItem > 0) {
		GetLocalTime(&SysTime);
		wsprintf(cTemp, "%d%02d%", SysTime.wMonth, SysTime.wDay);
		for(int j = 0; j < iNumItem; j++){
			if (pItem == NULL) {
				pItem = new class CItem;
			}
			if (pItem->InitItemAttr(iItemIDs[j]) == false ||
				m_pMapList[ npc->m_cMapIndex ]->bGetIsMoveAllowedTile(ItemPositions[j].x, ItemPositions[j].y) == false) {
					delete pItem;
					pItem = NULL;
			}
			else {
				if (iItemIDs[j] == ITEM_GOLD)
				{			
					if(npc->dwGoldDropValue <= 4) pItem->m_dwCount = dice(1, npc->dwGoldDropValue);
					else
						switch(dice(1,2))
					{
						case 1:
							pItem->m_dwCount = (uint32)(npc->dwGoldDropValue + dice(1, npc->dwGoldDropValue/5));
							break;

						case 2:
							pItem->m_dwCount = (uint32)(npc->dwGoldDropValue - dice(1, npc->dwGoldDropValue/5));
							break;
					}
				}
				else
					pItem->m_dwCount = dwCount;

				pItem->m_sTouchEffectType   = ITET_ID;
				pItem->m_sTouchEffectValue1 = dice(1,100000);
				pItem->m_sTouchEffectValue2 = dice(1,100000);
				pItem->m_sTouchEffectValue3 = (short)dwTime;
				if(!m_pMapList[ npc->m_cMapIndex ]->bSetItem(
					ItemPositions[j].x, ItemPositions[j].y, pItem))
				{
					delete pItem;
				}
				else
				{
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
						ItemPositions[j].x, ItemPositions[j].y,	pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					_bItemLog(ITEMLOG_NEWGENDROP, NULL, npc->m_cNpcName, pItem);
					AddGroundItem(pItem, ItemPositions[j].x, ItemPositions[j].y, npc->m_cMapIndex, TILECLEANTIMEPLAYER);
				}
				pItem = NULL;
			}
		}
	}
	else{
		if (iItemID == 0 && npc->dwGoldDropValue > 0 && dice(1,50) == 13) {
			iItemID = ITEM_GOLD;
			if(npc->dwGoldDropValue <= 4) dwCount = dice(1, npc->dwGoldDropValue);
			else
				switch(dice(1,2))
			{
				case 1:
					dwCount = (uint32)(npc->dwGoldDropValue + dice(1, npc->dwGoldDropValue/5));
					break;

				case 2:
					dwCount = (uint32)(npc->dwGoldDropValue - dice(1, npc->dwGoldDropValue/5));
					break;
			}
		}
		if (pItem->InitItemAttr(iItemID) == false) {
			delete pItem;
			pItem = NULL;
		}
		else {

			pItem->m_dwCount = dwCount;

			pItem->m_sTouchEffectType   = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
#ifdef LOGTIME
			pItem->m_sTouchEffectValue3 = dwTime;
#else 
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			//			wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
			wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);

			pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif
			if(!m_pMapList[ npc->m_cMapIndex ]->bSetItem(
				npc->m_sX, npc->m_sY, pItem))
			{
				delete pItem;
			}
			else
			{					
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
					npc->m_sX, npc->m_sY,
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 

				_bItemLog(ITEMLOG_NEWGENDROP, 0, npc->m_cNpcName, pItem);
				AddGroundItem(pItem, npc->m_sX, npc->m_sY, npc->m_cMapIndex, TILECLEANTIMEPLAYER);
			}
			pItem = NULL;
		}
	}

	if (dice(1, 100000) < 60) {
		pItem2 = new class CItem;
		switch(dice(1,4)){
		case 1:	iSlateID = 868; break;
		case 2: iSlateID = 869; break;
		case 3: iSlateID = 870; break;
		case 4: iSlateID = 871; break;
		}
		if (pItem2->InitItemAttr(iSlateID) == false) {
			delete pItem2;
			pItem2 = NULL;
		}
		else {
			pItem2->m_dwCount = 1;

			pItem2->m_sTouchEffectType   = ITET_ID;
			pItem2->m_sTouchEffectValue1 = dice(1,100000);
			pItem2->m_sTouchEffectValue2 = dice(1,100000);
			pItem2->m_sTouchEffectValue3 = (short)dwTime;

			if(!m_pMapList[ npc->m_cMapIndex ]->bSetItem(
				npc->m_sX, npc->m_sY, pItem2))
			{
				delete pItem2;
			}
			else
			{
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
					npc->m_sX, npc->m_sY, pItem2->m_sSprite, pItem2->m_sSpriteFrame, pItem2->m_cItemColor);
				_bItemLog(ITEMLOG_NEWGENDROP, NULL, npc->m_cNpcName, pItem2);
				AddGroundItem(pItem, npc->m_sX, npc->m_sY, npc->m_cMapIndex, TILECLEANTIMEPLAYER);
			}
			pItem2 = NULL;
		}
	}
}

void CGame::RequestFullObjectData(int iClientH, char *pData, int objectID)
{
	uint32 * dwp;
	uint16  * wp, wObjectID;
	char cData[100];
	short * sp, sX, sY;
	int   * ip, iRet;
	UnitStatus temp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if(objectID == -1){
		wp = (uint16 *)(pData + INDEX2_MSGTYPE);
		wObjectID = *wp;
	}else
		wObjectID = (uint16) objectID;

	char * cp = cData;
	Push(cp, Msgid(MSGID_MOTION_STOP));
	
	if(wObjectID < 10000)
	{
		sprintf(g_cTxt, "RFOD: Player(%u)", uint32(wObjectID));
		PutLogList(g_cTxt);

		if(wObjectID == 0 || wObjectID >= MAXCLIENTS)
			return;

		CClient * object = m_pClientList[wObjectID];
		if(!object)
			return;

		Push(cp, wObjectID);
		Push(cp, (uint16)object->m_sX);
		Push(cp, (uint16)object->m_sY);
		Push(cp, (uint16)object->m_sType);
		Push(cp, (uint8)object->m_cDir);
		Push(cp, object->m_cCharName);
		Push(cp, (uint16)object->m_sAppr1);
		Push(cp, (uint16)object->m_sAppr2);
		Push(cp, (uint16)object->m_sAppr3);
		Push(cp, (uint16)object->m_sAppr4);
		Push(cp, (uint32)object->m_iApprColor);

		temp = object->m_iStatus;
		if(_bGetIsPlayerHostile(iClientH,wObjectID) && wObjectID != iClientH && m_pClientList[iClientH]->m_iAdminUserLevel == 0)
			temp &= STATUS_ENEMYFLAGS;

		Push(cp, temp);
		Push(cp, uint8(object->m_bIsKilled ? true : false));

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, cp - cData); 
	}
	else 
	{
		sprintf(g_cTxt, "RFOD: Npc(%u)", uint32(wObjectID));
		
		wObjectID -= 10000;
		if(wObjectID == 0 || wObjectID >= MAXNPCS) return;

		CNpc * object = m_pNpcList[wObjectID];
		if(!object) 
			return;
		
		Push(cp, uint16(wObjectID + 10000));
		Push(cp, (uint16)object->m_sX);
		Push(cp, (uint16)object->m_sY);
		Push(cp, (uint16)object->m_sType);
		Push(cp, (uint8)object->m_cDir);
		Push(cp, (uint16)object->m_sAppr2);
		
		Push(cp, object->m_iStatus);
		Push(cp, uint8(object->m_bIsKilled ? true : false));

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, cp - cData); 
	}

	switch (iRet)
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == ITEMTYPE_ARROW) &&
				(m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
				return i;
		}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, bool bIsUseItemResult, bool bIsLog, bool notify)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ((bIsLog == true) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_CONSUME) 
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_EAT) 
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_USE_DEPLETE) 
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_USE_DEPLETE_DEST)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != ITEMTYPE_MATERIAL)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != ITEM_ICESTORMMANUAL)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != ITEM_MASSFIRESTRIKEMANUAL)
		&& (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum != ITEM_BLOODYSHOCKWMANUAL))
		_bItemLog(ITEMLOG_DEPLETE, iClientH,(int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	ReleaseItemHandler(iClientH, sItemIndex, true);

	if(notify)
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);


	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

	// !!! BUG POINT

	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	iCalcTotalWeight(iClientH);
}

void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
	int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
	uint32 dwTime, dwGUID;
	short sTemp, sTmpType, sTmpAppr1;
	bool depleteItem = true;
	dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;

	CItem *& item = m_pClientList[iClientH]->m_pItemList[sItemIndex];
	if(!item ||	item->m_disabled) return;

	if ((item->m_cItemType == ITEMTYPE_USE_DEPLETE) ||
		(item->m_cItemType == ITEMTYPE_USE_PERM) ||
		(item->m_cItemType == ITEMTYPE_ARROW) || 
		(item->m_cItemType == ITEMTYPE_EAT) ||
		(item->m_cItemType == ITEMTYPE_USE_SKILL) ||
		(item->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST) ) {
	}
	else return;

	if ( (item->m_cItemType == ITEMTYPE_USE_DEPLETE) ||
		(item->m_cItemType == ITEMTYPE_EAT) ) {


		switch (item->m_sItemEffectType) {
		case ITEMEFFECTTYPE_WARM: 


			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_ICE ] == 1) {
				//	SetStatusFlag(iClientH, OWNERTYPE_PLAYER, false);

				RemoveFromDelayEventList(iClientH, OWNERTYPE_PLAYER, MAGICTYPE_ICE);

				RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_ICE, dwTime + (1*1000), 
					iClientH, OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

				//				SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_ICE, NULL, NULL, NULL);
			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case ITEMEFFECTTYPE_LOTTERY:

			iTemp = dice(1, item->m_sItemSpecEffectValue1);
			if (iTemp == dice(1, item->m_sItemSpecEffectValue1)) {

			}
			else {

			}
			break;

		case ITEMEFFECTTYPE_SLATES:
			if (item->m_sIDnum == ITEM_ANCIENTTABLET) {
				if (m_astoria.get() && m_pClientList[iClientH]->m_cMapIndex == m_iAstoriaMapIndex) return;
				switch (item->m_sItemSpecEffectValue2){
				case 2: // Berserk slate
					if(m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ])
						RemoveFromDelayEventList(iClientH, OWNERTYPE_PLAYER, MAGICTYPE_BERSERK);

					m_pClientList[iClientH]->m_cMagicEffectStatus[ MAGICTYPE_BERSERK ] = true;
					m_pClientList[iClientH]->SetStatusFlag(STATUS_BERSERK, true);
					RegisterDelayEvent(DELAYEVENTTYPE_MAGICRELEASE, MAGICTYPE_BERSERK, dwTime + (1000 * 600),
						iClientH, OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
					SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTON, MAGICTYPE_BERSERK, 1, NULL, NULL);
					break;

				case 1: // Invincible slate
				case 3: // Mana slate
				case 4: // Exp slate
					SetSlateFlag(iClientH, item->m_sItemSpecEffectValue2, true);
					RegisterDelayEvent(DELAYEVENTTYPE_ANCIENT_TABLET, item->m_sItemSpecEffectValue2, 
						dwTime + (1000 * 600), iClientH, OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
					switch(item->m_sItemSpecEffectValue2) {
					case 1:	iEffectResult = 4;	break;
					case 3:	iEffectResult = 5;	break;
					case 4:	iEffectResult = 6;	break;
					}
				}
			}
			break;

		case ITEMEFFECTTYPE_HP:
			iMax = m_pClientList[iClientH]->GetMaxHP();
			if (m_pClientList[iClientH]->m_iHP < iMax) {
				if (item->m_sItemSpecEffectValue1 == 0) {
					iV1 = item->m_sItemEffectValue1;
					iV2 = item->m_sItemEffectValue2;
					iV3 = item->m_sItemEffectValue3;
				}
				else {
					iV1 = item->m_sItemSpecEffectValue1;
					iV2 = item->m_sItemSpecEffectValue2;
					iV3 = item->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (dice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case ITEMEFFECTTYPE_MP:
			iMax = m_pClientList[iClientH]->GetMaxMP();
			if (m_pClientList[iClientH]->m_iMP < iMax) {

				if (item->m_sItemSpecEffectValue1 == 0) {
					iV1 = item->m_sItemEffectValue1;
					iV2 = item->m_sItemEffectValue2;
					iV3 = item->m_sItemEffectValue3;
				}
				else 
				{
					iV1 = item->m_sItemSpecEffectValue1;
					iV2 = item->m_sItemSpecEffectValue2;
					iV3 = item->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (dice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;

		case ITEMEFFECTTYPE_SP:
			iMax = m_pClientList[iClientH]->GetMaxSP();

			if (m_pClientList[iClientH]->m_iSP < iMax) {

				if (item->m_sItemSpecEffectValue1 == 0) {
					iV1 = item->m_sItemEffectValue1;
					iV2 = item->m_sItemEffectValue2;
					iV3 = item->m_sItemEffectValue3;
				}
				else {
					iV1 = item->m_sItemSpecEffectValue1;
					iV2 = item->m_sItemSpecEffectValue2;
					iV3 = item->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (dice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned == true) {

				m_pClientList[iClientH]->m_bIsPoisoned = false;

				m_pClientList[iClientH]->SetStatusFlag(STATUS_POISON, false);
				SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_POISON, NULL, NULL, NULL);
			}
			break;

		case ITEMEFFECTTYPE_HPSTOCK:
			iV1 = item->m_sItemEffectValue1;
			iV2 = item->m_sItemEffectValue2;
			iV3 = item->m_sItemEffectValue3;

			m_pClientList[iClientH]->m_iHPstock += dice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			m_pClientList[iClientH]->m_iHungerStatus += dice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;
			
		case ITEMEFFECTTYPE_STUDYSKILL:
			iV1 = item->m_sItemEffectValue1;
			iV2 = item->m_sItemEffectValue2;
			iSEV1 = item->m_sItemSpecEffectValue1;

			if (iSEV1 == 0) {
				TrainSkillResponse(true, iClientH, iV1, iV2);
			}
			else {
				TrainSkillResponse(true, iClientH, iV1, iSEV1);
			}
			break;

		case ITEMEFFECTTYPE_VARIABLEADD:
			VariableAdd(m_pClientList[iClientH], item);
			break;

		case ITEMEFFECTTYPE_STUDYMAGIC:

			iV1 = item->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != NULL) {
				depleteItem = RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, false);
			}
			break;

		case ITEMEFFECTTYPE_MAGIC:
			m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

			switch (item->m_sItemEffectValue1) {
			case 1:
				RequestTeleportHandler(iClientH, 1);
				break;

			case 2:
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, true);
				break;

			case 3:
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, true);
				break;

			case 4:

				switch (item->m_sItemEffectValue2) {
				case 1:
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						ItemDepleteHandler(iClientH, sItemIndex, true);
						RequestTeleportHandler(iClientH, 3, "bisle");
					}
					break;

				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:

					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);

					if ((item->m_sTouchEffectValue1 != SysTime.wMonth) |
						(item->m_sTouchEffectValue2 != SysTime.wDay) ||
						(item->m_sTouchEffectValue3 <= SysTime.wHour) ) {

					}
					else {
						char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", item->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							ItemDepleteHandler(iClientH, sItemIndex, true);

							RequestTeleportHandler(iClientH, 3, cDestMapName);
						}
					}
					break;
				}
				break;
		
			case 5: // Heldenians scroll must be defined as ITEMTYPE_USE_PERM
					// Only Helnenian scrolls can be defined as ITEMTYPE_USE_PERM 
					// Scrolls not belonging to the user are depleted when entering function 
				if (   (m_bHeldenianMode)
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) 
					&& (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == true)
					&& (strcmp(m_pClientList[iClientH]->m_cMapName, "GodH") != 0))
				{	memcpy(&dwGUID, &item->m_sItemSpecEffectValue1, 4);					
					if (item->m_sTouchEffectType == ITET_UNIQUE_OWNER)
					{	if (dwGUID == m_dwHeldenianGUID)
						{	// Scrolls from current Heldenian can summon
							if (item->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, true,
									item->m_sItemEffectValue2); 
							else 
								PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, true,
									item->m_sItemEffectValue2 * -1); 
							m_pClientList[iClientH]->m_iWarContribution   += 300;
							if (m_pClientList[iClientH]->m_iWarContribution > MAXWARCONTRIBUTION)
								m_pClientList[iClientH]->m_iWarContribution = MAXWARCONTRIBUTION;
							if (m_pClientList[iClientH]->m_iWarContribution >= 256*128)
								SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, (m_pClientList[iClientH]->m_iWarContribution %(256*128)), 1, NULL);
						}
						// But older scrolls will be depleted without effect!
						ItemDepleteHandler(iClientH, sItemIndex, true);	
					}else
					{	// Not personal scrolls can summon and deplete scroll now
						if (item->m_sItemEffectValue6 == -1)// -1 allows using with weapon shield equiped
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, true,
							item->m_sItemEffectValue2); 
						else 
						PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, true,
							item->m_sItemEffectValue2 * -1); 
						ItemDepleteHandler(iClientH, sItemIndex, true);	
						return;
					}
				}else // No permanent scroll outside Special Heldenian summon scrolls
				{	if (!m_bHeldenianMode) ItemDepleteHandler(iClientH, sItemIndex, true);	
					return;	
				}
			}
			break;

		case 20:
			if (m_pClientList[iClientH] == NULL) return;

			m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGICRES] = 20;
			SendNotifyMsg(NULL, iClientH, NOTIFY_SKILL, 3, m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC], NULL, NULL);
			break;

		case ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStamina += item->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStamina > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStamina = 20*30; 
			break;

		case ITEMEFFECTTYPE_CHANGEATTR:
			switch (item->m_sItemEffectValue1) {
			case 1:
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:

				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;

				if (m_pClientList[iClientH]->m_cSex == MALE)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == FEMALE) sTemp = 4; 

				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
			break;

			case 4:
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {

					if (m_pClientList[iClientH]->m_cSex == MALE) 
						m_pClientList[iClientH]->m_cSex = FEMALE;
					else m_pClientList[iClientH]->m_cSex = MALE;


					if (m_pClientList[iClientH]->m_cSex == MALE) {
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == FEMALE) {
						sTmpType = 4; 
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
					//
				}
				break;

			case 5: 
				m_pClientList[iClientH]->m_cUnderwear++;
				if (m_pClientList[iClientH]->m_cUnderwear > 7) m_pClientList[iClientH]->m_cUnderwear = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;
			}

			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
			break;
		}

		if (depleteItem)
			ItemDepleteHandler(iClientH, sItemIndex, true);
		else //Re-enable item on client
			SendNotifyMsg(NULL, iClientH, NOTIFY_SETITEMCOUNT, sItemIndex, g_clientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount, true, NULL);

		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(NULL, iClientH, NOTIFY_HP, NULL, NULL, NULL, NULL);
			break;
		case 2:
			SendNotifyMsg(NULL, iClientH, NOTIFY_MP, NULL, NULL, NULL, NULL);
			break;
		case 3:
			SendNotifyMsg(NULL, iClientH, NOTIFY_SP, NULL, NULL, NULL, NULL);
			break;
		case 4: // Invincible
			SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_INVINCIBLE, NULL, NULL, NULL, NULL);
			break;
		case 5: // Mana
			SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_MANA, NULL, NULL, NULL, NULL);
			break;
		case 6: // EXP
			SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_EXP, NULL, NULL, NULL, NULL);
			break;
		default:
			break;
		}
	}
	else if (item->m_cItemType == ITEMTYPE_USE_DEPLETE_DEST) {

		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == true) 
			ItemDepleteHandler(iClientH, sItemIndex, true); 
	}
	else if (item->m_cItemType == ITEMTYPE_ARROW) {
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (item->m_cItemType == ITEMTYPE_USE_PERM) {
		switch (item->m_sItemEffectType)
		{
		case ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = item->m_sItemEffectValue1;
			switch (iV1) 
			{
			case 1:
				if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN]) == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE]) == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL]) == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 9, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 10, NULL, NULL);
				else 
					SendNotifyMsg(NULL, iClientH, NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
				break;
			}
			break;
		}
	}
	else if (item->m_cItemType == ITEMTYPE_USE_SKILL) {
		if ((item->m_wCurLifeSpan <= 0) ||
			(m_pClientList[iClientH]->m_bSkillUsingStatus[ item->m_sRelatedSkill ] == true) ) {
				return;
		}
		else {
			if ( item->m_wMaxLifeSpan != 0 ) {
				item->m_wCurLifeSpan--;
				if (item->m_wCurLifeSpan <= 0) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMLIFESPANEND, EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				}
				else {
					int iSkillUsingTimeID = (int)timeGetTime();

					RegisterDelayEvent(DELAYEVENTTYPE_USEITEM_SKILL, item->m_sRelatedSkill, 
						dwTime + m_pSkillConfigList[ item->m_sRelatedSkill ]->m_sValue2*1000, 
						iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
						m_pClientList[iClientH]->m_cSkillMastery[ item->m_sRelatedSkill ], iSkillUsingTimeID, NULL);

					m_pClientList[iClientH]->m_bSkillUsingStatus[ item->m_sRelatedSkill ] = true;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ item->m_sRelatedSkill ] = iSkillUsingTimeID;
				}
			}
		}
	}
}


void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, 
	short sV1, short sV2, short sV3, bool bExp, Element element, CMagic * spell)
{
	int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
	char cAttackerSide, cDamageMoveDir;
	uint32 dwTime;
	double dTmp1, dTmp2, dTmp3;
	short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY;

	if (cAttackerType == OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();

	iDamage = dice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;
	
	CParty * party = NULL;

	switch (cAttackerType)
	{
	case OWNERTYPE_PLAYER:
		party = m_pClientList[sAttackerH]->GetParty();

		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->GetMag() <= 0)
			dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->GetMag();

		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		if (m_pClientList[sAttackerH]->m_heroArmourBonus == 2) iDamage += 4;

		if (cTargetType == OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_RHAND] != -1 &&
				m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_RHAND] ] != NULL) {
					iTemp = m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_RHAND] ]->m_sIDnum;
					if ((iTemp == ITEM_KLONESSWAND_MS20 || iTemp == ITEM_KLONESSWAND_MS10) &&
						m_pClientList[sAttackerH]->m_reputation > m_pClientList[sTargetH]->m_reputation)
					{
						iTemp = (m_pClientList[sAttackerH]->m_reputation - m_pClientList[sTargetH]->m_reputation) /18;
						iDamage += iTemp > 25 ? 25 : iTemp;
					}
			}

			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_NECK] != -1 &&
				m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_NECK] ] != NULL) {
					iTemp = m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_NECK] ]->m_sIDnum;
					if ((iTemp == ITEM_NECKLACEOFKLONESS) &&
						m_pClientList[sAttackerH]->m_reputation > m_pClientList[sTargetH]->m_reputation)
					{
						iTemp = (m_pClientList[sAttackerH]->m_reputation - m_pClientList[sTargetH]->m_reputation) /22;
						iDamage += iTemp > 15 ? 15 : iTemp;
					}
			}
		}

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		if(m_pClientList[sAttackerH]->HasPartyRaidBonus())
			iDamage += 2;
		iDamage += iDamage * m_pClientList[sAttackerH]->m_addMagicDmgPct/100;

		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == true) 
			iDamage += iDamage/3;

		if ((cTargetType == OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == true) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;

			} else iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_side;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		break;

	case OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_side;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == true) return;

#ifdef SAMESIDETOWNPROTECT

		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_side == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return ;
#endif 
#ifdef BEGINNERTOWNPROTECT
		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == true) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return;
#endif
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > RAGPROTECTIONTIME) return;

		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == false) return;

		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == true) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		if (m_pClientList[sTargetH]->GetParty() && party == m_pClientList[sTargetH]->GetParty()) return;

		if ((m_pClientList[sTargetH]->m_iStatus & STATUS_REDSLATE) != 0) return;

		if (cAttackerType == OWNERTYPE_PLAYER) {

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == true) {
				iSideCondition = m_pClientList[sAttackerH]->GetPlayerRelationship(sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == true) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);

		switch(element) 
		{
		case ELEMENT_EARTH:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case ELEMENT_AIR:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case ELEMENT_FIRE:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case ELEMENT_WATER:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < MAXITEMS))
		{
			float abspct = 0.0f;

			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum)
			{
			case ITEM_RUBYRING:
				abspct = 0.1f;
				break;

			case ITEM_EMERALDRING:
				abspct = 0.2f;
				break;
			}

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage*abspct) {
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage*abspct;
			}

			iDamage *= 1.0f - abspct;
			if (iDamage <= 0) iDamage = 0;
		}


		if (m_pClientList[sTargetH]->GetEffectiveMA() != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->GetEffectiveMA();
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}


		if (cTargetType == OWNERTYPE_PLAYER) {
			iDamage -= (dice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == true) && 
			(dice(1,10) < 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
				iDamage = 1;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= PFMABSORBVAL;


		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == true)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		m_pClientList[sTargetH]->m_lastDamageTime = dwTime;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			g_clientList[sTargetH]->KilledHandler( sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {

				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;


					iTemp = (2*m_pClientList[sTargetH]->GetMag()) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->GetInt()/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}


				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (dice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;

						SendNotifyMsg(NULL, sTargetH, NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}

				SendNotifyMsg(NULL, sTargetH, NOTIFY_HP, NULL, NULL, NULL, NULL);

				SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_PLAYER, MSGID_MOTION_DAMAGE, iDamage, NULL, NULL);


				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(/*0,*/ sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {

					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

					m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode || 
			(cAttackerType == OWNERTYPE_NPC && m_pNpcList[sAttackerH]->IsHighlyTrained()) ||
			m_pNpcList[sTargetH]->m_sType == NPC_AS) &&
			(cAttackerSide == m_pNpcList[sTargetH]->m_side)) 
		{
			return;
		}

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		
		if(m_pNpcList[sTargetH]->m_cSize == 2 && spell)
		{
			uint32 factor = spell->m_vRange * spell->m_hRange;
			if(factor > 3*3)
				factor = 3*3;
			iDamage *= factor;
		}

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 6: 
		return;

		case 4: 			
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == false) {
				cDamageMoveDir = dice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == false) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(/*5,*/ sTargetH, OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_MOTION_MOVE, NULL, NULL, NULL);

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == false) {

				cDamageMoveDir = dice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == false) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(/*5,*/ sTargetH, OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_MOTION_MOVE, NULL, NULL, NULL);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == true) {
				DeleteNpc(sTargetH);
			}
			return;
		}

		if (cAttackerType == OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if (m_pClientList[sAttackerH]->IsNeutral() || (m_pNpcList[sTargetH]->m_side == m_pClientList[sAttackerH]->m_side)) return;
				break;
			}
		}

		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= PFMABSORBVAL;

		m_pNpcList[sTargetH]->ReduceHP( iDamage );

		if (m_pNpcList[sTargetH]->m_iHP <= 0) {

			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {

			switch (cAttackerType) {
			case OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_side == cAttackerSide)) return ;
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side) return;
				break;
			}

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_MOTION_DAMAGE, iDamage, NULL, NULL);

			if ((dice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side)) return;


				m_pNpcList[sTargetH]->m_cBehavior          = BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;


				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {

					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_NPC, MAGICTYPE_HOLDOBJECT);
				}

				// Crusade
				int iExp;

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) && 
					(cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {

						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							// Crusade
							iExp = iDamage;
							if ((m_bIsCrusadeMode == true) && (iExp > 10)) iExp = 10;



							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}


							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == true) 
								GetExp(sAttackerH, iExp, true); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
							else GetExp(sAttackerH, (iExp/2), true); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						}
						else {
							// Crusade
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							if ((m_bIsCrusadeMode == true) && (iExp > 10)) iExp = 10;


							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}


							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == true) 
								GetExp(sAttackerH, iExp, true); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							else GetExp(sAttackerH, (iExp/2), true); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType,
	short sAtkX, short sAtkY, short sV1, short sV2, short sV3, bool bExp, Element element, CMagic * spell)
{
	int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
	uint32 dwTime;
	char cAttackerSide, cDamageMoveDir;
	double dTmp1, dTmp2, dTmp3;
	int iMoveDamage;
	short sTgtX, sTgtY;

	Unit *attacker = NULL, *target = NULL;
	if(cAttackerType == OWNERTYPE_PLAYER)
		attacker = m_pClientList[sAttackerH];
	else if(cAttackerType == OWNERTYPE_NPC)
		attacker = m_pNpcList[sAttackerH];

	if(cTargetType == OWNERTYPE_PLAYER)
		target = m_pClientList[sTargetH];
	else if(cTargetType == OWNERTYPE_NPC)
		target = m_pNpcList[sTargetH];

	if(!attacker || !target || target->IsDead() ) return;

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;

	iDamage = dice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	CParty * party = NULL;

	switch (cAttackerType)
	{
	case OWNERTYPE_PLAYER:
		party = m_pClientList[sAttackerH]->GetParty();

		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->GetMag() <= 0)
			dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->GetMag();

		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;

		if (m_pClientList[sAttackerH]->m_heroArmourBonus == 2) iDamage += 4;

		if (target->IsPlayer()) {
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_RHAND] != -1 &&
				m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_RHAND] ] != NULL) {
					iTemp = m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_RHAND] ]->m_sIDnum;
					if ((iTemp == ITEM_KLONESSWAND_MS20 || iTemp == ITEM_KLONESSWAND_MS10) &&
						m_pClientList[sAttackerH]->m_reputation > m_pClientList[sTargetH]->m_reputation)
					{
						iTemp = (m_pClientList[sAttackerH]->m_reputation - m_pClientList[sTargetH]->m_reputation) /18;
						iDamage += iTemp > 15 ? 15 : iTemp;
					}
			}
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_NECK] != -1 &&
				m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_NECK] ] != NULL) {
					iTemp = m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[EQUIPPOS_NECK] ]->m_sIDnum;
					if ((iTemp == ITEM_NECKLACEOFKLONESS) &&
						m_pClientList[sAttackerH]->m_reputation > m_pClientList[sTargetH]->m_reputation)
					{
						iTemp = (m_pClientList[sAttackerH]->m_reputation / 20);
						iDamage += iTemp > 5 ? 5 : iTemp;
					}
			}
		}

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		if(m_pClientList[sAttackerH]->HasPartyRaidBonus())
			iDamage += 2;
		iDamage += iDamage * m_pClientList[sAttackerH]->m_addMagicDmgPct/100;


		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == true) 
			iDamage += iDamage/3;


		if ((cTargetType == OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == true) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{

			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;
			} else iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_side;
		break;

	case OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_side;
		break;
	}

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > RAGPROTECTIONTIME) return;


		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == false) return;

		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == true) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

#ifdef SAMESIDETOWNPROTECT

		if ((m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_side == cAttackerSide) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return ;
#endif 
#ifdef BEGINNERTOWNPROTECT
		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == true) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_iIsOnTown == NONPK)) return;
#endif

		if (m_pClientList[sTargetH]->GetParty() && party == m_pClientList[sTargetH]->GetParty()) return;

		if ((m_pClientList[sTargetH]->m_iStatus & STATUS_REDSLATE) != 0) return;

		if (cAttackerType == OWNERTYPE_PLAYER) {

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == true) {
				iSideCondition = m_pClientList[sAttackerH]->GetPlayerRelationship(sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == true) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);

		switch(element) 
		{
		case ELEMENT_EARTH:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case ELEMENT_AIR:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case ELEMENT_FIRE:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case ELEMENT_WATER:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex >= 0) && (iIndex < MAXITEMS)) {

			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case ITEM_EMERALDRING:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;

			case ITEM_RUBYRING:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}


		if (m_pClientList[sTargetH]->GetEffectiveMA() != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->GetEffectiveMA();
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}


		if (cTargetType == OWNERTYPE_PLAYER) {
			iDamage -= (dice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= PFMABSORBVAL;

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == true) && 
			(dice(1,10) < 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
				iDamage = 1;
		}


		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == true)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		m_pClientList[sTargetH]->m_lastDamageTime = dwTime;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			g_clientList[sTargetH]->KilledHandler( sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {


				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;


					iTemp = (2*m_pClientList[sTargetH]->GetMag()) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->GetInt()/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}


				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (dice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;

						SendNotifyMsg(NULL, sTargetH, NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}


				if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == true)) 
					iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {

					///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;
					}


					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					SendNotifyMsg(NULL, sTargetH, NOTIFY_HP, NULL, NULL, NULL, NULL);

					SendNotifyMsg(NULL, sTargetH, NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}
				else {
EDSD_SKIPDAMAGEMOVE:;
					SendNotifyMsg(NULL, sTargetH, NOTIFY_HP, NULL, NULL, NULL, NULL);

					SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_PLAYER, MSGID_MOTION_DAMAGE, iDamage, NULL, NULL);
				}

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(/*0,*/ sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

					m_pClientList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case OWNERTYPE_NPC:
		if ((m_bIsCrusadeMode || 
			(cAttackerType == OWNERTYPE_NPC && m_pNpcList[sAttackerH]->IsHighlyTrained()) ||
			m_pNpcList[sTargetH]->m_sType == NPC_AS) &&
			(cAttackerSide == m_pNpcList[sTargetH]->m_side)) 
		{
			return;
		}

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 6: 
		return;
		}
		
		if(m_pNpcList[sTargetH]->m_cSize == 2 && spell)
		{
			uint32 factor = spell->m_vRange * spell->m_hRange;
			if(factor > 3*3)
				factor = 3*3;
			iDamage *= factor;
		}

		if (cAttackerType == OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_side == 0) || (m_pNpcList[sTargetH]->m_side == m_pClientList[sAttackerH]->m_side)) return;
				break;
			}
		}

		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == MAGICPROTECT_PFM)
			iDamage *= PFMABSORBVAL;

		m_pNpcList[sTargetH]->ReduceHP( iDamage );

		if (m_pNpcList[sTargetH]->m_iHP <= 0) {

			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {

			switch (cAttackerType) {
			case OWNERTYPE_PLAYER:

				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_side == cAttackerSide)) return;
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side) return;
			break;
			}

			SendEventToNearClient_TypeA(sTargetH, OWNERTYPE_NPC, MSGID_MOTION_DAMAGE, iDamage, NULL, NULL);

			if ((dice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				if ((cAttackerType == OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_side == m_pNpcList[sTargetH]->m_side)) return;


				m_pNpcList[sTargetH]->m_cBehavior          = BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;



				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {

					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(sTargetH, OWNERTYPE_NPC, MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				int iExp;


				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) && 
					(cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							// Crusade
							iExp = iDamage;
							if ((m_bIsCrusadeMode == true) && (iExp > 10)) iExp = 10;

							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == true) 
								GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
							else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						}
						else {
							// Crusade
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							if ((m_bIsCrusadeMode == true) && (iExp > 10)) iExp = 10;


							if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}


							if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
								switch (m_pNpcList[sTargetH]->m_sType) {
								case 55:
								case 56:
									iExp = 0 ;
									break ;
								default: break;
								}
							}

							if (bExp == true) 
								GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}
				}
			}
		}
		break;
	}

	if(attacker->IsNPC() && g_npcList[sAttackerH]->m_cSpecialAbility == 2 && target->m_cMagicEffectStatus[MAGICTYPE_PROTECT])
	{
		if(target->IsPlayer())
		{
			g_clientList[sTargetH]->Notify(NULL, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_PROTECT, target->m_cMagicEffectStatus[MAGICTYPE_PROTECT], NULL, NULL);
		}

		switch(target->m_cMagicEffectStatus[MAGICTYPE_PROTECT]) 
		{
		case MAGICPROTECT_PFA:
			target->SetStatusFlag(STATUS_PFA, false);
			break;
		case MAGICPROTECT_PFM:
		case MAGICPROTECT_AMP:
			target->SetStatusFlag(STATUS_PFM, false);
			break;
		case MAGICPROTECT_DS:
		case MAGICPROTECT_GDS:
			target->SetStatusFlag(STATUS_DEFENSESHIELD, false);
			break;
		}

		target->m_cMagicEffectStatus[MAGICTYPE_PROTECT] = NULL;
		RemoveFromDelayEventList(target, MAGICTYPE_PROTECT);	
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iHP, iMaxHP;

	if (cAttackerType == OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	iHP = dice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == true) return;

		m_pClientList[sTargetH]->AddHP(iHP);
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == true) return;

		if(m_pNpcList[sTargetH]->m_sType == NPC_AS)
			iHP *= 2;

		m_pNpcList[sTargetH]->AddHP(iHP);
		}
	}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iSP, iMaxSP, iSideCondition;

	if (cAttackerType == OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	iSP = dice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == true) return;

		// Is the user having an invincibility slate
		if ((m_pClientList[sTargetH]->m_iStatus & STATUS_REDSLATE) != 0) return;


		if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {

			if (m_pClientList[sTargetH]->GetParty()  && m_pClientList[sAttackerH]->GetParty() == m_pClientList[sTargetH]->GetParty()) return;

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == true) {
				iSideCondition = m_pClientList[sAttackerH]->GetPlayerRelationship(sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				}
				else {

					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == true) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}
		}

		iMaxSP = m_pClientList[sTargetH]->GetMaxSP();
		if (m_pClientList[sTargetH]->m_iSP > 0) {
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStamina == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(NULL, sTargetH, NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
		}
		break;

	case OWNERTYPE_NPC:

		break;
	}
}

bool CGame::bSetItemToBankItem(int iClientH, CItem * pItem)
{
	uint32 * dwp;
	uint16  * wp;
	char  * cp;
	short * sp;
	char cData[100];		   

	if (m_pClientList[iClientH] == NULL) return false;
	if (pItem == NULL) return false;

	if (m_pClientList[iClientH]->m_bIsOnWarehouse == false) return false;

	for(int i = 0; i < MAXBANKITEMS; i++)
	{
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {

			m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;

			dwp  = (uint32 *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_ITEMTOBANK;

			cp = (char *)(cData + INDEX2_MSGTYPE + 2);

			*cp = i; 
			cp++;

			WriteItemData(cp, pItem);

			sp = (short *)cp;
			*sp = pItem->m_sItemEffectValue2;
			cp += 2;

			dwp = (uint32 *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			*cp = (char) pItem->m_sItemSpecEffectValue2 ;
			cp ++ ;

			for(int i = 0; i < MAXITEMSOCKETS; i++)
			{
				Push(cp, pItem->m_sockets[i]);
			}
			int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 56 + MAXITEMSOCKETS);

#ifdef TAIWANLOG
			_bItemLog(ITEMLOG_DEPOSIT, iClientH, (int) -1, pItem);
#endif

			m_pClientList[iClientH]->m_bIsBankModified = true ;

			return true;
		}
	}
	
	return false;
}

void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = true;
		break;
	case VK_F4:
		m_bF4pressed = true;
		break;
	case VK_F12:
		m_bF12pressed = true;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
	int i;
	switch (wParam) {
	case VK_F2:

		/*
		char cTxt[120];
		for (i = 1; i <= 200; i++){
		wsprintf(cTxt, "Level %d:  Exp %d", i, iGetLevelExp(i));
		PutLogFileList(cTxt);
		}

		if (m_bOnExitProcess == false) {
		m_cShutDownCode      = 3;
		m_bOnExitProcess     = true;
		m_dwExitProcessTime  = timeGetTime();

		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost Emulation)!!!");
		}
		*/
		break;

	case VK_F1:
		m_bF1pressed = false;
		break;
	case VK_F4:
		m_bF4pressed = false;
		break;
	case VK_F12:
		m_bF12pressed = false;
		break;

	case VK_F6:
		if (m_bF1pressed == true) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
					SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
				}
		}
		break;

	case VK_F7:
		if (m_bF1pressed == true) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
					SendNotifyMsg(NULL, i, NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
				}
		}
		break;

	case VK_F9:
		if (m_bF1pressed == true) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(NULL);
		}
		break;

	case VK_F11:
		if (m_bF1pressed == true) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;
	case VK_HOME:
		if (m_bF1pressed == true) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_END:
		//LocalEndCrusadeMode();
		break;

	case VK_INSERT:
		//_GrandMagicLaunchMsgSend(1, 1);
		//MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		//_GrandMagicLaunchMsgSend(1, 2);
		//MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
	int i, iTotal;

	iTotal = 0;

	for (i = 1; i < MAXNPCS; i++) 
		if ( (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == MOVETYPE_FOLLOW) ) {

			if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
				iTotal++;
		}

	return iTotal;
}

bool CGame::RegisterDelayEvent(int iDelayType, int iEffectType, uint32 dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
	int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] == NULL) {

			m_pDelayEventList[i] = new class CDelayEvent;

			m_pDelayEventList[i]->m_iDelayType = iDelayType;
			m_pDelayEventList[i]->m_iEffectType = iEffectType;

			m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
			m_pDelayEventList[i]->m_dX = dX;
			m_pDelayEventList[i]->m_dY = dY;

			m_pDelayEventList[i]->m_iTargetH    = iTargetH;
			m_pDelayEventList[i]->m_cTargetType = cTargetType;
			m_pDelayEventList[i]->m_iV1         = iV1;
			m_pDelayEventList[i]->m_iV2         = iV2;
			m_pDelayEventList[i]->m_iV3         = iV3; 

			m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;

			return true;
		}

		return false;
}

bool CGame::RegisterDelayEvent(int iDelayType, int iEffectType, uint32 dwLastTime, Unit * unit, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
	int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] == NULL) {

			m_pDelayEventList[i] = new class CDelayEvent;

			m_pDelayEventList[i]->m_iDelayType = iDelayType;
			m_pDelayEventList[i]->m_iEffectType = iEffectType;

			m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
			m_pDelayEventList[i]->m_dX = dX;
			m_pDelayEventList[i]->m_dY = dY;

			m_pDelayEventList[i]->m_iTargetH    = unit->m_handle;
			m_pDelayEventList[i]->m_cTargetType = unit->m_ownerType;
			m_pDelayEventList[i]->m_iV1         = iV1;
			m_pDelayEventList[i]->m_iV2         = iV2;
			m_pDelayEventList[i]->m_iV3         = iV3; 

			m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;

			return true;
		}

		return false;
}

void CGame::DelayEventProcessor()
{
	int i, iSkillNum, iResult;
	uint32 dwTime = timeGetTime();
	int iTemp;
	Unit * unit = NULL;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

			switch (m_pDelayEventList[i]->m_iDelayType) 
			{

			case DELAYEVENTTYPE_ANCIENT_TABLET:
				if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & STATUS_REDSLATE) != 0) {
					iTemp = 1;
				}
				else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & STATUS_BLUESLATE) != 0) {
					iTemp = 3;
				}
				else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & STATUS_GREENSLATE) != 0) {
					iTemp = 4;
				}

				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, NOTIFY_SLATE_STATUS, iTemp, NULL, NULL, NULL);
				SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, false);
				break;

			case DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
				CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
				DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DELAYEVENTTYPE_METEORSTRIKE:
				MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DELAYEVENTTYPE_USEITEM_SKILL:

				switch (m_pDelayEventList[i]->m_cTargetType) 
				{
				case OWNERTYPE_PLAYER:
					iSkillNum = m_pDelayEventList[i]->m_iEffectType;

					if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
					if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == false ) break;
					if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;

					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = false;
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;

					iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
						m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

					SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
					break;
				}
				break;
		case DELAYEVENTTYPE_KILL_ABADDON:
			NpcKilledHandler(m_pDelayEventList[i]->m_iTargetH, OWNERTYPE_NPC, m_pDelayEventList[i]->m_iTargetH, 0);
			break;

		case DELAYEVENTTYPE_END_APOCALYPSE:
			GlobalEndApocalypseMode(0);	
			break;
			case DELAYEVENTTYPE_DAMAGEOBJECT:
				break;

			case DELAYEVENTTYPE_MAGICRELEASE:
				if(m_pDelayEventList[i]->m_cTargetType == OWNERTYPE_PLAYER) 
					unit = m_pClientList[ m_pDelayEventList[i]->m_iTargetH ];
				else if(m_pDelayEventList[i]->m_cTargetType == OWNERTYPE_NPC) 
					unit = m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ];

				if(!unit) break;

				unit->RemoveMagicEffect(m_pDelayEventList[i]->m_iEffectType);
				break;
			}

			delete m_pDelayEventList[i];
			m_pDelayEventList[i] = NULL;
		}
}

bool CGame::RemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
	int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] != NULL) {

			if (iEffectType == NULL) {

				if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = NULL;
				}
			}
			else {
				if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
					(m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
						delete m_pDelayEventList[i];
						m_pDelayEventList[i] = NULL;
				}
			}
		}

	return true;
}

bool CGame::RemoveFromDelayEventList(Unit * unit, int iEffectType)
{
	int i;

	for (i = 0; i < MAXDELAYEVENTS; i++) 
		if (m_pDelayEventList[i] != NULL) {

			if (iEffectType == NULL) {

				if ( (m_pDelayEventList[i]->m_iTargetH == unit->m_handle) && (m_pDelayEventList[i]->m_cTargetType == unit->m_ownerType) ) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = NULL;
				}
			}
			else {
				if ( (m_pDelayEventList[i]->m_iTargetH == unit->m_handle) && (m_pDelayEventList[i]->m_cTargetType == unit->m_ownerType) &&
					(m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
						delete m_pDelayEventList[i];
						m_pDelayEventList[i] = NULL;
				}
			}
		}

	return true;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{
	char  * cp, cData[30];
	uint32 * dwp;
	uint16  * wp;
	short * sp;
	int     iRet;

	if(!m_pClientList[iClientH]) return;
	if(m_pClientList[iClientH]->m_rejectedMove) return;

	m_pClientList[iClientH]->m_rejectedMove = true;
	m_pClientList[iClientH]->m_resetMoveFreq = true; 
	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOTION_REJECT;

	cp   = (char *)(cData + INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
	int i, iTotal;

	iTotal = 0;
	for (i = 1; i < MAXCLIENTS; i++) 
		if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
	int i, ix, iy, iIndex;
	short sOwnerH, iDamage, sType;
	char  cOwnerType;
	uint32 dwTime = timeGetTime(), dwRegisterTime;

	HashMap<CNpc*, uint32> npcPendingDmgMap;
	HashMap<CNpc*, uint32>::iterator it;

	for (i = 0; i < MAXDYNAMICOBJECTS; i++) 
		if (m_pDynamicObjectList[i] != NULL) {
			switch (m_pDynamicObjectList[i]->m_sType) {
		case DYNAMICOBJECT_PCLOUD_BEGIN:

			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
				for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {

						switch (cOwnerType) {
						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if (m_pClientList[sOwnerH]->m_bIsKilled == true) break;

							if(m_pClientList[sOwnerH]->IsInvincible()) break ;


							//if ((m_pClientList[sOwnerH]->m_bIsNeutral == true) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

							if (m_pDynamicObjectList[i]->m_iV1 < 20)
								iDamage = dice(1,6);
							else iDamage = dice(1,8);

							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;
							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);

									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
										// 1: Hold-Person 
										// 2: Paralize
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
										RemoveFromDelayEventList(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
									}
								}


								if ( (CheckResistingMagicSuccess(1, sOwnerH, OWNERTYPE_PLAYER, 100) == false) &&
									(m_pClientList[sOwnerH]->m_bIsPoisoned == false) ) {

										m_pClientList[sOwnerH]->m_bIsPoisoned  = true;
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;

										m_pClientList[sOwnerH]->SetStatusFlag(STATUS_POISON, true);
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTON, MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
#ifdef TAIWANLOG
										_bItemLog(ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
#endif
								}
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;

							if (m_pDynamicObjectList[i]->m_iV1 < 20)
								iDamage = dice(1,6);
							else iDamage = dice(1,8);

							switch (m_pNpcList[sOwnerH]->m_sType) {
							case 40:
							case 41:
							case 6: 
							case 5: // Crusade structures
							case 8: // Heldenian gate.
								iDamage = 0;
								break;
							}

							m_pNpcList[sOwnerH]->ReduceHP( iDamage );

							if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
								NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); 
							}
							else {
								if (dice(1,3) == 2)
									m_pNpcList[sOwnerH]->m_dwTime = dwTime;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
								}

								npcPendingDmgMap[ m_pNpcList[sOwnerH] ] += iDamage;
							}
							break;
						}
					}
				}
				break;

		case DYNAMICOBJECT_ICESTORM:

			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
				for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {

						switch (cOwnerType) {
						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if (m_pClientList[sOwnerH]->m_bIsKilled == true) break;

							if(m_pClientList[sOwnerH]->IsInvincible()) break  ;

							//if ((m_pClientList[sOwnerH]->m_bIsNeutral == true) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

							iDamage = dice(3,3) + 5;
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);

									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] == 1) {

										// 1: Hold-Person 
										// 2: Paralize
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
										RemoveFromDelayEventList(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
									}
								}


								if (!checkResistingIceSuccess(1, sOwnerH, OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1))
									m_pClientList[sOwnerH]->AddMagicEffect(MAGICTYPE_ICE, g_magicConfigList[MAGIC_ICESTORM]->m_sValue[MAGICV_ICEDURATION]);
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;

							iDamage = dice(3,3) + 5;

							switch (m_pNpcList[sOwnerH]->m_sType)
							{
							case 40:
							case 41:
							case 6: 
								iDamage = 0;
								break;
							}

							m_pNpcList[sOwnerH]->ReduceHP( iDamage );

							if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
								NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); 
							}
							else {
								if (dice(1,3) == 2)
									m_pNpcList[sOwnerH]->m_dwTime = dwTime;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
								}
								
								npcPendingDmgMap[ m_pNpcList[sOwnerH] ] += iDamage;

								if (!checkResistingIceSuccess(1, sOwnerH, OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1))
									m_pNpcList[sOwnerH]->AddMagicEffect(g_magicConfigList[MAGIC_ICESTORM]->m_sType, g_magicConfigList[MAGIC_ICESTORM]->m_sValue[MAGICV_ICEDURATION]);
							}
							break;
						}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							iDamage = dice(3,2);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);
								}
							}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
					if ((sType == DYNAMICOBJECT_FIRE) && (m_pDynamicObjectList[iIndex] != NULL)) 
						m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
				}
				break;

		case DYNAMICOBJECT_FIRE:

			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
				for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {

						switch (cOwnerType) {

						case OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) break;
							if (m_pClientList[sOwnerH]->m_bIsKilled == true) break;

							if(m_pClientList[sOwnerH]->IsInvincible()) break  ;


							//if ((m_pClientList[sOwnerH]->m_bIsNeutral == true) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

							iDamage = dice(1,6);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;
							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);

									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
										// 1: Hold-Person 
										// 2: Paralize
										SendNotifyMsg(NULL, sOwnerH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
										RemoveFromDelayEventList(sOwnerH, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
									}
								}
							}
							break;

						case OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) break;
							iDamage = dice(1,6);
							switch (m_pNpcList[sOwnerH]->m_sType) {
							case 40:
							case 41:
							case 6: 
								iDamage = 0;
								break;
							}

							m_pNpcList[sOwnerH]->ReduceHP( iDamage );

							if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
								NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); 
							}
							else {
								if (dice(1,3) == 2)
									m_pNpcList[sOwnerH]->m_dwTime = dwTime;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
								}
								
								npcPendingDmgMap[ m_pNpcList[sOwnerH] ] += iDamage;
							}
							break;
						}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ( (cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {

							iDamage = dice(1,6);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
							m_pClientList[sOwnerH]->m_lastDamageTime = dwTime;
							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								m_pClientList[sOwnerH]->KilledHandler(sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(NULL, sOwnerH, NOTIFY_HP, NULL, NULL, NULL, NULL);
								}
							}
					}

					m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
					if ((sType == DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
						m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
				}
				break;
			}
		}

	for(it = npcPendingDmgMap.begin();
		it != npcPendingDmgMap.end();
		++it)
	{
		SendEventToNearClient_TypeA( it->first->m_handle, OWNERTYPE_NPC, MSGID_MOTION_DAMAGE, it->second, 0, NULL);
	}
}

void CGame::ClearSkillUsingStatus(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	//m_pClientList[iClientH]->m_hasPrecasted = false;
	for (i = 0; i < MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = false;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL;
	}

	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}
}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
	class CItem * pItem;
	short lX, lY;
	int   iResult, iFish, iItemID = 0 ;

	switch (cOwnerType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	if (cOwnerSkill == 0) return 0;

	iResult = dice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == false) return 0;

	if (cOwnerType == OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case SKILLEFFECTTYPE_TAMING:
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;

	case SKILLEFFECTTYPE_GET: 

		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:

			iItemID = 99 ;  
			break;

		case 2:

			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == false) return 0; 

			if (cOwnerType == OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
				if (iFish == NULL) iItemID = 100 ; 
			} else iItemID = 100 ; 
			break;
			}

			if (iItemID != 0) {


				if (iItemID == 100) {
					SendNotifyMsg(NULL, iOwnerH, NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);


					GetExp(iOwnerH, dice(2,5)); //m_pClientList[iOwnerH]->m_iExpStock += dice(1,2);
				}

				pItem = new class CItem;
				if (pItem == NULL) return 0;
				if (pItem->InitItemAttr(iItemID) == true) {


					pItem->m_sTouchEffectType   = ITET_ID;
					pItem->m_sTouchEffectValue1 = dice(1,100000);
					pItem->m_sTouchEffectValue2 = dice(1,100000);

					pItem->m_sTouchEffectValue3 = (short) timeGetTime();


					m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);


					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, cMapIndex,
						lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
				}
			}
		break;

	}
	return 1;
}


void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
	char  cOwnerType;
	short sAttackerWeapon, sOwnerH;
	int   iResult, iPlayerSkillLevel;
	uint32 dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((iV1 < 0) || (iV1 >= MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == true) return;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;


	/*
	if (iV1 != 19) {
	m_pClientList[iClientH]->m_iAbuseCount++;
	if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
	wsprintf(g_cTxt, "(!)  (%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName, 
	iV1, m_pClientList[iClientH]->m_iAbuseCount);
	PutLogFileList(g_cTxt);
	}
	}
	*/

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = dice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pSkillConfigList[iV1]->m_sType) {
	case SKILLEFFECTTYPE_PRETEND:
		if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iClientH])
			return;
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:

			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == true) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {

				SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);

			CalculateSSN_SkillIndex(iClientH, iV1, 1);

			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_DYING, 0, sAttackerWeapon, NULL);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*14,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
			}
		break;

	}
	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = true;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
	char cItemCategory;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	bool   bNeutral;
	uint32  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;	
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item) return;
	if (iNum <= 0) return;
	if (item->m_dwCount < iNum) return;

	iCalcTotalWeight(iClientH);


	bNeutral = false;
	if (m_pClientList[iClientH]->IsNeutral()) bNeutral = true;


	switch (cSellToWhom) {
	case 15: 
	case 24:        
		cItemCategory = item->m_cCategory;

		if ( (cItemCategory >= 1 && cItemCategory <= 10) || 
			item->m_sItemEffectType == ITEMEFFECTTYPE_JEWELRY) 
		{
			sRemainLife = item->m_wCurLifeSpan;

			if(sRemainLife == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, item->m_cName);
			}
			else if(item->m_sIDnum == ITEM_ARROW)
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, item->m_cName);
			} 
			else if ((item->m_sTouchEffectValue1  == m_pClientList[iClientH]->m_sCharIDnum1) && 
				(item->m_sTouchEffectValue2  == m_pClientList[iClientH]->m_sCharIDnum2) &&
				(item->m_sTouchEffectValue2  == m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, item->m_cName);
			} else {
				d1 = (double)sRemainLife;
				if (item->m_wMaxLifeSpan != 0)
					d2 = (double)item->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)item->m_wPrice; 				d3 = d3 * d2; 

				iPrice = (int)d3;
				iPrice = iPrice*iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;

				if ((item->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (item->m_dwAttribute & 0x000F0000) >> 16;



					switch (dwSWEType) {
					case 6: dwMul1 = 2; break;  
					case 8: dwMul1 = 2; break;  
					case 5: dwMul1 = 3; break;  					
					case 1: dwMul1 = 4; break;  					
					case 7: dwMul1 = 5; break;  					
					case 2: dwMul1 = 6; break;  
					case 3: dwMul1 = 15; break; 
					case 9: dwMul1 = 20; break; 
					default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice*dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice1 = (int)(d1 + d3);
				}


				if ((item->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;




					switch (dwSWEType) {
					case 1: 
					case 12: dwMul2 = 2; break;

					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;

					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}

					d1 = (double)iPrice*dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice2 = (int)(d1 + d3);
				}

				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

				if (bNeutral == true) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + m_pGold->GetWeight(iPrice) > _iCalcMaxLoad(iClientH)) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, item->m_cName);
				}
				else SendNotifyMsg(NULL, iClientH, NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, item->m_cName, iNum);
			}
		}
		else 	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {

			iPrice = (item->m_wPrice / 2)*iNum;
			sRemainLife = item->m_wCurLifeSpan;

			if (bNeutral == true) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			if (m_pClientList[iClientH]->m_iCurWeightLoad + m_pGold->GetWeight(iPrice) > _iCalcMaxLoad(iClientH)) {

				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, item->m_cName);
			}
			else SendNotifyMsg(NULL, iClientH, NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, item->m_cName, iNum);
		}
		else SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, item->m_cName);
		break;

	default:
		break;
	}
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
	class CItem * pItemGold;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	char   cItemName[21], cItemCategory;
	uint32  dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
	int    iEraseReq;
	bool   bNeutral;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= MAXITEMS)) return;	
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item || item->m_disabled) return;
	if (iNum <= 0 || item->m_dwCount < iNum) return;

	if (m_pClientList[iClientH]->m_bIsOnShop == false ) return;


	iCalcTotalWeight(iClientH);
	cItemCategory = item->m_cCategory;

	bNeutral = false;
	if (m_pClientList[iClientH]->IsNeutral()) bNeutral = true;

	iPrice = 0;

	if ( (cItemCategory >= 1 && cItemCategory <= 10) || 
		item->m_sItemEffectType == ITEMEFFECTTYPE_JEWELRY) 
	{
		sRemainLife = item->m_wCurLifeSpan;

		if (sRemainLife <= 0) {
			return;
		}
			else if(item->m_sIDnum == ITEM_ARROW)
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, item->m_cName);
			} 
		else {
			d1 = (double)sRemainLife;
			if (item->m_wMaxLifeSpan != 0)
				d2 = (double)item->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)item->m_wPrice; 			d3 = d3 * d2; 

			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;

			if ((item->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (item->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (item->m_dwAttribute & 0x000F0000) >> 16;

				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  
				case 8: dwMul1 = 2; break;  
				case 5: dwMul1 = 3; break;  				
				case 1: dwMul1 = 4; break;  				
				case 7: dwMul1 = 5; break;  				
				case 2: dwMul1 = 6; break;  
				case 3: dwMul1 = 15; break; 
				case 9: dwMul1 = 20; break; 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			if ((item->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;

				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;

				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;

				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}

				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}


			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

			if (bNeutral == true) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(ITEMLOG_SELL, iClientH, (int) -1, item) ;

			if ((item->m_cItemType == ITEMTYPE_CONSUME) ||
				(item->m_cItemType == ITEMTYPE_ARROW)) {

					SetItemCount(iClientH, cItemID, item->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, false, false);
		}
	}
	else 
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
			iPrice = item->m_wPrice/2; 
			iPrice = iPrice*iNum;


			if (bNeutral == true) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;


			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(ITEMLOG_SELL, iClientH, (int) -1, item) ;


			if ((item->m_cItemType == ITEMTYPE_CONSUME) ||
				(item->m_cItemType == ITEMTYPE_ARROW)) {

					SetItemCount(iClientH, cItemID, item->m_dwCount - iNum);
			}

			else ItemDepleteHandler(iClientH, cItemID, false, false);
		}


	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	pItemGold->InitItemAttr(cItemName);

	pItemGold->m_dwCount = iPrice;

	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == true) {

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItemGold, NULL, true);

		if (iEraseReq == 1)	delete pItemGold;
	}
	else {

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); 

		iCalcTotalWeight(iClientH);

		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
	char cItemCategory;
	uint32 remainLife, price;
	double d1, d2, d3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item) return;

	cItemCategory = item->m_cCategory;

	if(cItemCategory >= 1 && cItemCategory <= 10) 
	{
		if (cRepairWhom != 24) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, item->m_cName);
			return;
		}
	}
	else if((cItemCategory >= 43 && cItemCategory <= 50) || (cItemCategory >= 11 && cItemCategory <= 13)) 
	{
		if (cRepairWhom != 15) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, item->m_cName);
			return;
		}
	}
	else
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, item->m_cName);
		return;
	}

	remainLife = item->m_wCurLifeSpan;
	if (remainLife == 0) {
		price = item->m_wPrice / 2;
	}
	else {
		d1 = remainLife;
		if (item->m_wMaxLifeSpan != 0)
			d2 = item->m_wMaxLifeSpan;
		else d2 = 1.0f;
		d3 = (d1 / d2) * 0.5f;
		d2 = item->m_wPrice; 			
		d3 = d3 * d2; 

		price = (item->m_wPrice / 2) - d3;
	}

	SendNotifyMsg(NULL, iClientH, NOTIFY_REPAIRITEMPRICE, cItemID, remainLife, price, item->m_cName);

}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
	uint32    remainLife, price;
	char   * cp, cItemCategory, cData[120];
	double   d1, d2, d3;
	uint32  * dwp, dwGoldCount;
	uint16   * wp;
	int      iRet, iGoldWeight;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	CItem * item = m_pClientList[iClientH]->m_pItemList[cItemID];
	if (!item) return;


	if( m_pClientList[iClientH]->m_bIsOnShop != true ) return ;

	cItemCategory = item->m_cCategory;

	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		((cItemCategory >= 11) && (cItemCategory <= 13))) {

			remainLife = item->m_wCurLifeSpan;
			if (remainLife == 0) {
				price = item->m_wPrice / 2;
			}
			else {
				d1 = remainLife;
				if (item->m_wMaxLifeSpan != 0)
					d2 = item->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)item->m_wPrice; 			
				d3 = d3 * d2; 

				price = (item->m_wPrice / 2) - d3;
			}

			dwGoldCount = dwGetItemCount(iClientH, "Gold");

			if ( dwGoldCount < (uint32)price ) {
				dwp  = (uint32 *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + INDEX2_MSGTYPE + 2);
				*cp  = cItemID;
				cp++;

				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
				return;
				}
				return;
			}
			else {

				item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMREPAIRED, cItemID, item->m_wCurLifeSpan, NULL, NULL);

#ifdef TAIWANLOG
				if (item->m_cName != NULL) 
					_bItemLog(ITEMLOG_REPAIR,iClientH,item->m_cName,NULL) ;
#endif 

				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - price );

				iCalcTotalWeight(iClientH);

				m_stCityStatus[m_pClientList[iClientH]->m_side].iFunds += price;
			}
	}
	else {

	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
	CClient * player = m_pClientList[iClientH];
	if (!player) return 0;

	player->UpdateWeight();

	return player->GetWeight();
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, uint32 dwSize)
{
	char   seps[] = "= \t\n";
	char   * token, * cp, cName[11], cBuff[256], cTemp[120];
	int i;
	uint16 * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		return;
	}

	if (strlen(token) > 10) 
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));


	for (i = 1; i < MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {

				cp = (char * ) cTemp ;
				memcpy(cp, m_pClientList[i]->m_cMapName, 10) ;
				cp += 10 ;

				wp = (uint16 *)cp;
				*wp =(uint16) m_pClientList[i]->m_sX;
				cp += 2;

				wp = (uint16 *)cp;
				*wp = (uint16) m_pClientList[i]->m_sY;
				cp += 2;
			}

			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName, NULL, NULL, NULL, NULL, NULL, NULL, cTemp);

			return;
		}

		//SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDCHARACTER;
		cp++;

		wp = (uint16 *)cp;
		*wp = GSID;
		cp += 2;

		wp = (uint16 *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 25);

}


/*
void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, uint32 dwMsgSize)
{
char   seps[] = "= \t\n";
char   * cp, * token, cName[11], cBuff[256];
class  CStrTok * pStrTok;
uint16   * wp;
int i;

if (m_pClientList[iClientH] == NULL) return;
if (dwMsgSize <= 0) return;

ZeroMemory(cName, sizeof(cName));
ZeroMemory(cBuff, sizeof(cBuff));
memcpy(cBuff, pMsg, dwMsgSize);

pStrTok = new class CStrTok(cBuff, seps);
token = pStrTok->pGet();
token = pStrTok->pGet();

if (token == NULL) {
m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = false;
ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
}
else {
if (strlen(token) > 10)
memcpy(cName, token, 10);
else memcpy(cName, token, strlen(token));

m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
for (i = 1; i < MAXCLIENTS; i++) 
if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

return;
}

m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
break;
}


if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
ZeroMemory(cBuff, sizeof(cBuff));
cp = (char *)cBuff;
*cp = GSM_REQUEST_FINDCHARACTER;
cp++;

wp = (uint16 *)cp;
*wp = GSID;
cp += 2;

wp = (uint16 *)cp;
*wp = iClientH;
cp += 2;

memcpy(cp, cName, 10);
cp += 10;

memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
cp += 10;

bStockMsgToGateServer(cBuff, 25);
m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = true;

ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
}
else SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
return;
}

}*/

void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256];
	int i;
	char *cp;
	uint16 *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = false;
		SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
	}
	else {
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				if (i == iClientH) {
					return;
				}
				m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
				ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
				break;
			}

			if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
				ZeroMemory(cBuff, sizeof(cBuff));
				cp = (char *)cBuff;
				*cp = GSM_REQUEST_FINDCHARACTER;
				cp++;

				wp = (uint16 *)cp;
				*wp = GSID;
				cp += 2;

				wp = (uint16 *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, cName, 10);
				cp += 10;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				bStockMsgToGateServer(cBuff, 25);

				ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
				m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = true;
			}
			else{
				SendNotifyMsg(NULL, iClientH, NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
			}
	}

}

void CGame::SetPlayerProfile(int iClientH, char * pMsg, uint32 dwMsgSize)
{
	char cTemp[256];
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);


	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256], cBuff2[500];
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

				ZeroMemory(cBuff2, sizeof(cBuff2));

				wsprintf(cBuff2, "%s Profile:%s", cName, m_pClientList[i]->m_cProfile); 
				SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

				return;
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	return;
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, bool bNotify)
{
	short sItemIndex;
	int  i, iArrowIndex, iPrevSAType;
	double dV1, dV2, dV3;
	uint32  dwSWEType, dwSWEValue;
	float bonusDmg, RepDamage;
	short  sTemp;

	CClient * player = m_pClientList[iClientH];

	if (!player) return;

	SetAngel(iClientH, OWNERTYPE_PLAYER, 0, false);

	if ( (player->m_sItemEquipmentStatus[EQUIPPOS_RHAND]   != -1) &&
		(player->m_sItemEquipmentStatus[EQUIPPOS_TWOHAND] != -1) ) {

			if (player->m_pItemList[ player->m_sItemEquipmentStatus[EQUIPPOS_RHAND] ] != NULL) {
				player->m_bIsItemEquipped[player->m_sItemEquipmentStatus[EQUIPPOS_RHAND]] = false;
				player->m_sItemEquipmentStatus[EQUIPPOS_RHAND] = -1;
			}
	}

	player->m_cAttackDiceThrow_SM = 0;
	player->m_cAttackDiceRange_SM = 0;
	player->m_cAttackBonus_SM     = 0;  

	player->m_cAttackDiceThrow_L  = 0;
	player->m_cAttackDiceRange_L  = 0;
	player->m_cAttackBonus_L      = 0;

	player->m_iHitRatio = 0;
	player->m_iDefenseRatio = player->GetDex() * 2;
	player->m_iDamageAbsorption_Shield = 0;

	for (i = 0; i < MAXITEMEQUIPPOS; i++)
		player->m_iDamageAbsorption_Armor[i]  = 0;

	player->m_iMPSaveRatio  = 0;
	player->m_iAddResistMagic = 0;

	player->m_iAddPhysicalDamage = 0;
	player->m_iAddMagicalDamage  = 0;
	player->m_addMagicDmgPct = 0;

	player->m_bIsLuckyEffect  = false;
	player->m_iMagicDamageSaveItemIndex = -1;
	player->m_iSideEffect_MaxHPdown = 0;

	player->m_iAddAbsAir   = 0;
	player->m_iAddAbsEarth = 0;
	player->m_iAddAbsFire  = 0;
	player->m_iAddAbsWater = 0;

	player->m_iCustomItemValue_Attack  = 0;
	player->m_iCustomItemValue_Defense = 0;

	player->m_iMinAP_SM = 0;
	player->m_iMinAP_L  = 0;

	player->m_iMaxAP_SM = 0;
	player->m_iMaxAP_L  = 0;

	player->m_iSpecialWeaponEffectType  = 0;		
	player->m_iSpecialWeaponEffectValue = 0;
	player->m_iAddHP = player->m_iAddSP = player->m_iAddMP = 0; 
	player->m_iAddAR = player->m_iAddPR = player->m_iAddDR = 0;
	player->m_iAddMR = player->m_iAddAbsPD = player->m_iAddAbsMD = 0;
	player->m_iAddCD = player->m_iAddExp = player->m_iAddGold = 0;

	player->m_iHPStatic_stock = 0;

	iPrevSAType = player->m_iSpecialAbilityType;

	player->m_iSpecialAbilityType     = 0;
	player->m_specialAbilityLastSec  = 0;
	player->m_iSpecialAbilityEquipPos = 0;

	player->m_iAddTransMana = 0;
	player->m_iAddChargeCritical = 0;

	CItem * item;

	for (sItemIndex = 0; sItemIndex < MAXITEMS; sItemIndex++)
	{
		if((item = player->m_pItemList[sItemIndex]) && 
			player->m_bIsItemEquipped[sItemIndex]) 
		{
			switch (item->m_sItemEffectType)
			{

			case ITEMEFFECTTYPE_MAGICDAMAGESAVE:
				player->m_iMagicDamageSaveItemIndex = sItemIndex;
				break;

			case ITEMEFFECTTYPE_HP:
				player->m_iHPStatic_stock += item->m_sItemEffectValue4 ;
				break; 

			case ITEMEFFECTTYPE_JEWELRY:
				dwSWEType = GetNibble(item->m_dwAttribute, 5);
				if (dwSWEType) 
				{
					dwSWEValue = GetNibble(item->m_dwAttribute, 4);

					switch (dwSWEType) 
					{
					case ITEMSTAT_SHARP: 					
						player->m_cAttackDiceRange_SM++;
						player->m_cAttackDiceRange_L++;
						break;

					case ITEMSTAT_ANCIENT: 
						player->m_cAttackDiceRange_SM += 2;
						player->m_cAttackDiceRange_L  += 2;
						break;


					case ITEMSTAT_MANACONV: 					
						player->m_iAddTransMana += dwSWEValue;
						if (player->m_iAddTransMana > 13) player->m_iAddTransMana = 13;
						break;

					case ITEMSTAT_CRITICAL2: 					
						player->m_iAddChargeCritical += dwSWEValue;
						if (player->m_iAddChargeCritical > 20) player->m_iAddChargeCritical = 20;
						break;
					}
				}


				dwSWEType = GetNibble(item->m_dwAttribute, 3);
				if (dwSWEType)
				{
					dwSWEValue = GetNibble(item->m_dwAttribute, 2); 

					switch (dwSWEType) 
					{
					case 0:  break;
					case 1:  player->m_iAddPR += (int)dwSWEValue*7; break;
					case 2:  player->m_iAddAR += (int)dwSWEValue*7; break;
					case 3:  player->m_iAddDR += (int)dwSWEValue*7; break;
					case 4:  player->m_iAddHP += (int)dwSWEValue*7; break;
					case 5:  player->m_iAddSP += (int)dwSWEValue*7; break;
					case 6:  player->m_iAddMP += (int)dwSWEValue*7; break;
					case 7:  player->m_iAddMR += (int)dwSWEValue*7; break;
					case 8:  player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += (int)dwSWEValue*3; break;
					case 9:  player->m_iAddAbsMD += (int)dwSWEValue*3; break;
					case 10: player->m_iAddCD    += (int)dwSWEValue; break;
					case 11: player->m_iAddExp   += (int)dwSWEValue*10; break;
					case 12: player->m_iAddGold  += (int)dwSWEValue*10; break;
					}
				}
				break;

			case ITEMEFFECTTYPE_ATTACK_SPECABLTY:
			case ITEMEFFECTTYPE_ATTACK_DEFENSE:
			case ITEMEFFECTTYPE_ATTACK_MANASAVE:
			case ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
			case ITEMEFFECTTYPE_ATTACK:
				player->m_cAttackDiceThrow_SM = item->m_sItemEffectValue1;
				player->m_cAttackDiceRange_SM = item->m_sItemEffectValue2;
				player->m_cAttackBonus_SM     = item->m_sItemEffectValue3;
				if(item->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_MANASAVE)
				{	
					player->m_cAttackDiceThrow_L  = player->m_cAttackDiceThrow_SM;
					player->m_cAttackDiceRange_L  = player->m_cAttackDiceRange_SM;
					player->m_cAttackBonus_L      = player->m_cAttackBonus_SM;
				}else{
					player->m_cAttackDiceThrow_L  = item->m_sItemEffectValue4;
					player->m_cAttackDiceRange_L  = item->m_sItemEffectValue5;
					player->m_cAttackBonus_L      = item->m_sItemEffectValue6;
				}

				bonusDmg = (item->m_dwAttribute & 0xF0000000) >> 28;

				player->m_iAddPhysicalDamage += bonusDmg;

				switch(item->m_sIDnum)
				{
				case ITEM_DMMAGICSTAFF: case ITEM_BLACKMAGETEMPLE: case ITEM_DMMAGICWAND:
					player->m_iAddMagicalDamage  += ceil(bonusDmg/2);  break;
				default:
					player->m_iAddMagicalDamage  += bonusDmg;
				}


				player->m_iHitRatio += player->m_cSkillMastery[ item->m_sRelatedSkill ]; 


				//player->m_iHitRatio_ItemEffect_SM += item->m_sSM_HitRatio;
				//player->m_iHitRatio_ItemEffect_L  += item->m_sL_HitRatio;
				player->m_sUsingWeaponSkill = item->m_sRelatedSkill;


				if(item->IsManued())
				{
					player->m_iCustomItemValue_Attack += item->m_sItemSpecEffectValue2;
					if (player->m_iCustomItemValue_Attack > 100)
						player->m_iCustomItemValue_Attack = 100;

					if (player->m_iCustomItemValue_Attack < -100)
						player->m_iCustomItemValue_Attack = -100;

					if (player->m_iCustomItemValue_Attack > 0) {

						dV2 = (double)player->m_iCustomItemValue_Attack;
						dV1 = (dV2/100.0f)*(5.0f);
						player->m_iMinAP_SM = player->m_cAttackDiceThrow_SM + 
							player->m_cAttackBonus_SM + (int)dV1;

						player->m_iMinAP_L  = player->m_cAttackDiceThrow_L + 
							player->m_cAttackBonus_L + (int)dV1;

						if (player->m_iMinAP_SM < 1) player->m_iMinAP_SM = 1;
						if (player->m_iMinAP_L < 1)  player->m_iMinAP_L = 1;


						if (player->m_iMinAP_SM > (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM)) 
							player->m_iMinAP_SM = (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM);

						if (player->m_iMinAP_L > (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L)) 
							player->m_iMinAP_L = (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L);
					}
					else if (player->m_iCustomItemValue_Attack < 0) {
						dV2 = (double)player->m_iCustomItemValue_Attack;
						dV1 = (dV2/100.0f)*(5.0f);
						player->m_iMaxAP_SM = player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM 
							+ player->m_cAttackBonus_SM + (int)dV1;

						player->m_iMaxAP_L  = player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L 
							+ player->m_cAttackBonus_L + (int)dV1;

						if (player->m_iMaxAP_SM < 1) player->m_iMaxAP_SM = 1;
						if (player->m_iMaxAP_L < 1)  player->m_iMaxAP_L = 1;


						if (player->m_iMaxAP_SM < (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM)) 
							player->m_iMaxAP_SM = (player->m_cAttackDiceThrow_SM * player->m_cAttackDiceRange_SM + player->m_cAttackBonus_SM);

						if (player->m_iMaxAP_L < (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L)) 
							player->m_iMaxAP_L = (player->m_cAttackDiceThrow_L * player->m_cAttackDiceRange_L + player->m_cAttackBonus_L);
					}
				}


				if (dwSWEType  = GetNibble(item->m_dwAttribute, 5)) {
					dwSWEValue = GetNibble(item->m_dwAttribute, 4);

					player->m_iSpecialWeaponEffectType  = (int)dwSWEType;
					player->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

					switch (dwSWEType) 
					{
					case ITEMSTAT_SHARP:
						player->m_cAttackDiceRange_SM++;
						player->m_cAttackDiceRange_L++;
						break;

					case ITEMSTAT_ANCIENT:
						player->m_cAttackDiceRange_SM += 2;
						player->m_cAttackDiceRange_L  += 2;
						break;
					}
				}


				if ((item->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;

					switch (dwSWEType) 
					{
					case 0:  break;
					case 1:  player->m_iAddPR += (int)dwSWEValue*7; break;
					case 2:  player->m_iAddAR += (int)dwSWEValue*7; break;
					case 3:  player->m_iAddDR += (int)dwSWEValue*7; break;
					case 4:  player->m_iAddHP += (int)dwSWEValue*7; break;
					case 5:  player->m_iAddSP += (int)dwSWEValue*7; break;
					case 6:  player->m_iAddMP += (int)dwSWEValue*7; break;
					case 7:  player->m_iAddMR += (int)dwSWEValue*7; break;
					case 8:  player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += (int)dwSWEValue*3; break;
					case 9:  player->m_iAddAbsMD += (int)dwSWEValue*3; break;
					case 10: player->m_iAddCD    += (int)dwSWEValue; break;
					case 11: player->m_iAddExp   += (int)dwSWEValue*10; break;
					case 12: player->m_iAddGold  += (int)dwSWEValue*10; break;
					}
				}

				switch (item->m_sItemEffectType) 
				{
				case ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
					player->m_iSideEffect_MaxHPdown = item->m_sSpecialEffect;
					player->m_iAddAR += 70;
					break;

				case ITEMEFFECTTYPE_ATTACK_MANASAVE:
					player->m_iMPSaveRatio    += item->m_sItemEffectValue4;
					if (player->m_iMPSaveRatio > 80) player->m_iMPSaveRatio = 80;
					switch(item->m_sItemEffectValue5)
					{
					case WET_ADDMAGICDMGPCT:
						player->m_addMagicDmgPct += item->m_sItemEffectValue6;
						break;
					}
					break;

				case ITEMEFFECTTYPE_ATTACK_DEFENSE:

					player->m_iDamageAbsorption_Armor[EQUIPPOS_BODY] += item->m_sSpecialEffect;
					break;

				case ITEMEFFECTTYPE_ATTACK_SPECABLTY:

					player->m_iSpecialAbilityType    = item->m_sSpecialEffect;

					player->m_specialAbilityLastSec = item->m_sSpecialEffectValue1; 
					player->m_iSpecialAbilityEquipPos = (int)item->m_cEquipPos;


					if ((bNotify == true) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 2, player->m_iSpecialAbilityType, player->m_iSpecialAbilityTime, NULL);
					break;
				}
				break;

			case ITEMEFFECTTYPE_ADDEFFECT:
				switch (item->m_sItemEffectValue1) 
				{
				case 1:

					player->m_iAddResistMagic += item->m_sItemEffectValue2;
					break;

				case 2:
					player->m_iMPSaveRatio += item->m_sItemEffectValue2;
					if (player->m_iMPSaveRatio > 80) player->m_iMPSaveRatio = 80;
					break;

				case 3:

					player->m_iAddPhysicalDamage += item->m_sItemEffectValue2;
					break;

				case 4:

					player->m_iDefenseRatio += item->m_sItemEffectValue2;
					break;

				case 5:
					if (item->m_sItemEffectValue2 != 0)
						player->m_bIsLuckyEffect = true;
					else player->m_bIsLuckyEffect = false;
					break;

				case 6:

					player->m_iAddMagicalDamage += item->m_sItemEffectValue2;
					break;

				case 7:
					player->m_iAddAbsAir += item->m_sItemEffectValue2;
					break;

				case 8:
					player->m_iAddAbsEarth += item->m_sItemEffectValue2;
					break;

				case 9:
					player->m_iAddAbsFire += item->m_sItemEffectValue2;
					break;

				case 10:
					player->m_iAddAbsWater += item->m_sItemEffectValue2;
					break;

				case 11:
					player->m_iAddPR += item->m_sItemEffectValue2;
					break;

				case 12:
					player->m_iHitRatio += item->m_sItemEffectValue2;
					break;

				case 13: 
					player->m_iAddHP += (item->m_sItemSpecEffectValue2 /5);
					break;

				case 14:
					player->m_iAddAR += (item->m_sItemSpecEffectValue2 /5);
					break;

				case 15:
					player->m_iAddAbsMD += (item->m_sItemSpecEffectValue2 /10);
					break;

				case 20:	
					sTemp = (item->m_sItemSpecEffectValue2 /10);
					player->m_iDamageAbsorption_Armor[EQUIPPOS_HEAD]  += sTemp;
					player->m_iDamageAbsorption_Armor[EQUIPPOS_BODY]  += sTemp;	
					player->m_iDamageAbsorption_Armor[EQUIPPOS_ARMS]  += sTemp;
					player->m_iDamageAbsorption_Armor[EQUIPPOS_PANTS] += sTemp;
					break;	

				case 16: // Angel STR//AngelicPendant(STR)
					player->SetAngelStr(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 1);
					break;
				case 17: // Angel DEX //AngelicPendant(DEX)
					player->SetAngelDex(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 2);
					break;
				case 18: // Angel INT//AngelicPendant(INT)
					player->SetAngelInt(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 3);
					break;
				case 19: // Angel MAG//AngelicPendant(MAG)
					player->SetAngelMag(
						((item->m_dwAttribute & 0xF0000000) >> 28) + 1
						);
					SetAngel(iClientH, OWNERTYPE_PLAYER, 4);
					break;
				}
				break;

			case ITEMEFFECTTYPE_ATTACK_ARROW:
				if ( (player->m_cArrowIndex != -1) && 
					(player->m_pItemList[player->m_cArrowIndex] == NULL) ) {

						player->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
				}
				else if (player->m_cArrowIndex == -1) 
					player->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

				if (player->m_cArrowIndex == -1) {
					player->m_cAttackDiceThrow_SM = 0;
					player->m_cAttackDiceRange_SM = 0;
					player->m_cAttackBonus_SM     = 0;
					player->m_cAttackDiceThrow_L  = 0;
					player->m_cAttackDiceRange_L  = 0;
					player->m_cAttackBonus_L      = 0;
				}
				else {
					iArrowIndex = player->m_cArrowIndex;
					/*
					player->m_cAttackDiceThrow_SM = player->m_pItemList[iArrowIndex]->m_sItemEffectValue1;
					player->m_cAttackDiceRange_SM = player->m_pItemList[iArrowIndex]->m_sItemEffectValue2;
					player->m_cAttackBonus_SM     = player->m_pItemList[iArrowIndex]->m_sItemEffectValue3;
					player->m_cAttackDiceThrow_L  = player->m_pItemList[iArrowIndex]->m_sItemEffectValue4;
					player->m_cAttackDiceRange_L  = player->m_pItemList[iArrowIndex]->m_sItemEffectValue5;
					player->m_cAttackBonus_L      = player->m_pItemList[iArrowIndex]->m_sItemEffectValue6;
					*/

					player->m_cAttackDiceThrow_SM = item->m_sItemEffectValue1;
					player->m_cAttackDiceRange_SM = item->m_sItemEffectValue2;
					player->m_cAttackBonus_SM     = item->m_sItemEffectValue3;
					player->m_cAttackDiceThrow_L  = item->m_sItemEffectValue4;
					player->m_cAttackDiceRange_L  = item->m_sItemEffectValue5;
					player->m_cAttackBonus_L      = item->m_sItemEffectValue6;
				}


				player->m_iHitRatio += player->m_cSkillMastery[ item->m_sRelatedSkill ]; 

				// player->m_iHitRatio_ItemEffect_SM += item->m_sSM_HitRatio;
				// player->m_iHitRatio_ItemEffect_L  += item->m_sL_HitRatio;
				break;

			case ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
			case ITEMEFFECTTYPE_DEFENSE:
				player->m_iDefenseRatio += player->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;

				//player->m_iHitRatio_ItemEffect_SM += item->m_sSM_HitRatio;
				//player->m_iHitRatio_ItemEffect_L  += item->m_sL_HitRatio;


				if(item->IsManued())
				{
					player->m_iCustomItemValue_Defense += item->m_sItemSpecEffectValue2;


					dV2 = (double)item->m_sItemSpecEffectValue2;
					dV3 = (double)player->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
					dV1 = (double)(dV2 / 100.0f)*dV3;

					dV1 = dV1 / 2.0f;
					player->m_iDefenseRatio += (int)dV1;
					if (player->m_iDefenseRatio <= 0) player->m_iDefenseRatio = 1;
				}


				if ((item->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (item->m_dwAttribute & 0x000F0000) >> 16;


					switch (dwSWEType) 
					{
					case ITEMSTAT_SHARP: 					
						player->m_cAttackDiceRange_SM++;
						player->m_cAttackDiceRange_L++;
						break;

					case ITEMSTAT_ANCIENT: 
						player->m_cAttackDiceRange_SM += 2;
						player->m_cAttackDiceRange_L  += 2;
						break;


					case ITEMSTAT_MANACONV: 					
						player->m_iAddTransMana += dwSWEValue;
						if (player->m_iAddTransMana > 13) player->m_iAddTransMana = 13;
						break;

					case ITEMSTAT_CRITICAL2: 					
						player->m_iAddChargeCritical += dwSWEValue;
						if (player->m_iAddChargeCritical > 20) player->m_iAddChargeCritical = 20;
						break;
					}
				}

				if(item->GetMaxSockets() > 0)
				{
					for(i = 0; i < MAXITEMSOCKETS; i++)
					{
						if(item->m_sockets[i] == SG_NONE || item->m_sockets[i] == SG_VORTEXGEM)
							continue;
							
						switch(item->m_sockets[i])
						{
						case SG_REJUGEM7:
							player->m_iAddMP += 7;
							break;
						case SG_REJUGEM14:
							player->m_iAddMP += 14;
							break;
						case SG_REJUGEM21:
							player->m_iAddMP += 21;
							break;
						case SG_BLOODGEM7:
							player->m_iAddHP += 7;
							break;
						case SG_BLOODGEM14:
							player->m_iAddHP += 14;
							break;
						case SG_BLOODGEM21:
							player->m_iAddHP += 21;
							break;
						case SG_MINDGEM7:
							player->m_iAddMR += 7;
							break;
						case SG_MINDGEM14:
							player->m_iAddMR += 14;
							break;
						case SG_MINDGEM21:
							player->m_iAddMR += 21;
							break;
						case SG_ARMORGEM7:
							player->m_iAddDR += 7;
							break;
						case SG_ARMORGEM14:
							player->m_iAddDR += 14;
							break;
						case SG_ARMORGEM21:
							player->m_iAddDR += 21;
							break;
						case SG_ENCHANTEDGEM2:
							player->m_iAddAbsMD += 2;
							break;
						case SG_ENCHANTEDGEM4:
							player->m_iAddAbsMD += 4;
							break;
						case SG_ENCHANTEDGEM6:
							player->m_iAddAbsMD += 6;
							break;
						case SG_TACTICALGEM3:
							player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += 3;
							break;
						case SG_TACTICALGEM5:
							player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += 5;
							break;
						case SG_TACTICALGEM7:
							player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += 7;
							break;
						}
					}
				}

				if ((item->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (item->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (item->m_dwAttribute & 0x00000F00) >> 8;


					switch (dwSWEType) 
					{
					case 0:  break;
					case 1:  player->m_iAddPR += (int)dwSWEValue*7; break;
					case 2:  player->m_iAddAR += (int)dwSWEValue*7; break;
					case 3:  player->m_iAddDR += (int)dwSWEValue*7; break;
					case 4:  player->m_iAddHP += (int)dwSWEValue*7; break;
					case 5:  player->m_iAddSP += (int)dwSWEValue*7; break;
					case 6:  player->m_iAddMP += (int)dwSWEValue*7; break;
					case 7:  player->m_iAddMR += (int)dwSWEValue*7; break;
					case 8:  player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += (int)dwSWEValue*3; break;
					case 9:  player->m_iAddAbsMD += (int)dwSWEValue*3; break;
					case 10: player->m_iAddCD    += (int)dwSWEValue; break;
					case 11: player->m_iAddExp   += (int)dwSWEValue*10; break;
					case 12: player->m_iAddGold  += (int)dwSWEValue*10; break;
					}
				}

				switch(item->m_cEquipPos) 
				{
				case EQUIPPOS_LHAND:
					player->m_iDamageAbsorption_Shield	= item->m_sItemEffectValue2;
					break;
				default:
					player->m_iDamageAbsorption_Armor[item->m_cEquipPos] += item->m_sItemEffectValue2;
					break;
				}

				switch (item->m_sItemEffectType) 
				{
				case ITEMEFFECTTYPE_DEFENSE_SPECABLTY:

					player->m_iSpecialAbilityType = item->m_sSpecialEffect;

					player->m_specialAbilityLastSec = item->m_sSpecialEffectValue1; 
					player->m_iSpecialAbilityEquipPos = (int)item->m_cEquipPos;


					if ((bNotify == true) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 2, player->m_iSpecialAbilityType, player->m_iSpecialAbilityTime, NULL);
					break;
				}
				break;
			}
		}
	}

	if ((iPrevSAType != 0) && (player->m_iSpecialAbilityType == 0) && (bNotify == true)) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		if (player->m_bIsSpecialAbilityEnabled == true) {
			player->m_bIsSpecialAbilityEnabled = false;

			player->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
			sTemp = player->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			player->m_sAppr4 = sTemp;
			SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
		}
	}

	if ((iPrevSAType != 0) && (player->m_iSpecialAbilityType != 0) && 
		(iPrevSAType != player->m_iSpecialAbilityType) && (bNotify == true)) {

			if (player->m_bIsSpecialAbilityEnabled == true) {

				SendNotifyMsg(NULL, i, NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
				player->m_bIsSpecialAbilityEnabled = false;

				player->m_iSpecialAbilityTime = SPECABLTYTIMESEC;
				sTemp = player->m_sAppr4;
				sTemp = sTemp & 0xFF0F;
				player->m_sAppr4 = sTemp;
				SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
			}
	}
	player->m_heroArmourBonus = CheckHeroItemEquipped(iClientH);
}

bool CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, bool bIsCheck)
{
	int   tX, tY;
	short sOwnerH;
	char  cOwnerType, cNpcName[21];
	char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return false;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return false;
	if (m_bIsCrusadeMode == true) return false;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) return false;

	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != true) {
			if (bIsCheck == true) return true;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN]) == 0) 
				strcpy(cNpcName, "Guard-Aresden");
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE]) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL]) == 0) 
				strcpy(cNpcName, "Guard-Neutral");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ISTRIA]) == 0) 
				strcpy(cNpcName, "Guard-Istria");
			else
				return false;

			ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

			tX = (int)m_pClientList[iClientH]->m_sX;
			tY = (int)m_pClientList[iClientH]->m_sY;

			CNpc * guard = CreateNpc(cNpcName, m_pClientList[iClientH]->m_cMapIndex, 0, MOVETYPE_RANDOM, 
				&tX, &tY, (Side)-1, cNpcWaypoint, NULL, NULL, false, true);

			if(guard) 
			{
				guard->SetTarget( m_pClientList[iClientH] );
			}
		}
	}

	return false;
}

bool CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return false;
	if (m_pClientList[sOwnerH]  == NULL) return false;

	if (iClientH == sOwnerH) return true;

	if (m_pClientList[iClientH]->IsNeutral()) {
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			return true;
		else return false;
	}
	else {
		if (m_pClientList[iClientH]->m_side != m_pClientList[sOwnerH]->m_side) {
			return true;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				return true;
			else return false;
		}
	}

	return false;
}

void CGame::PoisonEffect(int iClientH, int iV1)
{
	int iPoisonLevel, iDamage, iPrevHP, iProb;

	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = dice(1, iPoisonLevel);

	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(NULL, iClientH, NOTIFY_HP, NULL, NULL, NULL, NULL);

	iProb = m_pClientList[iClientH]->m_cSkillMastery[SKILL_POISONRES] -10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (dice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = false;
		m_pClientList[iClientH]->SetStatusFlag(STATUS_POISON, false);
		SendNotifyMsg(NULL, iClientH, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}

void CGame::CheckDayOrNightMode()
{
	SYSTEMTIME SysTime;
	char cPrevMode;
	int  i;

	cPrevMode = m_cDayOrNight;

	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= NIGHTTIME) 
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
				if ((m_pClientList[i]->m_cMapIndex >= 0) && 
					(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
					(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == false))
					SendNotifyMsg(NULL, i, NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);
			}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256],* cp;
	uint16 * wp ;
	int i, iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));


		token = pStrTok->pGet();
		if (token == NULL) 
			iTime = 0;
		else iTime = atoi(token);

		if (iTime < 0) iTime = 0;

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {


				m_pClientList[i]->m_iTimeLeft_ShutUp = iTime*20; 
				SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
				SendNotifyMsg(NULL, i, NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);

				// Admin Log

				wsprintf(g_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
					m_pClientList[i]->m_cCharName, iTime);

#ifdef TAIWANLOG
				_bItemLog(ITEMLOG_SHUTUP,i,m_pClientList[iClientH]->m_cCharName,NULL) ;

				// Admin Log

				wsprintf(g_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
					m_pClientList[i]->m_cCharName, iTime);

				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
#endif

				return;
			}

			ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_SHUTUPPLAYER;
			cp++;

			wp = (uint16 *)cp;
			*wp = GSID;
			cp += 2;

			wp = (uint16 *)cp;
			*wp = iClientH;
			cp += 2;

			memcpy(cp, cName, 10);
			cp += 10;

			wp = (uint16 *)cp;
			*wp = iTime ;
			cp += 2;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			bStockMsgToGateServer(cBuff, 27);

			return;

	}

	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cBuff[256];
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 45) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	else if ( m_pClientList[iClientH]->IsNeutral() ) { // 2002-11-15
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				if (i != iClientH) {
					if(strcmp(m_pClientList[i]->m_cIPaddress,m_pClientList[iClientH]->m_cIPaddress) != 0){
						if (cValue == 0) 
							m_pClientList[i]->m_reputation--;
						else if (cValue == 1)
							m_pClientList[i]->m_reputation++;

						m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

						SendNotifyMsg(NULL, i, NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
						SendNotifyMsg(NULL, iClientH, NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
					}
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	return;
}

bool CGame::bReadNotifyMsgListFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32  dwFileSize;
	char * cp, * token, cReadMode;
	char seps[] = "=\t\n;";
	
	int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Notify Message list file not found!...");
		return false;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < MAXNOTIFYMSGS; i++) 
						if (m_pNoticeMsgList[i] == NULL) {
							m_pNoticeMsgList[i] = new class CMsg;
							m_pNoticeMsgList[i]->bPut(NULL, token, strlen(token), NULL, NULL);
							m_iTotalNoticeMsg++;
							break;
						}
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}

			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return true;
}


void CGame::NoticeHandler()
{
	char  cTemp, cBuffer[1000], cKey;
	uint32 dwSize, dwTime = timeGetTime();
	int i, iMsgIndex, iTemp;


	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > NOTICETIME) {

		m_dwNoticeTime = dwTime;
		do {
			iMsgIndex = dice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;

		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != NULL) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}

		for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, NOTIFY_NOTICEMSG, NULL, NULL, NULL, cBuffer);
			}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, uint32 dwMsgSize)
{
	char * cp, cCharName[11];
	int i;

	ZeroMemory(cCharName, sizeof(cCharName));

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	for (i = 0; i < MAXCLIENTS; i++) 
		if (m_pClientList[i] != NULL) {
			if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {

				SendNotifyMsg(NULL, i, NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
			}
		}
}

void CGame::CalcExpStock(int iClientH)
{
	bool bIsLevelUp;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;

	// !!!!
	//if ((m_pClientList[iClientH]->m_iLevel >= ) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[])) return;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == false) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	bIsLevelUp = bCheckLevelUp(iClientH);

	if ((bIsLevelUp == true) && (m_pClientList[iClientH]->m_iLevel <= 5)) {

		pItem = new class CItem;
		if (pItem->InitItemAttr("Gold") == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (uint32)100;
		bAddItem(iClientH, pItem);
	}

	if ((bIsLevelUp == true) && (m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20) ) {

		pItem = new class CItem;
		if (pItem->InitItemAttr("Gold") == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (uint32)300;
		bAddItem(iClientH, pItem);
	}

}

int CGame::iGetExpLevel(int iExp)
{
	int i;

	for (i = 1; i < 199; i++) 
		if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	int tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if(!token)
		return;

	if (strlen(token) > 10) 
		memcpy(cTargetName, token, 10);
	else memcpy(cTargetName, token, strlen(token));

	CClient * target = objMgr.FindPlayer(cTargetName);

	if(!target->IsValid())
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
		return;
	}

	if (memcmp(target->m_cMapName, sideMap[ARESDEN], 7) == 0) 
		strcpy(cNpcName, "Guard-Aresden");
	else if (memcmp(target->m_cMapName, sideMap[ELVINE], 6) == 0) 
		strcpy(cNpcName, "Guard-Elvine");
	else if (memcmp(target->m_cMapName, sideMap[ISTRIA], 6) == 0) 
		strcpy(cNpcName, "Guard-Istria");
	else strcpy(cNpcName, "Guard-Neutral");  

	tX = (int)target->m_sX;
	tY = (int)target->m_sY;

	CNpc * guard = CreateNpc(cNpcName, target->m_cMapIndex, 0, MOVETYPE_RANDOM, 
		&tX, &tY, (Side)-1, cNpcWaypoint, NULL, NULL, false, true);

	if(!guard) 
		return;

	guard->SetTarget( target );

	wsprintf(g_cTxt, "GM Order(%s): Guard Attack PC(%s)",m_pClientList[iClientH]->m_cCharName, target->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL, g_cTxt);
}


void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256];

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		return;
	}

	int iNum = atoi(token) - 1;		

	if ( m_iFightZoneReserve[iNum] != -1) {
		wsprintf(g_cTxt, "GM Order(%s): FightzoneNumber(%d) FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

		m_iFightZoneReserve[iNum] = - 1 ;        												 
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);

	}  else {
		wsprintf(g_cTxt, "GM Order(%s): FightzoneNumber(%d) Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);
		
		if(m_donateEventHolder != -1)
		{
			m_donateEventPot = -1;
			CClient * player = objMgr.FindPlayer(m_donateEventHolder);
			if(player)
				player->Notify(NULL, NOTIFY_DONATEEVENTINFO);
			m_donateEventHolder = -1;
		}
	}

	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cTargetName[11], cBuff[256];
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

#ifdef TIAWAN
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
#else
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
#endif

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				if (m_pClientList[i]->m_bIsInitComplete == true) {


					if (m_pClientList[iClientH]->m_iAdminUserLevel < m_pClientList[i]->m_iAdminUserLevel) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
						return ;
					}

					wsprintf(g_cTxt, "GM Order(%s): Close Connection PC(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cCharName);

					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
#ifdef TAIWANLOG
					_bItemLog(ITEMLOG_CLOSECONN,i, m_pClientList[iClientH]->m_cCharName,NULL);
#endif
					DeleteClient(i, true, true, true, true);
				}

				return;
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	return;
}




void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cTargetName[11], cBuff[256];

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if(!gldRankPerm[ m_pClientList[iClientH]->m_iGuildRank ].canBan ) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for(int i = 1; i < MAXCLIENTS; i++) 
		{
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) )
			{
				if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {

					SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
					return;
				}
				
				if(m_pClientList[i]->m_iGuildRank == GUILDRANK_MASTER)
					return;

				m_pClientList[i]->WithdrawFromGuild();

				SendNotifyMsg(NULL, iClientH, NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
				SendNotifyMsg(iClientH, i, COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);
				return;
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
		}
	}

	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, uint32 dwMsgSize)
{

}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, uint32 dwLastTime)
{
	int i, iDynamicHandle;

	if (cMapIndex < 0 || cMapIndex >= MAXMAPS ||
		!m_pMapList[cMapIndex] ||
		!m_pMapList[cMapIndex]->bGetIsWater(sX, sY))
	{
		delete pItem;
		return NULL;
	}

	for (i = 1; i < MAXFISHS; i++) 
	{
		if (m_pFish[i] == NULL) {

			m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
			if (m_pFish[i] == NULL) return NULL;


			switch (pItem->m_sIDnum) {
			case 101: 
			case 102: 
			case 103: 
			case 570:
			case 571:
			case 572:
			case 573:
			case 574:
			case 575:
			case 576:
			case 577:
				iDynamicHandle = iAddDynamicObjectList(i, NULL, DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
				break;
			default: 
				iDynamicHandle = iAddDynamicObjectList(i, NULL, DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
				break;
			}

			if (iDynamicHandle == NULL) {
				delete m_pFish[i];
				m_pFish[i] = NULL;
				return NULL;
			}
			m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMapList[cMapIndex]->m_iCurFish++;

			return i;
		}
	}

	delete pItem;
	return NULL;
}


bool CGame::bDeleteFish(int iHandle, int iDelMode)
{
	int i, iH;
	uint32 dwTime;

	if (m_pFish[iHandle] == NULL) return false;

	dwTime = timeGetTime();

	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;

	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}

	for (i = 1; i < MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
				SendNotifyMsg(NULL, i, NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
				ClearSkillUsingStatus(i); 
		}
	}


	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;

	return true;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
	int i;
	short sDistX, sDistY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= MAXMAPS)) return 0;

	for (i = 1; i < MAXDYNAMICOBJECTS; i++) 
		if (m_pDynamicObjectList[i] != NULL) {
			sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
			sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);

			if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
				((m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_FISHOBJECT)) &&
				(sDistX <= 2) && (sDistY <= 2)) {

					if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
					if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= MAXENGAGINGFISH) return 0;

					if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
					if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
					m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
					m_pClientList[iClientH]->m_iFishChance = 1;
					m_pClientList[iClientH]->m_bSkillUsingStatus[1] = true;

					SendNotifyMsg(NULL, iClientH, NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
						m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);


					m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;

					return i;
			}
		}

		return 0;
}

void CGame::FishProcessor()
{
	int i, iSkillLevel, iResult, iChangeValue;

	for (i = 1; i < MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true) && 
			(m_pClientList[i]->m_iAllocatedFish != NULL)) {

				if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) break;

				iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
				iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
				if (iSkillLevel <= 0) iSkillLevel = 1;

				iChangeValue = iSkillLevel / 10;
				if (iChangeValue <= 0) iChangeValue = 1;
				iChangeValue = dice(1, iChangeValue);

				iResult = dice(1, 100);
				if (iSkillLevel > iResult) {
					m_pClientList[i]->m_iFishChance += iChangeValue;
					if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

					SendNotifyMsg(NULL, i, NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
				}
				else if (iSkillLevel < iResult) {
					m_pClientList[i]->m_iFishChance -= iChangeValue;
					if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

					SendNotifyMsg(NULL, i, NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
				}
		}
	}
}



void CGame::AdminOrder_CreateFish(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256] ;
	class  CItem   * pItem;
	int tX, tY, iType;
	int iItemID = 0 ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		pItem = new class CItem;
		if (pItem == NULL) {
			return;
		}

		iItemID = 100 ;

		if (pItem->InitItemAttr(iItemID) == true) {
			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);

			delete pItem;
			pItem = NULL ;
		}
		else {
			delete pItem;
			pItem = NULL ;
		}
	}

	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cMapName[256] ;
	int dX, dY;
	bool   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_bIsObserverMode == true) return ;

#ifndef ALLOWPLAYERTP
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		//SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
#endif

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}


	if(dY == -1)	dX = -1;

	bFlag = false;
	if (strcmp("arefarm", cMapName) == 0) bFlag = true;
	else if (strcmp(sideMap[ARESDEN], cMapName) == 0) bFlag = true;
	else if (strcmp("aresdend1", cMapName) == 0) bFlag = true;
	else if (strcmp("cath_1", cMapName) == 0) bFlag = true;
	else if (strcmp("wrhus_1", cMapName) == 0) bFlag = true;
	else if (strcmp("bsmith_1", cMapName) == 0) bFlag = true;
	else if (strcmp("gshop_1", cMapName) == 0) bFlag = true;
	else if (strcmp("wrhus_1f", cMapName) == 0) bFlag = true;
	else if (strcmp("bsmith_1f", cMapName) == 0) bFlag = true;
	else if (strcmp("gshop_1f", cMapName) == 0) bFlag = true;
	else if (strcmp("gldhall_1", cMapName) == 0) bFlag = true;
	else if (strcmp("cityhall_1", cMapName) == 0) bFlag = true;
	else if (strcmp("CmdHall_1", cMapName) == 0) bFlag = true;
	else if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = true;
	else if (strcmp("huntzone2", cMapName) == 0) bFlag = true;
	else if (strcmp("huntzone4", cMapName) == 0) bFlag = true;
	else if (strcmp("areuni", cMapName) == 0) bFlag = true;
	else if (strcmp("resurr1", cMapName) == 0) bFlag = true;
	else if (strcmp("arejail", cMapName) == 0) bFlag = true;
	else if (strcmp("arewrhus", cMapName) == 0) bFlag = true;
	else if (strcmp("arebrk11", cMapName) == 0) bFlag = true;
	else if (strcmp("arebrk12", cMapName) == 0) bFlag = true;
	else if (strcmp("arebrk21", cMapName) == 0) bFlag = true;
	else if (strcmp("arebrk22", cMapName) == 0) bFlag = true;


	else if (strcmp("elvfarm", cMapName) == 0) bFlag = true;
	else if (strcmp(sideMap[ELVINE], cMapName) == 0)      bFlag = true;
	else if (strcmp("elvined1", cMapName) == 0)    bFlag = true;
	else if (strcmp("cath_2", cMapName) == 0)      bFlag = true;
	else if (strcmp("wrhus_2", cMapName) == 0)     bFlag = true;
	else if (strcmp("gshop_2", cMapName) == 0)     bFlag = true;
	else if (strcmp("bsmith_2", cMapName) == 0) bFlag = true;
	else if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = true;
	else if (strcmp("gshop_2f", cMapName) == 0)     bFlag = true;
	else if (strcmp("bsmith_2f", cMapName) == 0) bFlag = true;
	else if (strcmp("gldhall_2", cMapName) == 0)   bFlag = true;
	else if (strcmp("cityhall_2", cMapName) == 0) bFlag = true;
	else if (strcmp("CmdHall_2", cMapName) == 0) bFlag = true;
	else if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = true;
	else if (strcmp("huntzone1", cMapName) == 0) bFlag = true;
	else if (strcmp("huntzone3", cMapName) == 0) bFlag = true;
	else if (strcmp("elvuni", cMapName) == 0) bFlag = true;
	else if (strcmp("resurr2", cMapName) == 0) bFlag = true;
	else if (strcmp("elvjail", cMapName) == 0) bFlag = true;
	else if (strcmp("elvwrhus", cMapName) == 0) bFlag = true;
	else if (strcmp("elvbrk11", cMapName) == 0) bFlag = true;
	else if (strcmp("elvbrk12", cMapName) == 0) bFlag = true;
	else if (strcmp("elvbrk21", cMapName) == 0) bFlag = true;
	else if (strcmp("elvbrk22", cMapName) == 0) bFlag = true;


	else if (strcmp("dglv2", cMapName) == 0) bFlag = true;
	else if (strcmp("dglv3", cMapName) == 0) bFlag = true;
	else if (strcmp("dglv4", cMapName) == 0) bFlag = true;

	else if (strcmp("bisle", cMapName) == 0)   bFlag = true;
	else if (strcmp(sideMap[NEUTRAL], cMapName) == 0) bFlag = true;


	else if (strcmp("fightzone1", cMapName) == 0) bFlag = true;
	else if (strcmp("fightzone2", cMapName) == 0) bFlag = true;
	else if (strcmp("fightzone3", cMapName) == 0) bFlag = true;
	else if (strcmp("fightzone4", cMapName) == 0) bFlag = true;

	else if (strcmp("fightzone5", cMapName) == 0) bFlag = true;
	else if (strcmp("fightzone6", cMapName) == 0) bFlag = true;
	else if (strcmp("fightzone7", cMapName) == 0) bFlag = true;
	else if (strcmp("fightzone8", cMapName) == 0) bFlag = true;
	else if (strcmp("fightzone9", cMapName) == 0) bFlag = true;

	else if (strcmp("middleland", cMapName) == 0) bFlag = true;

	else if (strcmp("middled1n", cMapName) == 0) bFlag = true;
	else if (strcmp("middled1x", cMapName) == 0) bFlag = true;

	else if (strcmp("toh1", cMapName) == 0) bFlag = true;
	else if (strcmp("toh2", cMapName) == 0) bFlag = true;
	else if (strcmp("toh3", cMapName) == 0) bFlag = true;

	else if (strcmp("2ndmiddle", cMapName) == 0) bFlag = true;
	else if (strcmp("icebound", cMapName) == 0) bFlag = true;

	else if (strcmp("barracks1", cMapName) == 0) bFlag = true;
	else if (strcmp("barracks2", cMapName) == 0) bFlag = true;
	else if (strcmp("bsmith", cMapName) == 0) bFlag = true;
	else if (strcmp("astoria", cMapName) == 0) bFlag = true;

	else if (strcmp("test", cMapName) == 0) bFlag = true;
	else if (strcmp("inferniaA", cMapName) == 0) bFlag = true; 
	else if (strcmp("inferniaB", cMapName) == 0) bFlag = true; 
	else if (strcmp("maze", cMapName) == 0) bFlag = true; 
	else if (strcmp("procella", cMapName) == 0) bFlag = true;
	else if (strcmp("abaddon", cMapName) == 0) bFlag = true; 
	else if (strcmp("druncncity", cMapName) == 0) bFlag = true; 
	else if (strcmp("GodH", cMapName) == 0)   bFlag = true;
	else if (strcmp("BtField", cMapName) == 0) bFlag = true;
	else if (strcmp("HRampart", cMapName) == 0)     bFlag = true;


	if (!bFlag) 
		return; 

	if ((dX == - 1) && (dY == -1))
		wsprintf(g_cTxt, "GM Order(%s): teleport MapName(%s)",m_pClientList[iClientH]->m_cCharName, cMapName);
	else wsprintf(g_cTxt, "GM Order(%s): teleport MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName, cMapName,dX,dY);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

	RequestTeleportHandler(iClientH, 2, cMapName, dX, dY);

	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
	int iResult, iFishH;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = false;

	iResult = dice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {


		GetExp(iClientH, dice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 6)); //m_pClientList[iClientH]->m_iExpStock += dice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		CalculateSSN_SkillIndex(iClientH, SKILL_FISHING, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);


		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;


		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, 
			pItem);


		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 


		SendNotifyMsg(NULL, iClientH, NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;

		bDeleteFish(iFishH, 1); 
		return;
	}


	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);

	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}


void CGame::FishGenerator()
{
	class CItem * pItem;
	int iP, tX, tY;
	int iItemID; 
	short sDifficulty;
	uint32 dwLastTime;

	for(int i = 0; i < MAXMAPS; i++) {
		if (dice(1,4) != 1 || !m_pMapList[i] || m_pMapList[i]->m_iCurFish >= m_pMapList[i]->m_iMaxFish)	
			continue;

		iP = dice(1, m_pMapList[i]->m_iTotalFishPoint) - 1;
		if (m_pMapList[i]->m_FishPointList[iP].x == -1 || m_pMapList[i]->m_FishPointList[iP].y == -1) break;

		tX = m_pMapList[i]->m_FishPointList[iP].x + (dice(1,3) - 2);
		tY = m_pMapList[i]->m_FishPointList[iP].y + (dice(1,3) - 2);

		pItem = new CItem;
		if (!pItem) break;


		iItemID = ITEM_NONE;
		switch (dice(1,9)) 
		{
		case 1:	iItemID = ITEM_REDCARP ; sDifficulty = dice(1,10) +  5; break;
		case 2:	iItemID = ITEM_GREENCARP ; sDifficulty = dice(1,5) + 15;  break;
		case 3:	iItemID = ITEM_GOLDCARP ; sDifficulty = dice(1,10) + 20; break;
		case 4:	iItemID = ITEM_CRUCIANCARP ; sDifficulty = 1;  break;
		case 5:	iItemID = ITEM_BLUESEABREAM ; sDifficulty = dice(1,15) + 1;  break;  
		case 6:	iItemID = ITEM_REDSEABREAM ; sDifficulty = dice(1,18) + 1;  break;  
		case 7:	iItemID = ITEM_SALMON ; sDifficulty = dice(1,12) + 1;  break;
		case 8:	iItemID = ITEM_GRAYMULLET ; sDifficulty = dice(1,10) + 1;  break;
		case 9:
			switch (dice(1,150)) 
			{
			case 1:
			case 2:
			case 3:
				iItemID = ITEM_POWERGREENPOTION;  
				sDifficulty = dice(4,4) + 20;
				break;

			case 10:
			case 11:
				iItemID = ITEM_SUPERGREENPOTION;  
				sDifficulty = dice(4,4) + 40;
				break;

			case 20:
				iItemID = ITEM_DAGGER_ADD2;  
				sDifficulty = dice(4,4) + 5;
				break;

			case 30:
				iItemID = ITEM_LONGSWORD_ADD2;  
				sDifficulty = dice(4,4) + 10;
				break;

			case 40:
				iItemID = ITEM_SCIMITAR_ADD2;  
				sDifficulty = dice(4,4) + 15;
				break;

			case 50:
				iItemID = ITEM_RAPIER_ADD2;  
				sDifficulty = dice(4,4) + 35;
				break;

			case 60:
				iItemID = ITEM_FLAMEBERGE_ADD2;  
				sDifficulty = dice(4,4) + 40;
				break;

			case 70:
				iItemID = ITEM_WARAXE_ADD2;  
				sDifficulty = dice(4,4) + 30;
				break;

			case 90:
				iItemID = ITEM_RUBY;  
				sDifficulty = dice(4,4) + 30;
				break;

			case 95:
				iItemID = ITEM_DIAMOND;  
				sDifficulty = dice(4,4) + 30;
				break;
			}
			break;
		}

		dwLastTime  = 10 _m + 10 _m * (dice(1,3) - 1);

		if (pItem->InitItemAttr(iItemID))
			iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime); 
		else{
			delete pItem;
			pItem = NULL;
		}
	}													  
}


// Calculates the number of players within a given radius.
int CGame::getPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
	int x, y, ret;
	class CTile * pTile;

	if ((cMapIndex < 0)	|| (cMapIndex > MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	ret = 0;
	for (x = dX - cRadius; x <= dX + cRadius; x++)
		for (y = dY - cRadius; y <= dY + cRadius; y++) {
			if ( (x < 0) || (x >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(y < 0) || (y >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + x + y*m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == OWNERTYPE_PLAYER))
					ret++;
			}
		}

		return ret;
}


void CGame::WeatherProcessor()
{
	Weather prevMode;
	int i, j;
	uint32 dwTime;
	dwTime = timeGetTime();
	SYSTEMTIME SysTime;
	GetLocalTime(&SysTime);

	for (i = 0; i < MAXMAPS; i++) 
	{
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == false)) 
		{
			prevMode = m_pMapList[i]->m_weather;
			if (m_pMapList[i]->m_weather != WEATHER_SUNNY) 
			{
				if ((dwTime - m_pMapList[i]->m_dwWeatherStartTime) > m_pMapList[i]->m_dwWeatherLastTime) 
					m_pMapList[i]->m_weather = WEATHER_SUNNY;
			} else if (dice(1,100) == 13) 
			{
				m_pMapList[i]->m_weather = Weather( dice(1,3) );
				m_pMapList[i]->m_dwWeatherStartTime = dwTime;
				m_pMapList[i]->m_dwWeatherLastTime  = 3 _m + dice(1,7) _m;
			}

			if (m_pMapList[i]->m_bIsFixedSnowMode == true)
			{
				m_pMapList[i]->m_weather = Weather( dice(1,3) + 3 );
				m_pMapList[i]->m_dwWeatherStartTime = dwTime;
				m_pMapList[i]->m_dwWeatherLastTime  = 3 _m + dice(1,7) _m;
			}

			if (prevMode != m_pMapList[i]->m_weather)
			{
				for (j = 1; j < MAXCLIENTS; j++) 
					if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == true) && (m_pClientList[j]->m_cMapIndex == i)) 
						SendNotifyMsg(NULL, j, NOTIFY_WEATHERCHANGE, m_pMapList[i]->m_weather, NULL, NULL, NULL);
			}
		}
	}
}


void CGame::FightzoneReserveProcessor()
{
	int i;

	//	PutLogList("CAN FIGHTZONE RESERVE!!");

	for (i=0 ; i < MAXFIGHTZONE ; i++ ) {
		if (m_iFightZoneReserve[i] == -1 ) continue ; 
		m_iFightZoneReserve[i] = 0 ;
	}

	for (i = 1; i < MAXCLIENTS; i++) {
		if((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
			SendNotifyMsg(NULL, i, NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	}
}


int CGame::iGetWeatherMagicBonusEffect(CMagic * spell, Weather weather)
{
	switch (weather) 
	{
	case WEATHER_LIGHTRAIN:
	case WEATHER_MEDIUMRAIN:
	case WEATHER_HEAVYRAIN:
		switch(spell->m_element) 
		{
		case ELEMENT_AIR:
			return 2*weather;

		case ELEMENT_FIRE:
			return -2*weather;
		}
		break;
		
	case WEATHER_LIGHTSNOW:
	case WEATHER_MEDIUMSNOW:
	case WEATHER_HEAVYSNOW:
		switch(spell->m_element) 
		{
		case ELEMENT_FIRE:
			return (weather%3) * -1; 

		case ELEMENT_WATER:
			return weather%3;
		}
		break;
	}

	return 0;
}

int CGame::iGetMapIndex(char * pMapName)
{
	int i, iMapIndex;

	iMapIndex = -1;
	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {
			if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) {
				iMapIndex = i;
				break;
		}
		}

	return iMapIndex;
}


int CGame::_iForcePlayerDisconect(int iNum)
{
	int i, iCnt;

	iCnt = 0;
	for (i = 1; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete == true)
				DeleteClient(i, true, true);
			else DeleteClient(i, false, false);
			iCnt++;
			if (iCnt >= iNum) break;
		}

		return iCnt;
}

void CGame::SpecialEventHandler()
{
	uint32 dwTime;

	dwTime = timeGetTime();

	if ((dwTime - m_dwSpecialEventTime) < MOBEVENTTIME) return;
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = true;

	switch (dice(1,350)) {
	case 98: m_cSpecialEventType = 2; break; 
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cIP[21], cInfoString[500];
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
				ZeroMemory(cInfoString, sizeof(cInfoString));
				wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
					m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					m_pClientList[i]->m_iLevel, NULL/*m_pClientList[i]->m_cAccountStatus*/,
					m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

				SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			}
	}


}

void CGame::ToggleSafeAttackModeHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;


	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == true) 
		m_pClientList[iClientH]->m_bIsSafeAttackMode = false;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = true;

	SendNotifyMsg(NULL, iClientH, NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
	int ix, iy, sX, sY;
	short sOwnerH;
	char  cOwnerType;


	if (m_pNpcList[iNpcH] == NULL) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
		for (iy = sY - 8; iy <= sY + 8; iy++) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == OWNERTYPE_NPC) && 
				(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_side == m_pNpcList[iNpcH]->m_side) &&
				(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == false) && (m_pNpcList[sOwnerH]->m_cBehavior == BEHAVIOR_MOVE)) {

					m_pNpcList[sOwnerH]->m_cBehavior          = BEHAVIOR_ATTACK;
					m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
					m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

					return;
			}
		}
}

void CGame::ForceDisconnectAccount(char *pAccountName, uint16 wCount)
{
	int i;
	bool accountConnected = false;

	if (m_bIsGameStarted){
		if (wCount > 10 ) wCount = 10 ;
		for (i = 1; i < MAXCLIENTS; i++){
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
				accountConnected = true;
				wsprintf(g_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
				PutLogList(g_cTxt);

				//DeleteClient(i, true, true);

				SendNotifyMsg(NULL, i, NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
			}
		}
	}

	if(!accountConnected)
		bSendMsgToLS(MSGID_CONFIRMFORCELOGOUT, NULL, NULL, pAccountName);
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 5) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if(!m_pClientList[iClientH]->m_sOriginalType)
		m_pClientList[iClientH]->m_sOriginalType = m_pClientList[iClientH]->m_sType;
	else
		m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;

	if (token != NULL) {
		if (memcmp(token, "off", 3) == 0)
			m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;

		else if (memcmp(token, "Slime", 5) == 0)
			m_pClientList[iClientH]->m_sType = 10;

		else if (memcmp(token, "Skeleton", 8) == 0)
			m_pClientList[iClientH]->m_sType = 11;

		else if (memcmp(token, "Stone-Golem", 11) == 0)
			m_pClientList[iClientH]->m_sType = 12;

		else if (memcmp(token, "Cyclops", 7) == 0)
			m_pClientList[iClientH]->m_sType = 13;

		else if (memcmp(token, "Orc", 3) == 0)
			m_pClientList[iClientH]->m_sType = 14;

		else if (memcmp(token, "ShopKeeper", 10) == 0)
			m_pClientList[iClientH]->m_sType = 15;

		else if (memcmp(token, "Giant-Ant", 9) == 0)
			m_pClientList[iClientH]->m_sType = 16;

		else if (memcmp(token, "Scorpion", 8) == 0)
			m_pClientList[iClientH]->m_sType = 17;

		else if (memcmp(token, "Zombie", 6) == 0)
			m_pClientList[iClientH]->m_sType = 18;

		else if (memcmp(token, "Gandlf", 6) == 0)
			m_pClientList[iClientH]->m_sType = 19;

		else if (memcmp(token, "Howard", 6) == 0)
			m_pClientList[iClientH]->m_sType = 20;

		else if (memcmp(token, "Gaurd", 5) == 0)
			m_pClientList[iClientH]->m_sType = 21;

		else if (memcmp(token, "Amphis", 6) == 0)
			m_pClientList[iClientH]->m_sType = 22;

		else if (memcmp(token, "Clay-Golem", 10) == 0)
			m_pClientList[iClientH]->m_sType = 23;

		else if (memcmp(token, "Tom", 3) == 0)
			m_pClientList[iClientH]->m_sType = 24;

		else if (memcmp(token, "William", 7) == 0)
			m_pClientList[iClientH]->m_sType = 25;

		else if (memcmp(token, "Kennedy", 7) == 0)
			m_pClientList[iClientH]->m_sType = 26;

		else if (memcmp(token, "Hellbound", 9) == 0)
			m_pClientList[iClientH]->m_sType = 27;

		else if (memcmp(token, "Troll", 5) == 0)
			m_pClientList[iClientH]->m_sType = 28;

		else if (memcmp(token, "Orge", 4) == 0)
			m_pClientList[iClientH]->m_sType = 29;

		else if (memcmp(token, "Liche", 5) == 0)
			m_pClientList[iClientH]->m_sType = 30;

		else if (memcmp(token, "Demon", 5) == 0)
			m_pClientList[iClientH]->m_sType = 31;

		else if (memcmp(token, "Unicorn", 7) == 0)
			m_pClientList[iClientH]->m_sType = 32;

		else if (memcmp(token, "WereWolf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 33;

		else if (memcmp(token, "Dummy", 5) == 0)
			m_pClientList[iClientH]->m_sType = 34;

		else if (memcmp(token, "Energy-Sphere", 13) == 0)
			m_pClientList[iClientH]->m_sType = 35;

		else if (memcmp(token, "AGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 36;

		else if (memcmp(token, "CGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 37;

		else if (memcmp(token, "MS", 2) == 0)
			m_pClientList[iClientH]->m_sType = 38;

		else if (memcmp(token, "DT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 39;

		else if (memcmp(token, "ESG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 40;

		else if (memcmp(token, "GMG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 41;

		else if (memcmp(token, "ManaStone", 9) == 0)
			m_pClientList[iClientH]->m_sType = 42;

		else if (memcmp(token, "LWB", 3) == 0)
			m_pClientList[iClientH]->m_sType = 43;

		else if (memcmp(token, "GHK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 44;

		else if (memcmp(token, "GHC", 3) == 0)
			m_pClientList[iClientH]->m_sType = 45;

		else if (memcmp(token, "TK", 2) == 0)
			m_pClientList[iClientH]->m_sType = 46;

		else if (memcmp(token, "BG", 2) == 0)
			m_pClientList[iClientH]->m_sType = 47;

		else if (memcmp(token, "Stalker", 7) == 0)
			m_pClientList[iClientH]->m_sType = 48;

		else if (memcmp(token, "Hellclaw", 8) == 0)
			m_pClientList[iClientH]->m_sType = 49;

		else if (memcmp(token, "Tigerworm", 8) == 0)
			m_pClientList[iClientH]->m_sType = 50;

		else if (memcmp(token, "CP", 2) == 0)
			m_pClientList[iClientH]->m_sType = 51;

		else if (memcmp(token, "Gagoyle", 7) == 0)
			m_pClientList[iClientH]->m_sType = 52;

		else if (memcmp(token, "Beholder", 8) == 0)
			m_pClientList[iClientH]->m_sType = 53;

		else if (memcmp(token, "Dark-Elf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 54;

		else if (memcmp(token, "Rabbit", 6) == 0)
			m_pClientList[iClientH]->m_sType = 55;

		else if (memcmp(token, "Cat", 3) == 0)
			m_pClientList[iClientH]->m_sType = 56;

		else if (memcmp(token, "Giant-Frog", 10) == 0)
			m_pClientList[iClientH]->m_sType = 57;

		else if (memcmp(token, "Mountain-Giant", 14) == 0)
			m_pClientList[iClientH]->m_sType = 58;

		else if (memcmp(token, "Ettin", 5) == 0)
			m_pClientList[iClientH]->m_sType = 59;

		else if (memcmp(token, "Cannibal-Plant", 13) == 0)
			m_pClientList[iClientH]->m_sType = 60;

		else if (memcmp(token, "Rudolph", 7) == 0)
			m_pClientList[iClientH]->m_sType = 61;

		else if (memcmp(token, "DireBoar", 8) == 0)
			m_pClientList[iClientH]->m_sType = 62;

		else if (memcmp(token, "Frost", 5) == 0)
			m_pClientList[iClientH]->m_sType = 63;

		else if (memcmp(token, "Crops", 5) == 0)
			m_pClientList[iClientH]->m_sType = 64;

		else if (memcmp(token, "Ice-Golem", 9) == 0)
			m_pClientList[iClientH]->m_sType = 65;

		else if (memcmp(token, "Wyvern", 6) == 0)
			m_pClientList[iClientH]->m_sType = 66;

		else if (memcmp(token, "McGaffin", 8) == 0)
			m_pClientList[iClientH]->m_sType = 67;

		else if (memcmp(token, "Perry", 5) == 0)
			m_pClientList[iClientH]->m_sType = 68;

		else if (memcmp(token, "Devlin", 6) == 0)
			m_pClientList[iClientH]->m_sType = 69;

		else if (memcmp(token, "Barlog", 6) == 0)
			m_pClientList[iClientH]->m_sType = 70;

		else if (memcmp(token, "Centaurus", 9) == 0)
			m_pClientList[iClientH]->m_sType = 71;

		else if (memcmp(token, "Claw-Turtle", 11) == 0)
			m_pClientList[iClientH]->m_sType = 72;

		else if (memcmp(token, "Fire-Wyvern", 11) == 0)
			m_pClientList[iClientH]->m_sType = 73;

		else if (memcmp(token, "Giant-Crayfish", 14) == 0)
			m_pClientList[iClientH]->m_sType = 74;

		else if (memcmp(token, "Giant-Lizard", 12) == 0)
			m_pClientList[iClientH]->m_sType = 75;

		else if (memcmp(token, "Giant-Plant", 11) == 0)
			m_pClientList[iClientH]->m_sType = 76;

		else if (memcmp(token, "MasterMage-Orc", 14) == 0)
			m_pClientList[iClientH]->m_sType = 77;

		else if (memcmp(token, "Minotaurs", 9) == 0)
			m_pClientList[iClientH]->m_sType = 78;

		else if (memcmp(token, "Nizie", 5) == 0)
			m_pClientList[iClientH]->m_sType = 79;

		else if (memcmp(token, "Tentocle", 8) == 0)
			m_pClientList[iClientH]->m_sType = 80;

		else if (memcmp(token, "Abaddon", 7) == 0)
			m_pClientList[iClientH]->m_sType = 81;

		else if (memcmp(token, "Sor", 3) == 0)
			m_pClientList[iClientH]->m_sType = 82;

		else if (memcmp(token, "ATK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 83;

		else if (memcmp(token, "Elf", 3) == 0)
			m_pClientList[iClientH]->m_sType = 84;

		else if (memcmp(token, "DSK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 85;

		else if (memcmp(token, "HBT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 86;

		else if (memcmp(token, "CT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 87;

		else if (memcmp(token, "Bar", 3) == 0)
			m_pClientList[iClientH]->m_sType = 88;

		else if (memcmp(token, "AGC", 3) == 0)
			m_pClientList[iClientH]->m_sType = 89;

		else if (memcmp(token, "Gail", 4) == 0)
			m_pClientList[iClientH]->m_sType = 90;

		else if (memcmp(token, "gate", 4) == 0)
			m_pClientList[iClientH]->m_sType = 91;
	}
	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
}

void CGame::AdminOrder_SetInvi(int iClientH)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->ToggleStatusFlag(STATUS_INVISIBILITY);
}

void CGame::AdminOrder_SetHP(int iClientH, uint32 val)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->m_iHP = val;
}

void CGame::AdminOrder_SetMP(int iClientH, uint32 val)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->m_iMP = val;
}

void CGame::AdminOrder_SetMag(int iClientH, uint32 val)
{
	if (!m_pClientList[iClientH]->IsGM()) {
		return;
	}

	m_pClientList[iClientH]->SetMag(val);
}

bool CGame::bOnClose()
{
	if (m_bIsServerShutdowned == false) 
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return true;
		else return false;
	else return true;

	return false;
}

void CGame::_CheckAttackType(int iClientH, short *spType)
{
	uint16 wType;

	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		if (wType < 40) *spType = 1;
		break;

	case 20:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_HANDATTACK] < 100) *spType = 1;
		break;

	case 21: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_SHORTSWORD] < 100) *spType = 1;
		break;

	case 22: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_FENCING] < 100) *spType = 1;
		break;

	case 23: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_LONGSWORD] < 100) *spType = 1;
		break;

	case 24: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_AXE] < 100) *spType = 1;
		break;

	case 25: 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_ARCHERY] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		if (wType < 40) *spType = 1;
		break;
	case 26: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_HAMMER] < 100) *spType = 1;
		break;

	case 27: 

		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_STAFF] < 100) *spType = 1;
		break;
	}
}


void CGame::ReqCreatePortionHandler(int iClientH, char *pData)
{
	char  * cp, cI[6], cPortionName[21];
	int    i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
	short sItemIndex[6], sTemp;
	uint32  itemNumber[6];
	short sItemArray[12];
	bool   bDup, bFlag;
	class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		itemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;


	for (i = 0; i < 6; i++) {
		if (cI[i] >= MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
		if (cI[i] >= 0) {
			bDup = false;
			for (j = 0; j < 6; j++) 
				if (sItemIndex[j] == cI[i]) {
					itemNumber[j]++;
					bDup = true;
				}
			if (bDup == false) {
				for (j = 0; j < 6; j++) 
					if (sItemIndex[j] == -1) {
						sItemIndex[j] = cI[i];
						itemNumber[j]++;
						break;
					}
			}
		}

	for (i = 0; i < 6; i++) 
		if (sItemIndex[i] != -1) {
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;

			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < itemNumber[i]) return;
		}


	bFlag = true;
	while (bFlag == true) {
		bFlag = false;
		for (i = 0; i < 5; i++) 
			if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
					(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
						sTemp = sItemIndex[i+1];
						sItemIndex[i+1] = sItemIndex[i];
						sItemIndex[i] = sTemp;
						sTemp = itemNumber[i+1];
						itemNumber[i+1] = itemNumber[i];
						itemNumber[i] = sTemp;
						bFlag = true;
				}
			}
		}

		//testcode
		/*
		char cTemp[120];
		char cTxt1[120];
		char cTxt2[120];
		ZeroMemory(cTxt1, sizeof(cTxt1));
		ZeroMemory(cTxt2, sizeof(cTxt2));
		for (i = 0; i < 6; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		if (sItemIndex[i] != -1)
		wsprintf(cTemp, "(%d) ", m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
		else strcpy(cTemp, "(*)");
		strcat(cTxt1, cTemp);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "(%d) ", itemNumber[i]);
		strcat(cTxt2, cTemp);
		}
		PutLogList(cTxt1);
		PutLogList(cTxt2);
		*/

	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = itemNumber[i];
		j += 2;
	}

		//testcode
		/*
		char cTemp[120], cTxt1[120];
		ZeroMemory(cTxt1, sizeof(cTxt1));
		for (i = 0; i < 12; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d", sItemArray[i]);
		strcat(cTxt1, cTemp);
		}
		PutLogList(cTxt1);
		*/


	ZeroMemory(cPortionName, sizeof(cPortionName));

	for (i = 0; i < MAXPORTIONTYPES; i++) 
		if (m_pPortionConfigList[i] != NULL) {
			bFlag = false;
			for (j = 0; j < 12; j++) 
				if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true;

			if (bFlag == false) {

				ZeroMemory(cPortionName, sizeof(cPortionName));
				memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
				iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
				iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
			}
		}


	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMATCHINGPORTION, NULL, NULL, NULL, NULL);
		return;
	}

	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[SKILL_ALCHEMY];
	if (iSkillLimit > iSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_LOWPORTIONSKILL, NULL, NULL, NULL, cPortionName);
		return;
	}


	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;


	if( m_pClientList[iClientH]->m_cSkillMastery[SKILL_ALCHEMY] == 100 )
		iSkillLevel += 5;

	iResult = dice(1,100);
	if (iResult > iSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}

	/*
	if ((m_pClientList[iClientH]->m_iLevel < 20) && (iSkillLevel > 80 )) {
	SendNotifyMsg(NULL, iClientH, NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
	return;
	}
	*/

	CalculateSSN_SkillIndex(iClientH, SKILL_ALCHEMY, 1);

	if (strlen(cPortionName) != 0) {
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;

		for (i = 0; i < 6; i++)
			if (sItemIndex[i] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_CONSUME)

					SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
					m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - itemNumber[i]);
				else ItemDepleteHandler(iClientH, sItemIndex[i], false);
			}

		SendNotifyMsg(NULL, iClientH, NOTIFY_PORTIONSUCCESS, NULL, NULL, NULL, cPortionName);

		GetExp(iClientH, dice(2, (iDifficulty/3))); //m_pClientList[iClientH]->m_iExpStock += dice(1, (iDifficulty/3));

		if ((pItem->InitItemAttr(cPortionName) == true)) {

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) {

				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

				if (iEraseReq == 1) delete pItem;

				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
	}
}



bool CGame::_bDecodePortionConfigFileContents(char *pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iPortionConfigListIndex = 0;
	

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:

					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete[] pContents;
						return false;
					}

					if (m_pPortionConfigList[atoi(token)] != NULL) {
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
						delete[] pContents;
						return false;
					}
					m_pPortionConfigList[atoi(token)] = new class CPortion;
					iPortionConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:

					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

			case 14:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
				cReadModeB = 15;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
				cReadModeB = 16;
				break;

			case 16:

				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "potion", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
	PutLogList(cTxt);

	return true;
}

void CGame::LocalSavePlayerData(int iClientH)
{
	char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
	int    iSize;
	FILE * pFile;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;

	pData = new char[30000];
	if (pData == NULL) return;
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	_mkdir(cCharDir);
	_mkdir(cDir);


	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete[] pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}

	if (pFile != NULL) fclose(pFile);
	delete[] pData;
}

void CGame::MineralGenerator()
{
	int i, iP, tX, tY, iRet;

	for (i = 0; i < MAXMAPS; i++) {

		if ((dice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == true) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {

				iP = dice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
				if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

				tX = m_pMapList[i]->m_MineralPointList[iP].x;
				tY = m_pMapList[i]->m_MineralPointList[iP].y;

				iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
	int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;

	for (i = 1; i < MAXMINERALS; i++) 
		if (m_pMineral[i] == NULL) {

			iMineralType = dice(1, cLevel);
			m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
			if (m_pMineral[i] == NULL) return NULL;

			iDynamicHandle = NULL;
			switch (iMineralType) {
			case 1: 		
			case 2:
			case 3:
			case 4:
				iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
				break;

			case 5: 
			case 6:
				iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
				break;

			default:
				iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
				break;
			}

			if (iDynamicHandle == NULL) {
				delete m_pMineral[i];
				m_pMineral[i] = NULL;
				return NULL;
			}
			m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMineral[i]->m_cMapIndex = cMapIndex;


			switch (iMineralType) {
			case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
			case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
			case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
			case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
			case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
			default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			}

			m_pMapList[cMapIndex]->m_iCurMineral++;

			return i;
		}

	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
	short sType;
	uint32 dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult;
	int   iMineralID = ITEM_COAL;
	class CItem * pItem;
	uint16  wWeaponType;

	if (m_pClientList[iClientH] == NULL)  return;


	m_pClientList[iClientH]->RemoveMagicEffect(MAGICTYPE_INVISIBILITY);


	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

	switch (sType) {
	case DYNAMICOBJECT_MINERAL1:
	case DYNAMICOBJECT_MINERAL2:

		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
		}
		else return;

		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[SKILL_MINING];
		if (iSkillLevel == 0) break;

		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;

		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = dice(1, 100);
		if (iResult <= iSkillLevel) {
			CalculateSSN_SkillIndex(iClientH, SKILL_MINING, 1);

		switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) {
				case 1: 
					switch (dice(1,6)) {
						case 1: 
						case 2: 
						case 3:    
						case 4: 
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 5:    
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 6:
							iMineralID = ITEM_BLONDESTONE; // BlondeStone
							GetExp(iClientH, dice(1,3));
							break;
					} 
					break; 

				case 2: 
					switch (dice(1,7)) {
						case 1: 
						case 2: 
						case 3:
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 4:    
						case 5:  
						case 6:   
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 7:
							if (dice(1,3) == 2) {
								iMineralID = ITEM_SILVERNUGGET; // SilverNugget
								GetExp(iClientH, dice(1,4)); 
							} 
							else { 
								iMineralID = ITEM_BLONDESTONE; // BlondeStone
								GetExp(iClientH, dice(1,3)); 
							} 
							break; 
					} 
					break; 

				case 3: 
					switch (dice(1,6)) {
						case 1:						 
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 2: 
						case 3:    
						case 4:    
						case 5: 
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 6: 
							if (dice(1,8) == 3) {
								if (dice(1,2) == 1) {
									iMineralID = ITEM_SILVERNUGGET; // SilverNugget
									GetExp(iClientH, dice(1,4)); 
								} 
								else { 
									iMineralID = ITEM_BLONDESTONE; // BlondeStone
									GetExp(iClientH, dice(1,3)); 
								}
								break;
							} 
							else { 
								iMineralID = ITEM_IRONORE; // IronOre
								GetExp(iClientH, dice(1,3)); 
							} 
							break; 
					} 
					break; 

				case 4: 
					switch (dice(1,6)) {
						case 1:  
						case 2: 
							iMineralID = ITEM_COAL; // Coal
							GetExp(iClientH, dice(1,3)); 
							break;
						case 3:
							if (dice(1,3) == 2) {
								iMineralID =  ITEM_SILVERNUGGET; // SilverNugget
								GetExp(iClientH, dice(1,4)); 
							}
							else{
								iMineralID = ITEM_COAL; // Coal
								GetExp(iClientH, dice(1,3)); 
							}
							break;
						case 4:    
						case 5: 
							iMineralID = ITEM_IRONORE; // IronOre
							GetExp(iClientH, dice(1,3)); 
							break; 
						case 6: 
							if (dice(1,3) == 3)
							{
								// 0.33333
								if (dice(1,2) == 1)
								{
									// 0.5
									if (dice(1,2) == 1)
									{
										// 0.5
										iMineralID = ITEM_MITHRAL;
										GetExp(iClientH, dice(1,30)); 
									} else { 
										if (dice(1,100) <= 75)
										{
											// 0.75
											iMineralID =  ITEM_GOLDNUGGET;
											GetExp(iClientH, dice(1,5)); 
										} else {
											// 0.25
											iResult = dice(1,10000);
											if (iResult <= 1600)
											{
												iResult = dice(1,10000);
												if (iResult <= 7000)
													iMineralID = ITEM_ARMORGEM7;
												else if (iResult <= 9980)
													iMineralID = ITEM_ARMORGEM14;
												else if (iResult <= 10000)
													iMineralID = ITEM_ARMORGEM21;
											}
											else if (iResult <= 3200) 
											{
												iResult = dice(1,10000);
												if (iResult <= 7000)
													iMineralID = ITEM_MINDGEM7;
												else if (iResult <= 9980)
													iMineralID = ITEM_MINDGEM14;
												else if (iResult <= 10000)
													iMineralID = ITEM_MINDGEM21;
											}
											else if (iResult <= 6300)
											{
												iResult = dice(1,10000);
												if (iResult <= 7000)
													iMineralID = ITEM_BLOODGEM7;
												else if (iResult <= 9980)
													iMineralID = ITEM_BLOODGEM14;
												else if (iResult <= 10000)
													iMineralID = ITEM_BLOODGEM21;
											}
											else if (iResult <= 9400)
											{
												iResult = dice(1,10000);
												if (iResult <= 7000)
													iMineralID = ITEM_REJUGEM7;
												else if (iResult <= 9980)
													iMineralID = ITEM_REJUGEM14;
												else if (iResult <= 10000)
													iMineralID = ITEM_REJUGEM21;
											}
											else if (iResult <= 9700)
											{
												iResult = dice(1,10000);
												if (iResult <= 7000)
													iMineralID = ITEM_TACTICALGEM3;
												else if (iResult <= 9980)
													iMineralID = ITEM_TACTICALGEM5;
												else if (iResult <= 10000)
													iMineralID = ITEM_TACTICALGEM7;
											}
											else if (iResult <= 9999)
											{
												iResult = dice(1,10000);
												if (iResult <= 7000)
													iMineralID = ITEM_ENCHANTEDGEM2;
												else if (iResult <= 9980)
													iMineralID = ITEM_ENCHANTEDGEM4;
												else if (iResult <= 10000)
													iMineralID = ITEM_ENCHANTEDGEM6;
											}
											else if (iResult <= 10000)
											{
												iMineralID = ITEM_VORTEXGEM;
											}

											GetExp(iClientH, dice(1,60)); 
										}
									}
									break;
								} else { 
									// 0.5
									iMineralID =  ITEM_SILVERNUGGET; // SilverNugget
									GetExp(iClientH, dice(1,4)); 
								}
								break;
							} 
							else 
							{
								// 0.77777
								if (dice(1,2) == 1) 
								{
									iMineralID = ITEM_GOLDNUGGET; // GoldNugget
									GetExp(iClientH, dice(1,5));
								} else {
									iMineralID = ITEM_IRONORE;  // IronOre
									GetExp(iClientH, dice(1,3)); 
								}
								break;
							} 
							break; 
					}
					break;

				case 5: 
					switch (dice(1,19)) {
						case 3: 
							iMineralID = ITEM_SAPPHIRE; // Sapphire
							GetExp(iClientH, dice(2,3)); 
							break; 
						default: 
							iMineralID = ITEM_CRYSTAL; // Crystal
							GetExp(iClientH, dice(2,3)); 
							break; 
					} 
					break; 

				case 6: 
					switch (dice(1,5)) {
						case 1: 
							if (dice(1,6) == 3) {
								iMineralID =  ITEM_EMERALD; // Emerald 
								GetExp(iClientH, dice(2,4)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal
								GetExp(iClientH, dice(2,3)); 
							} 
							break; 
						case 2: 
							if (dice(1,6) == 3) {
								iMineralID =  ITEM_SAPPHIRE; // Saphire
								GetExp(iClientH, dice(2,4)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal
								GetExp(iClientH, dice(2,3)); 
							} 
							break; 
						case 3: 
							if (dice(1,6) == 3) {
								iMineralID =  ITEM_RUBY; // Ruby
								GetExp(iClientH, dice(2,4)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal 
								GetExp(iClientH, dice(2,3)); 
							} 
							break; 
						case 4: 
							iMineralID =  ITEM_CRYSTAL; // Crystal 
							GetExp(iClientH, dice(2,3)); 
							break; 
						case 5: 
							if (dice(1,12) == 3) {
								iMineralID =  ITEM_DIAMOND; // Diamond
								GetExp(iClientH, dice(2,5)); 
							} 
							else { 
								iMineralID =  ITEM_CRYSTAL; // Crystal
								GetExp(iClientH, dice(2,3)); 
							} 
							break;
					} 
					break;

			} 

			pItem = new class CItem;
			if (pItem->InitItemAttr(iMineralID) == false) {
				delete pItem;
			}
			else {

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
			}

			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;

	default: 
		break;
	}
}


bool CGame::bDeleteMineral(int iIndex)
{
	int iDynamicIndex;
	uint32 dwTime;

	dwTime = timeGetTime();

	if (m_pMineral[iIndex] == NULL) return false;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return false;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
		m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, true);

	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;

	return true;
}

void CGame::DeleteFlags()
{
	uint32 dwTime = timeGetTime(), dwRegisterTime;
	short sType;

	for (int i = 1; i < MAXDYNAMICOBJECTS; i++) 
	{ 
		if (m_pDynamicObjectList[i] && (m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_ARESDENFLAG || 
			m_pDynamicObjectList[i]->m_sType == DYNAMICOBJECT_ELVINEFLAG)) 
		{
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( 
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );

			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, 
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
			m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, 
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetTempMoveAllowedFlag(
				m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, true);

			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
	char cRewardName[21], cTargetName[21];
	int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1:			break;
	case 2:			break;
	case 3:			break;
	case 4:			iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5:
		break;
	case 6:			break;

	case 32: 		break;
	case 67:
	case 68:
	case 69: 		break;

	case 21: 

		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return; 
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {

			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, ""); break;
			}
		}


		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;

		SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		// Return Code

		switch (iQuestNum) {
		case  0: SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
	int ix, iy, iItemNum;
	short sSpr, sSprFrame;
	char  cItemColor;
	class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
		for (iy = sY -1; iy <= sY +1; iy++) {
			iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);

			switch (iItemNum) {
			case ITEM_COAL: 
				pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
				if (pItem != NULL) delete pItem;
				iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, cMapIndex,
					ix, iy, sSpr, sSprFrame, cItemColor);
				break;
			}
		}
}

//void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, uint32 dwMsgSize)
//{
//	char   seps[] = "= \t\n";
//	char   * token, cBuff[256], cNpcName[256];
//	int i;
//
//	if (m_pClientList[iClientH] == NULL) return;
//	if ((dwMsgSize)	<= 0) return;
//
//	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
//
//		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
//		return;
//	}
//
//	ZeroMemory(cBuff, sizeof(cBuff));
//	memcpy(cBuff, pData, dwMsgSize);
//
//	StrTok pStrTok(new CStrTok(cBuff, seps));
//
//	token = pStrTok->pGet();
//	token = pStrTok->pGet();
//	if (token != NULL) {
//		ZeroMemory(cNpcName, sizeof(cNpcName));
//		strcpy(cNpcName, token);
//	}
//
//	for (i = 0; i < MAXNPCS; i++) 
//		if (m_pNpcList[i] != NULL) {
//			if (memcmp(m_pNpcList[i]->m_cName, cNpcName, NPCNAMELENGTH - 1) == 0) {
//				SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINIFO, 1, i, NULL, NULL);
//			}
//		}
//
//}


int CGame::_iGetWeaponSkillType(int iClientH)
{
	uint16 wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;


	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {

		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			return 9; 
		else return 8; 	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {

		return 14; 	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {

		return 21;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}

	return 1;
}



//                             1 2 3 
static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,0,0};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 1,3,5};
static int ___iCAB9[]  = {0,0, 2,4,8};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5: 		return ___iCAB5[iComboCount];
		break;
	case 6: 		return ___iCAB6[iComboCount];
		break;
	case 7: 
		return ___iCAB7[iComboCount];
		break;
	case 8: 		return ___iCAB8[iComboCount];
		break;
	case 9: 
		return ___iCAB9[iComboCount];
		break;
	case 10: 		return ___iCAB10[iComboCount];
		break;
	case 14: 
		return ___iCAB6[iComboCount];
		break;
	case 21: 
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}


void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;


	SendNotifyMsg(NULL, iClientH, NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
}


bool CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
	bool bRet;

	if (m_pClientList[iClientH] == NULL) return false;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return false;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType)
	{
	case ITEMEFFECTTYPE_OCCUPYFLAG:
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2)
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 = 100;

		bRet =  SetHeldenianFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, iClientH, 1);

		if(!bRet) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;

	case ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		if(__bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
			iClientH))
		{
			if(--m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)
				return true;
		}
		break;

	case ITEMEFFECTTYPE_DYE:
		if(sDestItemID >= 0 && sDestItemID < MAXITEMS && m_pClientList[iClientH]->m_pItemList[sDestItemID])
		{
			if(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11 ||
				m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12)
			{
				m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
				return true;
			}
			else {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1);
				return false;
			}
		}
		break;

	case ITEMEFFECTTYPE_ITEMFARM:
		return __bSetAgricultureItem(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
			iClientH); 

	case ITEMEFFECTTYPE_SOCKET:
		if(sDestItemID >= 0 && sDestItemID < MAXITEMS) 
		{
			CItem * item = m_pClientList[iClientH]->m_pItemList[sDestItemID];
			if(!item) break;

			bRet = item->AddSocket( m_pClientList[iClientH]->m_pItemList[sItemIndex] );

			if(bRet)
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMSOCKETCHANGE, sDestItemID, (uint32)item);
			}
			return bRet;
		}
		break;
	}

	return false;
}


bool CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, bool bAdminFlag)
{
	int ix,iy,tx,ty,fx,fy;
	int   iLocalSide, iLocalEKNum, iDynamicObjectIndex, iIndex, iPrevStatus;
	class CTile * pTile;
	bool  bFlag;
	uint32 dwTime = timeGetTime();

	return false;


	if (cMapIndex != m_iMiddlelandMapIndex) return false;

	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) || 
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return false;

	if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) {
		if ((bAdminFlag == false) && (m_pClientList[iClientH]->m_side != iSide)) return false;
	}


	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != NULL) return false;
	if (pTile->m_bIsMoveAllowed == false)  return false;


	for (ix = dX-5; ix <= dX+5; ix++) 
	{
		for (iy = dY-5; iy <= dY+5; iy++) {
			if (ix != dX || iy != dY)
{
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
					(pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {

						if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side == iSide) return false;
				}
			}
		}
	}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= MAXOCCUPYFLAG) {

		return false;
	}

	bFlag = false;
	for (ix = dX - 10; ix <= dX + 10; ix++)
	{
		for (iy = dY - 8; iy <= dY + 8; iy++) {
			if (dX >= 0 && dX < m_pMapList[cMapIndex]->m_sSizeX && 
				dY >= 0 && dY < m_pMapList[cMapIndex]->m_sSizeY)
			{
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				if (pTile->m_iOccupyFlagIndex && pTile->m_iOccupyFlagIndex > 0 && 
					pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG && 
					m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]) 
				{
						if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side == iSide) {
							bFlag = true;
							goto SOF_LOOPBREAK1;
						}
				}
			}
		}
	}

SOF_LOOPBREAK1:;


	if ((bFlag == false) && (bAdminFlag == false)) return false;

	// Crusade

	int iTemp, iDistance = 9999999;
	int iMinFlagIndex = -1;
	class CTile * pMinTile;

	for (ix = dX - 10; ix <= dX + 10; ix++)
	{
		for (iy = dY - 8; iy <= dY + 8; iy++) {
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
					(pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL) &&
					(m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side != iSide)) {

						iTemp = (dX - ix)*(dX - ix) + (dY - iy)*(dY - iy);
						if (iTemp < iDistance) {
							iDistance = iTemp;
							iMinFlagIndex = pTile->m_iOccupyFlagIndex;
							pMinTile = pTile;
						}
				}
			}
		}
	}

	if (iMinFlagIndex != -1) {
		COccupyFlag *& minFlag = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex];
		fx = minFlag->m_sX;
		fy = minFlag->m_sY;
		iLocalSide  = minFlag->m_side;
		iLocalEKNum = minFlag->m_iEKCount;

		m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;

		iDynamicObjectIndex = minFlag->m_iDynamicObjectIndex;
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
		m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);

		delete minFlag;
		minFlag = NULL;

		pMinTile->m_iOccupyFlagIndex = NULL;

		delete m_pDynamicObjectList[iDynamicObjectIndex];
		m_pDynamicObjectList[iDynamicObjectIndex] = NULL;
	}

	switch (iSide)
	{
	case ARESDEN:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
	case ELVINE:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
	}


	iEKNum = 1;
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {

		return true; 
	}

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;

	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	_CheckStrategicPointOccupyStatus(cMapIndex);

	return true;

					/*
					for (ix = dX - 10; ix <= dX + 10; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) {
					if (iEKNum <= 0) goto SOF_LOOPBREAK2; 

					if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
					if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
					(pTile->m_iOccupyFlagIndex < MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {

					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side != iSide) {

					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount <= iEKNum) {

					// Crusade
					//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
					//	m_pClientList[iClientH]->m_iExpStock += m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount * 40;


					fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
					fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;
					iLocalSide  = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side;
					iLocalEKNum = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;

					m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;

					iEKNum -= m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;

					iDynamicObjectIndex = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iDynamicObjectIndex;
					SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
					m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
					m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
					m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);

					delete m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex];
					m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] = NULL;

					pTile->m_iOccupyFlagIndex = NULL;

					delete m_pDynamicObjectList[iDynamicObjectIndex];
					m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

					for (tx = fx - 10; tx <= fx + 10; tx++)
					for (ty = fy - 8; ty <= fy + 8; ty++) {
					if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
					iPrevStatus = pTile->m_iOccupyStatus;

					switch (iLocalSide) {
					case 1: 
					pTile->m_iOccupyStatus += iLocalEKNum;
					if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
					break;
					case 2:
					pTile->m_iOccupyStatus -= iLocalEKNum;
					if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
					break;
					}
					}
					}
					}
					else {
					m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount -= iEKNum;
					iLocalSide = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_side;

					fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
					fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;

					for (tx = fx - 10; tx <= fx + 10; tx++)
					for (ty = fy - 8; ty <= fy + 8; ty++) {
					if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);

					switch (iLocalSide) {
					case 1: 
					pTile->m_iOccupyStatus += iEKNum;
					if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
					break;
					case 2:
					pTile->m_iOccupyStatus -= iEKNum;
					if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
					break;
					}
					}
					}

					iEKNum = 0;
					}
					}
					}
					}
					}

					SOF_LOOPBREAK2:;



					if (iEKNum > 0) {

					switch (iSide) {
					case 1:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
					case 2:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	break;
					}

					iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
					if (iIndex < 0) {

					return true; 
					}

					// Crusade
					//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
					//	m_pClientList[iClientH]->m_iExpStock += iEKNum * 25;

					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
					pTile->m_iOccupyFlagIndex = iIndex;

					m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

					for (ix = dX - 10; ix <= dX + 10; ix++)
					for (iy = dY - 8; iy <= dY + 8; iy++) {
					if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
					(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
					}
					else {
					pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);

					switch (iSide) {
					case 1: 
					pTile->m_iOccupyStatus -= iEKNum; 
					break;
					case 2:
					pTile->m_iOccupyStatus += iEKNum; 
					break;
					}
					}
					}
					}


					iPrevStatus = m_iStrategicStatus;
					_CheckStrategicPointOccupyStatus(cMapIndex);
					if ((iPrevStatus * m_iStrategicStatus) < 0) {

					}

					return true;
					*/
}


void CGame::SetSummonMobAction(int iClientH, int iMode, uint32 dwMsgSize, char *pData)
{
	int i, iTargetIndex;
	char   seps[] = "= \t\n";
	char   * token, cTargetName[11], cBuff[256];

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->IsNeutral()) return;

	switch (iMode) {
	case 0: 
	case 1: 
		for (i = 0; i < MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) {
				if ( (m_pNpcList[i]->m_bIsSummoned == true) && 
					(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					(m_pNpcList[i]->m_cFollowOwnerType == OWNERTYPE_PLAYER) &&
					!m_pNpcList[i]->IsDead()) {

						m_pNpcList[i]->m_iSummonControlMode = iMode;
						m_pNpcList[i]->m_bIsPermAttackMode  = false;
						m_pNpcList[i]->m_cBehavior          = BEHAVIOR_MOVE;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;
						m_pNpcList[i]->m_iTargetIndex       = NULL;
				}
			}
			break;

	case 2:

		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		ZeroMemory(cTargetName, sizeof(cTargetName));
		StrTok pStrTok(new CStrTok(cBuff, seps));
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		iTargetIndex = 0;
		if (token != NULL) {

			if (strlen(token) > 10) 
				memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));

			for (i = 1; i < MAXCLIENTS; i++) 
			{
				// if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) { // original
				if ((m_pClientList[i] != NULL) &&
					(memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) 
				{
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

SSMA_SKIPSEARCH:;

		if ( (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_side != 0) && 
			(m_pClientList[iTargetIndex]->m_side != m_pClientList[iClientH]->m_side) ) {
				for (i = 0; i < MAXNPCS; i++)
					if (m_pNpcList[i] != NULL) {
						if ( (m_pNpcList[i]->m_bIsSummoned == true) && 
							(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
							(m_pNpcList[i]->m_cFollowOwnerType == OWNERTYPE_PLAYER) &&
							!m_pNpcList[i]->IsDead()) {
								m_pNpcList[i]->m_iSummonControlMode = iMode;
								m_pNpcList[i]->m_cBehavior          = BEHAVIOR_ATTACK;
								m_pNpcList[i]->m_sBehaviorTurnCount = 0;
								m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
								m_pNpcList[i]->m_cTargetType        = OWNERTYPE_PLAYER;
								m_pNpcList[i]->m_bIsPermAttackMode  = true;
						}
					}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
	int   i, iNum, iRet, iEraseReq, iEKNum;
	char  * cp, cData[256], cItemName[21];
	class CItem * pItem;
	uint32 * dwp;
	short * sp;
	uint16  * wp;
	char cTxt[120];

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 2) return;
	if (!m_bHeldenianMode) return;
	if (m_pClientList[iClientH]->m_iGuildRank != GUILDRANK_MASTER) return;

 	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_side) {
	case 1: strcpy(cItemName, "AresdenFlag"); break;
	case 2: strcpy(cItemName, "ElvineFlag");  break;
	}
	// ReqPurchaseItemHandler
	iNum = 1;
	for (i = 1; i <= iNum; i++) 
	{	pItem = new class CItem;
		if (pItem->InitItemAttr(cItemName) == false) 
		{	delete pItem;
		}else 
		{	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) 
			{	if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 2) 
				{	iEKNum = 1;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 2;
				}								
				// EKNum
				pItem->m_sItemSpecEffectValue2 = iEKNum;
				pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER; 
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 
				//testcode 
				wsprintf(cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, iEKNum
					, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogList(cTxt);
				PutLogFileList(cTxt);
					
				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);								
				if (iEraseReq == 1) delete pItem;
				SendNotifyMsg(NULL, iClientH, NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iEnemyKillTotalCount, NULL, NULL);
			}else 
			{	delete pItem;
				iCalcTotalWeight(iClientH);
				dwp  = (uint32 *)(cData + INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
				*wp  = NOTIFY_CANNOTCARRYMOREITEM;				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case XSOCKEVENT_QUENEFULL:
				case XSOCKEVENT_SOCKETERROR:
				case XSOCKEVENT_CRITICALERROR:
				case XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
 	}	}	}	}
}







void CGame::GetFightzoneTicketHandler(int iClientH)
{
	int   iEraseReq, iMonth, iDay, iHour;
	char  cItemName[21];
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) {

		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,ITEMNAME_ARENATICKET) ;
	else  wsprintf(cItemName,ITEMNAME_ARENATICKET2,m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (pItem->InitItemAttr(cItemName) == false) {
		delete pItem;
		return;
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) {
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;

		pItem->m_sTouchEffectType   = ITET_DATE;

		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
		iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;

		_bItemLog(ITEMLOG_GET, iClientH, (int) -1, pItem);

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

		if (iEraseReq == 1) 
		{
			delete pItem;
			pItem = NULL ;
		}
	}
	else {

		delete pItem;
		pItem = NULL ;

		iCalcTotalWeight(iClientH);

		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
	}
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
	SYSTEMTIME SysTime;
	char cTxt[120];
	int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");

	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	for (i = 1; i < MAXOCCUPYFLAG; i++) 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) {

			wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_side,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
			strcat(pData, cTxt);
			strcat(pData, "\n");
		}

		strcat(pData, "\n\n");

		return strlen(pData);
}


bool CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, uint32 dwMsgSize)
{
	char * pContents, * token;
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iSide;
	
	int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return false;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				// Side
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				iSide = atoi(token);
				cReadModeB = 2;
				break;

			case 2:

				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				dX = atoi(token);
				cReadModeB = 3;
				break;

			case 3:

				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				dY = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// EKNum
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				iEKNum = atoi(token);

				if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, true) == true)
					iTotalFlags++;

				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return false;
	}

	wsprintf(g_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(g_cTxt);

	return true;
}


void CGame::GetHeroMantleHandler(int iClientH,int reqItem,char * pString) 
{ 
	int   i, iNum, iEraseReq; 
	char  cItemName[21]; 
	class CItem * pItem; 

	CClient * player = m_pClientList[iClientH];
	if (!player) return; 
	if (player->m_iEnemyKillCount < 100) return; 
	if (player->IsNeutral()) return; 
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return;
	}

	if(reqItem < 0 || reqItem >= HR_MAX) return;

	uint32 iItemID = HeroItemID[reqItem][ player->m_side-1 ][ player->m_cSex-1 ];

	if(player->m_iEnemyKillCount < heroPrice[reqItem].EK ||
		player->m_iContribution < heroPrice[reqItem].contribution)
		return;

	if (!m_pItemConfigList[iItemID])  return;

	ZeroMemory(cItemName, sizeof(cItemName)); 
	memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 
	// ReqPurchaseItemHandler
	iNum = 1; 
	for (i = 1; i <= iNum; i++) 
	{ 
		pItem = new class CItem; 
		if (pItem->InitItemAttr(cItemName) == false) 
		{ 
			delete pItem; 
		} 
		else { 

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) {

				player->m_iEnemyKillCount -= heroPrice[reqItem].EK;
				player->m_iContribution -= heroPrice[reqItem].contribution;

				if (player->m_iCurWeightLoad < 0) player->m_iCurWeightLoad = 0; 

				wsprintf(g_cTxt, "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", player->m_cCharName, player->m_iEnemyKillCount, player->m_iContribution,cItemName); 
				PutLogFileList(g_cTxt); 

				pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER; 
				pItem->m_sTouchEffectValue1 = player->m_sCharIDnum1; 
				pItem->m_sTouchEffectValue2 = player->m_sCharIDnum2; 
				pItem->m_sTouchEffectValue3 = player->m_sCharIDnum3; 

				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

				if (iEraseReq == 1) delete pItem; 

				SendNotifyMsg(NULL, iClientH, NOTIFY_ENEMYKILLS, player->m_iEnemyKillCount, player->m_iEnemyKillTotalCount, NULL, NULL); 
			} 
			else 
			{ 
				delete pItem; 

				iCalcTotalWeight(iClientH); 

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			} 
		} 
	} 
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
	char * cp, cItemIndex;
	short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
	int i, iDamage;

	if (m_pClientList[iClientH] == NULL) return;

	for (i = 0; i < MAXITEMS; i++) 
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == ITET_UNIQUE_OWNER) &&
				(m_pClientList[iClientH]->m_bIsItemEquipped[i] == true) ) {


					if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
						(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
						(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {

					}
					else {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
						ReleaseItemHandler(iClientH, i, true);

						iDamage = dice(10, 10);
						m_pClientList[iClientH]->m_iHP -= iDamage;
						if (m_pClientList[iClientH]->m_iHP <= 0) {
							m_pClientList[iClientH]->KilledHandler(NULL, NULL, iDamage);
						}
					}
			}
		}
}


void CGame::_Manager_Init(int iClientH, char *  pData)
{
	if (m_pClientList[iClientH] == NULL) return;
	char cTemp[256] ;
	uint32 * dwp ;
	uint16 * wp ;
	char * cp ;
	short * sp ;

	ZeroMemory(cTemp, sizeof(cTemp));

	cp = (char *)(pData + 6);

	memcpy(cTemp,cp,10) ;

	if (memcmp(cTemp,"?BWordMtr?",10) != 0) return ;

	m_pClientList[iClientH]->m_bIsManager = true;
	m_iTotalClients-- ;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (uint32 *)cTemp;
	*dwp = MSGID_RESPONSE_CHECKCONNECTION;

	wp  = (uint16 *)(cTemp + INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;

	if ((m_bIsGameStarted == true) && (m_bIsItemAvailable == true) && 
		(m_bIsNpcAvailable == true) && (m_bIsMagicAvailable == true) &&
		(m_bIsSkillAvailable == true) && (m_bIsPortionAvailable == true) &&
		(m_bIsQuestAvailable == true)
		) {

			*sp =  1 ; 
	} 
	else 
	{
		*sp =  0 ; 
	}
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iMaxClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalGameServerClients ;
	cp += 2 ;

	sp  = (short *)cp;
	*sp = m_iTotalGameServerMaxClients ;
	cp += 2 ;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16 );

	wsprintf(g_cTxt, "(*) Manager Program(%d) Registered.", iClientH);
	PutLogList(g_cTxt);
}


void CGame::_Manager_Shutdown(int iClientH, char * pData)
{
	return ;
	if (m_pClientList[iClientH] == NULL) return;
	char cTemp[256] ;
	char * cp ;


	ZeroMemory(cTemp, sizeof(cTemp));

	cp = (char *)(pData + 6);

	memcpy(cTemp,cp,10) ;

	if (memcmp(cTemp,"1dkld$#@01",10) != 0) return ;


	m_cShutDownCode      = 2;
	m_bOnExitProcess     = true;
	m_dwExitProcessTime  = timeGetTime();

	PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
	bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);

	wsprintf(g_cTxt, "(*) Manager Program(%d) Start Shutdown.", iClientH);
	PutLogList(g_cTxt);
}

void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, uint16 wObjectID, char *pItemName)
{
	short sOwnerH;
	char  cOwnerType;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_isExchangeMode == true) return;
	if (wObjectID >= MAXCLIENTS) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == true) return;	//DEBUG

	if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iClientH]) return;
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((sOwnerH != NULL) && (cOwnerType == OWNERTYPE_PLAYER)) {

		if (wObjectID != NULL) {
			if (wObjectID < 10000) {
				if (m_pClientList[wObjectID] != NULL) {
					if ((uint16)sOwnerH != wObjectID) sOwnerH = NULL;
				}
			}
			else sOwnerH = NULL;
		}

		if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) {
			_ClearExchangeStatus(iClientH); 
		}
		else {
			if ((m_pClientList[sOwnerH]->m_isExchangeMode == true) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == true)) {

					_ClearExchangeStatus(iClientH);
			}
			else {
				m_pClientList[iClientH]->m_isExchangeMode = true;
				m_pClientList[iClientH]->m_exchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_exchangeName, sizeof(m_pClientList[iClientH]->m_exchangeName));
				strcpy(m_pClientList[iClientH]->m_exchangeName, m_pClientList[sOwnerH]->m_cCharName);

				m_pClientList[iClientH]->m_exchangeCount = 0;
				m_pClientList[sOwnerH]->m_exchangeCount = 0;

				for(i = 0; i < 4; i++){
					m_pClientList[iClientH]->m_exchangeItems[i].itemAmount = 0;
					m_pClientList[iClientH]->m_exchangeItems[i].itemIndex = -1;
					ZeroMemory(m_pClientList[iClientH]->m_exchangeItems[i].itemName, sizeof(m_pClientList[iClientH]->m_exchangeItems[i].itemName));

					m_pClientList[sOwnerH]->m_exchangeItems[i].itemAmount = 0;
					m_pClientList[sOwnerH]->m_exchangeItems[i].itemIndex = -1;
					ZeroMemory(m_pClientList[sOwnerH]->m_exchangeItems[i].itemName, sizeof(m_pClientList[sOwnerH]->m_exchangeItems[i].itemName));
				}


				m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemIndex  = (char)sItemIndex;
				m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemAmount = iAmount;
				memcpy(m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemName, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);

				m_pClientList[sOwnerH]->m_isExchangeMode  = true;
				m_pClientList[sOwnerH]->m_exchangeH = iClientH;

				ZeroMemory(m_pClientList[sOwnerH]->m_exchangeName, sizeof(m_pClientList[sOwnerH]->m_exchangeName));
				strcpy(m_pClientList[sOwnerH]->m_exchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->m_exchangeCount++;
				SendNotifyMsg(iClientH, iClientH, NOTIFY_OPENEXCHANGEWINDOW, sItemIndex + 1000, (uint32)m_pClientList[iClientH]->m_pItemList[sItemIndex], iAmount);

				SendNotifyMsg(iClientH, sOwnerH, NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, (uint32)m_pClientList[iClientH]->m_pItemList[sItemIndex], iAmount);
			}
		}
	}
	else {

		_ClearExchangeStatus(iClientH);
	}
}



void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
	int iExH, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == true) return;	
	if (m_pClientList[iClientH]->m_exchangeCount >= 4) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_disabled) return;

	if ((m_pClientList[iClientH]->m_isExchangeMode == true) && (m_pClientList[iClientH]->m_exchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_exchangeH;
		if (m_pClientList[iExH] != NULL && memcmp(m_pClientList[iClientH]->m_exchangeName, m_pClientList[iExH]->m_cCharName, 10) == 0 ) {

			if ((iItemIndex < 0) || (iItemIndex >= MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1  == m_pClientList[iClientH]->m_sCharIDnum1) && 
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2  == m_pClientList[iClientH]->m_sCharIDnum2) &&
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2  == m_pClientList[iClientH]->m_sCharIDnum3)) return;

			for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount;i++){
				if (m_pClientList[iClientH]->m_exchangeItems[i].itemIndex == (char)iItemIndex) {
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
					return;
				}
			}

			m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemIndex  = (char)iItemIndex;
			m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemAmount = iAmount;

			memcpy(m_pClientList[iClientH]->m_exchangeItems[m_pClientList[iClientH]->m_exchangeCount].itemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

			m_pClientList[iClientH]->m_exchangeCount++;

			SendNotifyMsg(iClientH, iClientH, NOTIFY_SETEXCHANGEITEM, iItemIndex+1000, (uint32)m_pClientList[iClientH]->m_pItemList[iItemIndex], iAmount); 

			SendNotifyMsg(iClientH, iExH, NOTIFY_SETEXCHANGEITEM, iItemIndex, (uint32)m_pClientList[iClientH]->m_pItemList[iItemIndex], iAmount);
		}
	}
}


void CGame::ConfirmExchangeItem(int iClientH)
{
	int iExH, i;
	int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
	class CItem * pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4];

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == true) return;
	if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iClientH]) return;


	if ((m_pClientList[iClientH]->m_isExchangeMode == true) && (m_pClientList[iClientH]->m_exchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_exchangeH;
		if(m_astoria.get() && m_astoria->GetRelicHolder() == m_pClientList[iExH]) return;

		if(iClientH == iExH) return;	
		if (m_pClientList[iExH] != NULL) {
			if ( (memcmp(m_pClientList[iClientH]->m_exchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
				(m_pClientList[iExH]->m_isExchangeMode != true) ||
				(memcmp(m_pClientList[iExH]->m_exchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0) ) {
					_ClearExchangeStatus(iClientH);
					_ClearExchangeStatus(iExH);
					return;
			}
			else {
				m_pClientList[iClientH]->m_isExchangeConfirm = true;
				if (m_pClientList[iExH]->m_isExchangeConfirm == true) {
					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex] == NULL) ||
							(memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName, m_pClientList[iClientH]->m_exchangeItems[i].itemName, 20) != 0)) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
						}
					}

					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						if(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex] == NULL ||
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_disabled || 
							(memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName, m_pClientList[iExH]->m_exchangeItems[i].itemName, 20) != 0)) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
						}
					}

					iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
					iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);

					iItemWeightA = 0;
					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						iItemWeightA = m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->GetWeight(
							m_pClientList[iClientH]->m_exchangeItems[i].itemAmount);
					}

					iItemWeightB = 0;
					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						iItemWeightB = m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->GetWeight(
							m_pClientList[iExH]->m_exchangeItems[i].itemAmount);
					}

					if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}
					
					if (_iGetItemSpaceLeft(iClientH) == 0 || _iGetItemSpaceLeft(iExH) == 0) {
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}

					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

								if (m_pClientList[iClientH]->m_exchangeItems[i].itemAmount > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_dwCount) {
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}

								pItemA[i] = new CItem(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName,
									m_pClientList[iClientH]->m_exchangeItems[i].itemAmount);

								pItemAcopy[i] = new CItem(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName);
								bCopyItemContents(pItemAcopy[i], pItemA[i]);
								pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
						}
						else {
							pItemA[i] = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex];
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
 
							pItemAcopy[i] = new CItem(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
						}
					}

					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

								if (m_pClientList[iExH]->m_exchangeItems[i].itemAmount > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_dwCount) {
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}

								pItemB[i] = new CItem(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName,
									m_pClientList[iExH]->m_exchangeItems[i].itemAmount);

								pItemBcopy[i] = new CItem(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName);
								bCopyItemContents(pItemBcopy[i], pItemB[i]);
								pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_exchangeItems[i].itemAmount;
						}
						else {
							pItemB[i] = (CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex];
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_exchangeItems[i].itemAmount;

							pItemBcopy[i] = new CItem(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_exchangeItems[i].itemAmount;
						}
					}


					for(i = 0; i < m_pClientList[iExH]->m_exchangeCount; i++){
						bAddItem(iClientH, pItemB[i]);
						_bItemLog(ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
						delete pItemBcopy[i];
						pItemBcopy[i] = NULL;
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

							iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex]->m_dwCount - m_pClientList[iExH]->m_exchangeItems[i].itemAmount;
							if (iAmountLeft < 0) iAmountLeft = 0;	  

							SetItemCount(iExH, m_pClientList[iExH]->m_exchangeItems[i].itemIndex, iAmountLeft);
						}
						else {
							ReleaseItemHandler(iExH, m_pClientList[iExH]->m_exchangeItems[i].itemIndex, true);
							SendNotifyMsg(NULL, iExH, NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_exchangeItems[i].itemIndex, m_pClientList[iExH]->m_exchangeItems[i].itemAmount, NULL, m_pClientList[iClientH]->m_cCharName);
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_exchangeItems[i].itemIndex] = NULL;
						}
					}

					for(i = 0; i < m_pClientList[iClientH]->m_exchangeCount; i++){
						bAddItem(iExH, pItemA[i]);
						_bItemLog(ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
						delete pItemAcopy[i];
						pItemAcopy[i] = NULL;

						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_cItemType == ITEMTYPE_ARROW) ) {

							iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex]->m_dwCount - m_pClientList[iClientH]->m_exchangeItems[i].itemAmount;
							if (iAmountLeft < 0) iAmountLeft = 0;	 

							SetItemCount(iClientH, m_pClientList[iClientH]->m_exchangeItems[i].itemIndex, iAmountLeft);
						}
						else {
							ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_exchangeItems[i].itemIndex, true);
							SendNotifyMsg(NULL, iClientH, NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_exchangeItems[i].itemIndex, m_pClientList[iClientH]->m_exchangeItems[i].itemAmount, NULL, m_pClientList[iExH]->m_cCharName);
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_exchangeItems[i].itemIndex] = NULL;
						}
					}

					m_pClientList[iClientH]->m_isExchangeMode = false;
					m_pClientList[iClientH]->m_isExchangeConfirm = false;
					ZeroMemory(m_pClientList[iClientH]->m_exchangeName, sizeof(m_pClientList[iClientH]->m_exchangeName));
					m_pClientList[iClientH]->m_exchangeH = NULL;
					m_pClientList[iClientH]->m_exchangeCount = 0;

					m_pClientList[iExH]->m_isExchangeMode = false;
					m_pClientList[iExH]->m_isExchangeConfirm = false;
					ZeroMemory(m_pClientList[iExH]->m_exchangeName, sizeof(m_pClientList[iExH]->m_exchangeName));
					m_pClientList[iExH]->m_exchangeH = NULL;
					m_pClientList[iClientH]->m_exchangeCount = 0;

					for(i = 0; i < 4; i++){
						m_pClientList[iClientH]->m_exchangeItems[i].itemIndex = -1;
						m_pClientList[iExH]->m_exchangeItems[i].itemIndex = -1;
					}

					SendNotifyMsg(NULL, iClientH, NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iExH,     NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);

					iCalcTotalWeight(iClientH);
					iCalcTotalWeight(iExH);
					return;									
				}
			}
		}
		else {
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}



int CGame::_iGetItemSpaceLeft(int iClientH)
{
	int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < MAXITEMS; i++) 
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (MAXITEMS - iTotalItem);
}

bool CGame::bAddItem(int iClientH, CItem * pItem)
{
	char cData[256];
	int iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) {

		SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL;
		}

		return true;
	}
	else {

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, 
			pItem);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);

		return true;
	}

	return false;
}


void CGame::CancelExchangeItem(int iClientH)
{
	int iExH;

	iExH = m_pClientList[iClientH]->m_exchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}


void CGame::_ClearExchangeStatus(int iClientH)
{
	if ((iClientH <= 0) || (iClientH >= MAXCLIENTS)) return;
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_isExchangeMode == true) 
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL);

	m_pClientList[iClientH]->m_isExchangeMode    = false;
	m_pClientList[iClientH]->m_isExchangeConfirm = false;
	m_pClientList[iClientH]->m_exchangeH = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_exchangeName, sizeof(m_pClientList[iClientH]->m_exchangeName));
}

int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	if (m_pClientList[iClientH] == NULL) return 0;

	return 0;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{

	if (m_pClientList[iClientH] == NULL) return 0;

	if (m_pClientList[iClientH]->m_side == ARESDEN ) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN], 7) == 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}
		else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE], 6) == 0) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}
	else if (m_pClientList[iClientH]->m_side == ELVINE ) {
			if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN], 7) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
				return 1002;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE], 6) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
				return 1003;
			}
	}
	else if (m_pClientList[iClientH]->IsNeutral()) {
			if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ARESDEN], 7) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
				return 1004;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[ELVINE], 6) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
				return 1005;
			}
			else if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL], 7) == 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
				return 1006;
			}
	}

	return 0;
}


bool CGame::_bDecodeQuestConfigFileContents(char * pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	uint32 iQuestConfigListIndex = 0;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:

				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				if (m_pQuestConfigList[atoi(token)] != NULL) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[atoi(token)] = new class CQuest;
				iQuestConfigListIndex = atoi(token);

				cReadModeB = 2;
				break;

			case 2:

				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_side = atoi(token);
				cReadModeB = 3;
				break;

			case 3:

				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// TargetType
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// MaxCount
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
				cReadModeB = 12;
				break;

			case 12:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
				cReadModeB = 13;
				break;

			case 13:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
				cReadModeB = 14;
				break;

			case 14:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
				cReadModeB = 15;
				break;

			case 15:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
				cReadModeB = 16;
				break;

			case 16:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
				cReadModeB = 17;
				break;

			case 17:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
				cReadModeB = 18;
				break;

			case 18:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
				cReadModeB = 19;
				break;

			case 19:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
				cReadModeB = 20;
				break;

			case 20:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
				cReadModeB = 21;
				break;

			case 21:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
				cReadModeB = 22;
				break;

			case 22:
				ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
				strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
				cReadModeB = 23;
				break;

			case 23:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
				cReadModeB = 24;
				break;

			case 24:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
				cReadModeB = 25;
				break;

			case 25:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
				cReadModeB = 26;
				break;

			case 26:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
				cReadModeB = 27;
				break;

			case 27:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);

	return true;
}

void CGame::_SendQuestContents(int iClientH)
{
	int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cQuestRemain;
	char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
			NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		if (m_pQuestConfigList[iIndex] == NULL) return ;

		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);

		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);

	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
	int iIndex;
	char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;

	if (m_pQuestConfigList[iIndex] == NULL) return;

	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {

		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;

		SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case QUESTTYPE_MONSTERHUNT:
	case QUESTTYPE_GOPLACE:
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = true;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = false;
		break;
	}
}

bool CGame::_bCheckIsQuestCompleted(int iClientH)
{
	int iQuestIndex;

	if (m_pClientList[iClientH] == NULL) return false;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == true) return false;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return false;

	if (m_pQuestConfigList[iQuestIndex] != NULL) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == true) && 
				(m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
					m_pClientList[iClientH]->m_bIsQuestCompleted = true;
					SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
					return true;
			}
			break;

		case QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == true) && 				 
				(m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && 
				(m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {

					m_pClientList[iClientH]->m_bIsQuestCompleted = true;
					SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
					return true;
			}
			break;
		}
	}

	return false;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, uint16 wMsgType, CItem *pItem, int iV1, bool deleteOnError)
{
	char  * cp, cData[512];
	uint32 * dwp;
	uint16  * wp;
	int     iRet;

	if (m_pClientList[iClientH] == NULL) return;

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + INDEX2_MSGTYPE + 2);

	switch (wMsgType)
	{
	case NOTIFY_ITEMOBTAINED:
		WriteItemData(cp, pItem);

		*cp = (char)pItem->m_sItemSpecEffectValue2; 
		cp++;

		dwp = (uint32 *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		
		for(int j = 0; j < MAXITEMSOCKETS; j++)
		{
			Push(cp, pItem->m_sockets[j]);
		}

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53 + MAXITEMSOCKETS);
		break;

	case NOTIFY_ITEMPURCHASED:
		WriteItemData(cp, pItem);

		wp  = (uint16 *)cp;
		*wp = iV1; // (iCost - iDiscountCost);

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case NOTIFY_CANNOTCARRYMOREITEM:
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}

	if (deleteOnError){
		switch (iRet) {
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

bool CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return false;

	/*
	if ((pItem->m_cItemType == ITEMTYPE_CONSUME) || (pItem->m_cItemType == ITEMTYPE_ARROW)) {
	if ((m_pClientList[iClientH]->m_iCurWeightLoad + (pItem->m_wWeight * pItem->m_dwCount)) > _iCalcMaxLoad(iClientH)) 
	return false;
	}
	else {
	if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->m_wWeight) > _iCalcMaxLoad(iClientH)) 
	return false;
	}
	*/
	if (m_pClientList[iClientH]->m_iCurWeightLoad + pItem->GetWeight(pItem->m_dwCount) > _iCalcMaxLoad(iClientH)) 
		return false;

	for (i = 0; i < MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return true;

	return false;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = false;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
	int i, iTotalPoint;
	POINT  pList[MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == NULL) return;

	iTotalPoint = 0;
	for (i = 0; i < MAXINITIALPOINT; i++)
		if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
			pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
			pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
			iTotalPoint++;
		}

	if (iTotalPoint == 0) return;

	if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		i = 0;
	else i = dice(1, iTotalPoint) - 1;
	*pX = pList[i].x;
	*pY = pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
	class CTile * pTile;
	int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < MAXSTRATEGICPOINTS; i++)
		if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {

			iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
			iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
			iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
			iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

			m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
		}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	UINT iTmp;
	int iLogSockH, iRet;

	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;

	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		wsprintf(g_cTxt, "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iGateServerPort);
		PutLogList(g_cTxt);

		m_bIsSubLogSockAvailable[iLogSockH] = true;
		if((m_iSubLogSockFailCount + m_iSubLogSockActiveCount) > MAXSUBLOGSOCK && m_iSubLogSockFailCount > 0) m_iSubLogSockFailCount--;
		break;

	case XSOCKEVENT_CONNECTIONESTABLISH:
		wsprintf(g_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
		PutLogList(g_cTxt);
		m_iCurSubLogSockIndex = iLogSockH;
		if(!m_bIsGameServerRegistered) bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		else bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVERSOCKET, NULL);
		m_bIsSocketConnected[iLogSockH] = true;
		m_iSubLogSockActiveCount++;
		m_iSubLogSockInitIndex++;
		break;

	case XSOCKEVENT_READCOMPLETE:
		OnSubLogRead(iLogSockH);
		break;

	case XSOCKEVENT_BLOCK:
		wsprintf(g_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(g_cTxt);
		break;

	case XSOCKEVENT_CONFIRMCODENOTMATCH:
	case XSOCKEVENT_MSGSIZETOOLARGE:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = false;

		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		if(m_iSubLogSockActiveCount == 0) m_bIsGameServerRegistered = false;
		wsprintf(g_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(g_cTxt);
		m_bIsSocketConnected[iLogSockH] = false;
		break;
	}
}





void CGame::OnSubLogRead(int iIndex)
{
	uint32 dwMsgSize;
	char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}
#ifdef TAIWANLOG
bool CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,bool bForceItemLog)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;
	if (pItem == NULL) return false;


	if (m_pClientList[iGiveH]->m_cCharName == NULL) return false;

	if (iAction == ITEMLOG_DUPITEMID) {

		if (m_pClientList[iGiveH] == NULL) return false;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return false;
		wsprintf(g_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
			pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
			m_pClientList[iGiveH]->m_cCharName);
		//	PutItemLogFileList(iGiveH,g_cTxt);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,g_cTxt);
		return true;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	switch (iAction) {
		case ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case ITEMLOG_GIVE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case ITEMLOG_DROP:
			wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_GET:
			wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		case ITEMLOG_CREATE:
			wsprintf(cTxt, "PC(%s)\tCreate\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		case ITEMLOG_MAKE:
			wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_DEPLETE:
			wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount , 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_SELL:
			wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		default:
			return false ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return true;
}


bool CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	char  cTxt[200];

	ZeroMemory(cTxt, sizeof(cTxt));

	switch (iAction) {

		case ITEMLOG_APPLY:
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tApply\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cLocation,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case ITEMLOG_CLOSECONN:
			if (cName == NULL) return false;
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tKicked\t \t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName, 
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY,cName);
			break ;

		case ITEMLOG_CREATEGUILD:
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tCreate Guild\t(%s)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_cGuildName );
			break ;


		case ITEMLOG_GUILDDISMISS: // guild 
			if (cName == NULL) return false;
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tGuild Dismiss\t(%s)", m_pClientList[iClientH]->m_cCharName,cName );
			break ;

		case ITEMLOG_BANGUILD:
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tRemove\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case ITEMLOG_JOINGUILD:
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tJoin\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;

		case ITEMLOG_REPAIR:
			if (cName == NULL) return false;
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_RESERVEFIGZONE:
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tReserve\t(%s)\t%s(%d %d)\t(%d)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cGuildName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iFightzoneNumber);
			break ;

		case ITEMLOG_SKILLLEARN:
		case ITEMLOG_MAGICLEARN:
			if (cName == NULL) return false; 
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_SPELLFIELD:
			if (cName == NULL) return false; 
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tSpell\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_SUMMONMONSTER:
			if (cName == NULL) return false;
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, cName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break ;
		case ITEMLOG_SUMMONPLAYER:
			if (cName == NULL) return false;
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tSummoned\t \t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY ,cName);
			break ;

		case ITEMLOG_SHUTUP:
			if (cName == NULL) return false;
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tShut up\t(%d)\t%s(%d %d)\tGM(%s)",m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iTimeLeft_ShutUp/20,
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY,cName);
			break ;

		case ITEMLOG_POISONED:
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)",m_pClientList[iClientH]->m_cCharName, 
				m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY);
			break; 

		case ITEMLOG_NEWGENDROP:
			if (pItem == NULL) return false;
			wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d %x)",cName, pItem->m_cName, pItem->m_dwCount,  
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute) ;
			break;

		default:
			return false;
	}

	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return true ;
}




#else  
bool CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,bool bForceItemLog)
{
	if (!pItem || !m_pClientList[iGiveH]->m_cCharName) 
		return false;

	if (!bForceItemLog) {
		if (!pItem->IsLogged() || iAction == ITEMLOG_RETRIEVE) 
			return false;
	}

	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));
	m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction)
	{
	case ITEMLOG_EXCHANGE:
		if (m_pClientList[iRecvH]->m_cCharName == NULL) return false;
		m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);
		wsprintf(cTxt, "PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s->%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName, cTemp1, cTemp2);
		break;

	case ITEMLOG_GIVE:
		if (m_pClientList[iRecvH]->m_cCharName == NULL) return false;
		m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);
		wsprintf(cTxt, "PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)\tIP(%s->%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName, cTemp1, cTemp2);
		break;

	case ITEMLOG_DROP:
		wsprintf(cTxt, "PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_GET:
		wsprintf(cTxt, "PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_MAKE:
		wsprintf(cTxt, "PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_DEPLETE:
		wsprintf(cTxt, "PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_BUY:
		iItemCount = iRecvH ;
		wsprintf(cTxt, "PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			iItemCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_SELL:
		wsprintf(cTxt, "PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_RETRIEVE:
		wsprintf(cTxt, "PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_MAILRETRIEVE:
		wsprintf(cTxt, "PC(%s)\tMail Retrieve\t%s(%d %d %d %d %x)\tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, 
			pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, cTemp1);
		break;

	case ITEMLOG_MAILSEND:
		wsprintf(cTxt, "PC(%s)\tMail Send\t%s(%d %d %d %d %x)\tRecvID(%u)\tIP(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, 
			pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, iRecvH, cTemp1);
		break;

	case ITEMLOG_DEPOSIT:
		wsprintf(cTxt, "PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_GWHDEPOSIT:
		wsprintf(cTxt, "PC(%s)\tGuild Deposit\t%s(%d %d %d %d %x)\tGuild(%s)\t \tIP(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cGuildName, cTemp1);
		break;

	case ITEMLOG_GWHRETRIEVE:
		wsprintf(cTxt, "PC(%s)\tGuild Retrieve\t%s(%d %d %d %d %x)\tGuild(%s)\t \tIP(%s)",m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cGuildName, cTemp1);
		break;

	case ITEMLOG_DUPITEMID:
		wsprintf(cTxt, "PC(%s)\tHaveDupItem\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_UPGRADEFAIL:
		wsprintf(cTxt, "PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	case ITEMLOG_UPGRADESUCCESS:
		wsprintf(cTxt, "PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)\t \tIP(%s)", m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
			pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
			m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, cTemp1);
		break;

	default:
		return false;
	}

	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return true;
}


bool CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	if(!pItem || !pItem->IsLogged()) return false;

	if(iAction != ITEMLOG_NEWGENDROP)
	{
		if( m_pClientList[iClientH] == NULL ) return false;
	}
	char  cTxt[200], cTemp1[120];
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	if( m_pClientList[iClientH] != NULL ) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
	case ITEMLOG_NEWGENDROP:
		if (pItem == NULL) return false;
		wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)",cName, pItem->m_cName, pItem->m_dwCount,  
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		break;
	case ITEMLOG_SKILLLEARN:
	case ITEMLOG_MAGICLEARN:
		if (cName == NULL) return false; 
		if (m_pClientList[iClientH] == NULL) return false;
		wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 
	case ITEMLOG_SUMMONMONSTER:
		if (cName == NULL) return false;
		if (m_pClientList[iClientH] == NULL) return false;
		wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break ;
	case ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == NULL) return false;
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, 
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	case ITEMLOG_REPAIR:
		if (cName == NULL) return false;
		if (m_pClientList[iClientH] == NULL) return false;
		wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	default:
		return false;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return true ;
}
#endif // #ifdef TAIWANLOG

bool CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{
	char  cTxt[200];

	ZeroMemory(cTxt, sizeof(cTxt));

	switch (iAction) {

		case CRUSADELOG_ENDCRUSADE:
			if (cName == NULL) return false;
			wsprintf(cTxt,"\tEnd Crusade\t%s",cName);
			break;

		case CRUSADELOG_SELECTDUTY :
			if (cName == NULL) return false;
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == NULL) return false;
			wsprintf(cTxt, "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,iData,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case CRUSADELOG_STARTCRUSADE:
			wsprintf(cTxt,"\tStart Crusade");
			break ;

		case CRUSADELOG_APOCALYPSE:
			wsprintf(cTxt,"\tStart Apocalypse");
			break ;
		default:
			return false;
	}

	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, NULL,cTxt);
	return true ;
}


bool CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	if ( m_pClientList[iVictumH] == NULL) return false ;

	switch (iAction) {

		case PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 

		case PKLOG_BYPLAYER:
			if ( m_pClientList[iAttackerH] == NULL) return false ;
			wsprintf(cTxt, "PC(%s)\tKilled by PC\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break;
		case PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == NULL) return false ;
			wsprintf(cTxt, "PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case PKLOG_BYENERMY:
			if ( m_pClientList[iAttackerH] == NULL) return false ;
			wsprintf(cTxt, "PC(%s)\tKilled by EN\t \t%s(%d %d)\tPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case PKLOG_BYNPC:
			if(pNPC==NULL) return false ;
			wsprintf(cTxt, "PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,pNPC);
			break; 
		case PKLOG_BYOTHER:
			wsprintf(cTxt, "PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnKnown", m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 
		default:
			return false;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iVictumH, NULL,cTxt);
	return true ;
}

bool CGame::_bCheckSubLogSocketIndex()
{
	int  iCnt;
	bool bLoopFlag;

	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = false;
	while (bLoopFlag == false) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == true)) 
			bLoopFlag = true;
		else m_iCurSubLogSockIndex++;

		if(m_iCurSubLogSockIndex >= MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

		iCnt++;
		if (iCnt >= MAXSUBLOGSOCK) {

			if (m_bOnExitProcess == false) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = true;
				m_dwExitProcessTime  = timeGetTime();

				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return false;
		}
	}

	return true;
}
/*bool CGame::_bCheckSubLogSocketIndex()
{
for(BYTE b = 0; b < MAXSUBLOGSOCK; b++){
if ((m_pSubLogSock[b] != NULL) && (m_bIsSubLogSockAvailable[b] == true)) break; 
if(b >= (MAXSUBLOGSOCK-1)){
if(m_bOnExitProcess == false){
m_cShutDownCode      = 3;
m_bOnExitProcess     = true;
m_dwExitProcessTime  = timeGetTime();
PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
}
return false;
}
}
m_iCurSubLogSockIndex++;
while(1){
if(m_iCurSubLogSockIndex >= MAXSUBLOGSOCK || m_iCurSubLogSockIndex == 0) m_iCurSubLogSockIndex = 1;
if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == true)) break;
else m_iCurSubLogSockIndex++;
}
return true;
}*/

bool CGame::_bDecodeBuildItemConfigFileContents(char *pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  i, iIndex = 0;
	
	class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:

				ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
				memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));

				cReadModeB = 2;
				break;

			case 2:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
				cReadModeB = 3;
				break;

			case 3:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
				cReadModeB = 12;
				break;


			case 12:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
				cReadModeB = 13;
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
				cReadModeB = 14;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
				cReadModeB = 15;
				break;

			case 15:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
				cReadModeB = 16;
				break;

			case 16:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);

				cReadModeB = 17;
				break;

			case 17:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);

				cReadModeB = 18;
				break;


			case 18:
				// 
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
				cReadModeB = 19;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);

				cReadModeB = 20;
				break;

			case 20:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);

				cReadModeB = 21;
				break;



			case 21:
				// m_iAverageValue
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);

				cReadModeB = 22;
				break;

			case 22:
				// m_iMaxSkill
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);

				cReadModeB = 23;
				break;

			case 23:
				// m_wAttribute
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;

				pItem = new class CItem;
				if (pItem->InitItemAttr(m_pBuildItemList[iIndex]->m_cName) == true) {

					m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;


					for (i = 0; i < 6; i++)
						m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

					iIndex++;
				}
				else {
					wsprintf(g_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
					PutLogList(g_cTxt);

					delete m_pBuildItemList[iIndex];
					m_pBuildItemList[iIndex] = NULL;

					delete[] pContents;
					return false;
				}
				delete pItem;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return true;
}

void CGame::BuildItemHandler(int iClientH, char *pData)
{
	char * cp, cName[21], cElementItemID[6];
	int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[MAXITEMS];
	class  CItem * pItem;
	bool   bFlag, bItemFlag[6];
	double dV1, dV2, dV3;
	uint32  dwTemp, dwTemp2;
	uint16   wTemp;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;

	bFlag = true;
	while (bFlag == true) {
		bFlag = false;
		for (i = 0; i <= 4; i++) 
			if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
				cElementItemID[i] = cElementItemID[i+1];
				cElementItemID[i+1] = -1;
				bFlag = true;
			}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = false;

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING];
	iResult = dice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
		return;
	}

	for (i = 0; i < 6; i++)
		if (cElementItemID[i] != -1) {
			if ((cElementItemID[i] < 0) || (cElementItemID[i] > MAXITEMS)) return;
			if(!m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] ||
				m_pClientList[iClientH]->m_pItemList[cElementItemID[i]]->m_disabled) return;
		}

		for (i = 0; i < MAXBUILDITEMS; i++)
			if (m_pBuildItemList[i] != NULL) {
				if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {


					if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING]) return;

					for (x = 0; x < MAXITEMS; x++) 
						if (m_pClientList[iClientH]->m_pItemList[x] != NULL) 
							iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
						else iItemCount[x] = 0;

						iMatch = 0;
						iTotalValue = 0;

						for (x = 0; x < 6; x++) {
							if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
								iMatch++;
							}
							else {
								for (z = 0; z < 6; z++) 
									if ((cElementItemID[z] != -1) && (bItemFlag[z] == false)) {

										if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
											(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
											(iItemCount[cElementItemID[z]] > 0)) {
												iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
												if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING]) {
													iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING])/2;
												}

												iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
												iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
												iMatch++;
												bItemFlag[z] = true;

												goto BIH_LOOPBREAK;
										}
									}
BIH_LOOPBREAK:;
							}
						}

						if (iMatch != 6) {
							SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
							return;
						}

						dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
						if (iTotalValue <= 0) 
							dV3 = 1.0f;
						else dV3 = (double)iTotalValue;
						dV1 = (double)(dV3/dV2)*100.0f;

						iTotalValue = (int)dV1;


						pItem = new class CItem;
						if (pItem->InitItemAttr(m_pBuildItemList[i]->m_cName) == false) {
							delete pItem;
							return;
						}

						pItem->m_dwAttribute |= 1;

						if (pItem->m_cItemType == ITEMTYPE_MATERIAL)
						{
							iTemp = dice(1, (iPlayerSkillLevel/2)+1) -1;
							pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;

							pItem->m_sTouchEffectType   = ITET_ID;
							pItem->m_sTouchEffectValue1 = dice(1,100000);
							pItem->m_sTouchEffectValue2 = dice(1,100000);
							pItem->m_sTouchEffectValue3 = timeGetTime();

						}
						else {

							dwTemp = pItem->m_dwAttribute;
							dwTemp = dwTemp & 0x0000FFFF;

							dwTemp2 = (uint16)m_pBuildItemList[i]->m_wAttribute;
							dwTemp2 = dwTemp2 << 16;

							dwTemp  = dwTemp | dwTemp2;
							pItem->m_dwAttribute = dwTemp;

							iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);



							if (iResultValue > 0) {
								dV2 = (double)iResultValue;
								dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
								dV1 = (dV2/dV3)*100.0f;
								pItem->m_sItemSpecEffectValue2 = (int)dV1;
							}
							else if (iResultValue < 0) {
								dV2 = (double)(iResultValue);
								dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
								dV1 = (dV2/dV3)*100.0f;
								pItem->m_sItemSpecEffectValue2 = (int)dV1;
							}
							else pItem->m_sItemSpecEffectValue2 = 0;


							dV2 = (double)pItem->m_sItemSpecEffectValue2;
							dV3 = (double)pItem->m_wMaxLifeSpan;
							dV1 = (dV2/100.0f)*dV3;

							iTemp  = (int)pItem->m_wMaxLifeSpan;
							iTemp += (int)dV1;


							pItem->m_sTouchEffectType   = ITET_ID;
							pItem->m_sTouchEffectValue1 = dice(1,100000);
							pItem->m_sTouchEffectValue2 = dice(1,100000);
							pItem->m_sTouchEffectValue3 = timeGetTime();

							if (iTemp <= 0) 
								wTemp = 1;
							else wTemp = (uint16)iTemp;

							if (wTemp <= pItem->m_wMaxLifeSpan*2) {
								pItem->m_wMaxLifeSpan = wTemp;
								pItem->m_sItemSpecEffectValue1 = (short)wTemp;
								pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
							}
							else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;


							pItem->m_cItemColor = 2;
						}

						bAddItem(iClientH, pItem);
						SendNotifyMsg(NULL, iClientH, NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); 

#ifdef TAIWANLOG

						_bItemLog(ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif

						for (x = 0; x < 6; x++)
							if (cElementItemID[x] != -1) {
								if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
									// ### BUG POINT!!!
									wsprintf(g_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
									PutLogFileList(g_cTxt);
								}
								else {
									iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
									if (iCount < 0) iCount = 0;
									SetItemCount(iClientH, cElementItemID[x], iCount);
								}
							}

							if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[SKILL_MANUFACTURING])
								CalculateSSN_SkillIndex(iClientH, SKILL_MANUFACTURING, 1);


							GetExp(iClientH, dice(2, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += dice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

							return;
				}
			}
}

void CGame::AdminOrder_EventSpell(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cMagicName[31]; 
	int    i, unused, magicID;
	bool disabling = false, toggling = false;
	CMagic * spell;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 12) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) return;
	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, token, 30);

	token = pStrTok->pGet();
	if (token != NULL){
		if (token[0] == '1') disabling = false;
		else if(token[0] == '0') disabling = true;
	} 
	else {
		toggling = true;
	}
		
	magicID = _iGetMagicNumber(cMagicName, &unused, &unused);
	if (magicID > -1) {
		spell = g_magicConfigList[magicID];
		bool *magicLimited = &(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_magicLimited[magicID]);
		if (toggling){
			*magicLimited = !(*magicLimited);
		} else {
			*magicLimited = disabling;
		}
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				if(*magicLimited && !m_pClientList[i]->IsGM() && m_pClientList[i]->m_cMagicEffectStatus[spell->m_sType] == spell->m_sValue[MAGICV_TYPE]){
					m_pClientList[i]->RemoveMagicEffect(spell->m_sType);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTSPELL, *magicLimited, magicID, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_EventArmor(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = false;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = true;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled;
	}

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled == false) { //Enable armor use
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				SendNotifyMsg(NULL, i, NOTIFY_EVENTARMOR, false, NULL, NULL, NULL, NULL);
			}
		}
	}
	else //Disable armor use
	{
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				if(!m_pClientList[i]->IsGM() && !m_pClientList[i]->IsDead()){
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ] != -1){
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_HEAD, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_HEAD ], false);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_BODY, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BODY ], false);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_ARMS, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_ARMS ], false);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_BOOTS, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BOOTS ], false);
					}
					if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_PANTS, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_PANTS ], false);
					}
					/*if ( m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ] != -1) {
						SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_BACK, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ], NULL, NULL);
						ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_BACK ], false);
						
					}*/ 
					SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTARMOR, true, NULL, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_EventSheild(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = false;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = true;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled;
	}

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled == false) { //Enable shield use
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				SendNotifyMsg(NULL, i, NOTIFY_EVENTSHIELD, false, NULL, NULL, NULL, NULL);
			}
		}
	}
	else //Disable shield
	{
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				if (!m_pClientList[i]->IsGM() && !m_pClientList[i]->IsDead() && m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ] != -1){
					SendNotifyMsg(NULL, i, NOTIFY_ITEMRELEASED, EQUIPPOS_LHAND, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ], NULL, NULL);
					ReleaseItemHandler(i, m_pClientList[i]->m_sItemEquipmentStatus[ EQUIPPOS_LHAND ], true);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTSHIELD, true, NULL, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_EventChat(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = false;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = true;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled;
	}

	for (i = 1; i < MAXCLIENTS; i++) {
		if(m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
			SendNotifyMsg(NULL, i, NOTIFY_EVENTCHAT, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled, NULL, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_EventParty(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = false;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = true;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled;
	}


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled == false) { //Enable
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
				SendNotifyMsg(NULL, i, NOTIFY_EVENTPARTY, false, NULL, NULL, NULL, NULL);
			}
		}
	}
	else //Disable
	{
		for (i = 1; i < MAXCLIENTS; i++)
		{
			if (m_pClientList[i] && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
			{
				if (m_pClientList[i]->GetParty() && !m_pClientList[i]->IsGM())
				{
					partyMgr.DeleteParty( m_pClientList[i]->GetParty()->GetID() );
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTPARTY, true, NULL, NULL, NULL, NULL);
			}
		}
	}
}


void CGame::AdminOrder_EventReset(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for(i = 0; i < MAXMAGICTYPE; i++)
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_magicLimited[i] = false;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPartyDisabled = false;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isShieldDisabled = false;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isArmorDisabled = false;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isChatDisabled = false;
	
	for (i = 1; i < MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) {
			if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn) m_pClientList[i]->RemoveMagicEffect(MAGICTYPE_CONFUSE);
			SendNotifyMsg(NULL, i, NOTIFY_EVENTRESET, NULL, NULL, NULL, NULL, NULL);
		}
	}

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = false;
}

void CGame::AdminOrder_EventTP(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i, j;
	bool   enabling = true;


	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	bool donateEvent = (token && token[0] == '1') ? true : false;

	if(m_pClientList[iClientH]->m_iAdminUserLevel < 4)
		donateEvent = false;

	for(i = 0; i < MAXTELEPORTLIST; i++)
		if(m_pTeleportConfigList[i] != NULL && m_pTeleportConfigList[i]->m_adminCreated == true 
			&& strcmp(m_pTeleportConfigList[i]->m_cTargetMap, m_pClientList[iClientH]->m_cMapName) == 0)
				enabling = false;

	if (enabling) 
	{
		//Enable teleports
		for(j = 1; j < MAXSIDES; j++){
			for(i = 0; i < MAXTELEPORTLIST; i++)
			{
				if(m_pTeleportConfigList[i] == NULL)
				{ 
					m_pTeleportConfigList[i] = new class CTeleport;
					m_pTeleportConfigList[i]->m_bNetural = false;
					strcpy(m_pTeleportConfigList[i]->m_cNpcname, "William");
					wsprintf(m_pTeleportConfigList[i]->m_cSourceMap, "cityhall_%d", j);
					strcpy(m_pTeleportConfigList[i]->m_cTargetMap, m_pClientList[iClientH]->m_cMapName);
					m_pTeleportConfigList[i]->m_iX = -1;
					m_pTeleportConfigList[i]->m_iY = -1;
					m_pTeleportConfigList[i]->m_iSide = j;
					m_pTeleportConfigList[i]->m_iMinLvl = 0;
					m_pTeleportConfigList[i]->m_iMaxLvl = MAXLEVEL;	
					m_pTeleportConfigList[i]->m_adminCreated = true;
					m_pTeleportConfigList[i]->m_donateEvent = donateEvent;
					m_pTeleportConfigList[i]->m_cost = donateEvent ? 5 : 0;
					break;
				}
			}
		}
		
		while(CClient * player = objMgr.GetPlayers())
			player->Notify(NULL, NOTIFY_EVENTTP, 1, donateEvent, NULL, NULL);

		if(donateEvent && m_donateEventHolder == -1)
		{
			m_donateEventHolder = m_pClientList[iClientH]->m_charID;
			m_donateEventPot = 0;
		}
	}
	else //Disable teleports
	{
		for(j = 1; j < MAXSIDES; j++){
			for(i = 0; i < MAXTELEPORTLIST; i++)
			{
				if(m_pTeleportConfigList[i] != NULL && m_pTeleportConfigList[i]->m_adminCreated == true 
					&& strcmp(m_pTeleportConfigList[i]->m_cTargetMap, m_pClientList[iClientH]->m_cMapName) == 0){
					delete m_pTeleportConfigList[i];
					m_pTeleportConfigList[i] = NULL;
					break;
				}
			}
		}

		while(CClient * player = objMgr.GetPlayers())
			player->Notify(NULL, NOTIFY_EVENTTP, 0, donateEvent, NULL, NULL);
	}
}

void CGame::AdminOrder_EventIllusion(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)	return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (token[0] == '1'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = true;
		}else if (token[0] == '0'){
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = false;
		}
	} 
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn = !m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn;
	}


	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_isPermIllusionOn) { //Enable permanent illusion
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex){
				if(!m_pClientList[i]->IsGM()){
					m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] = 3; //Illusion
					//m_pClientList[i]->SetStatusFlag(STATUS_ILLUSION, true);
					SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTON, MAGICTYPE_CONFUSE, 3, iClientH, NULL);
				}
				SendNotifyMsg(NULL, i, NOTIFY_EVENTILLUSION, true, NULL, NULL, NULL, NULL);
			}
		}
	}
	else // Disable permanent illusion
	{
		for (i = 1; i < MAXCLIENTS; i++) {
			if (m_pClientList[i] != NULL && m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex){
				if(!m_pClientList[i]->IsGM())
					m_pClientList[i]->RemoveMagicEffect(MAGICTYPE_CONFUSE);

				SendNotifyMsg(NULL, i, NOTIFY_EVENTILLUSION, false, NULL, NULL, NULL, NULL);
			}
		}
	}
}


void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if ( memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 4) != 0 ) {
		return;
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();


	if (token != NULL) {
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = true;

			for (i = 1; i < MAXCLIENTS; i++) 
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
					SendNotifyMsg(NULL, i, NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = false;


			for (i = 1; i < MAXCLIENTS; i++) 
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
					SendNotifyMsg(NULL, i, NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);
		}
	}

}

void CGame::AdminOrder_ToggleInvincible(int iClientH)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4)	return;

	m_pClientList[iClientH]->m_GMFlags ^= GMFLAG_INVINCIBLE;

	m_pClientList[iClientH]->Notify(NULL, NOTIFY_ADMININFO);
}

void CGame::AdminOrder_ToggleNoAggro(int iClientH)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4)	return;

	m_pClientList[iClientH]->m_GMFlags ^= GMFLAG_NOAGGRO;
	
	m_pClientList[iClientH]->Notify(NULL, NOTIFY_ADMININFO);
}

void CGame::AdminOrder_ToggleEthereal(int iClientH)
{
	CClient * player = m_pClientList[iClientH];
	if (!player->IsGM())	return;
	
	// Ethereal flags prevent any message to be sent to near client,
	// so they must be set at the appropriate time
	if(player->IsEthereal())
	{
		player->m_GMFlags ^= GMFLAG_ETHEREAL;		
		RequestTeleportHandler(iClientH, 2, player->m_cMapName, player->m_sX, player->m_sY);
	} else {
		m_pMapList[player->m_cMapIndex]->ClearOwner(iClientH, OWNERTYPE_PLAYER, player->m_sX, player->m_sY);
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_EVENT_REJECT, NULL, NULL, NULL);

		player->m_GMFlags ^= GMFLAG_ETHEREAL;
	}

	m_pClientList[iClientH]->Notify(NULL, NOTIFY_ADMININFO);
}


void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256],* cp; 
	uint16 * wp ;
	int    iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {

		if (token == NULL) 
			iTime = 0;
		else iTime = atoi(token);

		if (iTime < 0) iTime = 0;

		m_sForceRecallTime = iTime ;

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;

		wp = (uint16 *)cp;
		*wp = iTime ;
		cp += 2;

		bStockMsgToGateServer(cBuff, 3);

		wsprintf(g_cTxt,"(!) Admin Set Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(g_cTxt) ;
	}

	return ;
}

void CGame::AdminOrder_UnsummonAll(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 5) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	
	for (i = 1; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			//0.3-> kill summoned monsters only, by Elimos
			if ((m_pNpcList[i]->m_bIsSummoned == true) && (m_pNpcList[i]->m_bIsKilled == false)) 
				NpcKilledHandler(iClientH, OWNERTYPE_PLAYER, i, 0);
		}
}



void CGame::AdminOrder_UnsummonBoss(int iClientH)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 5) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for (i = 1; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			if (((m_pNpcList[i]->m_sType == 31) || (m_pNpcList[i]->m_sType == 49)  || (m_pNpcList[i]->m_sType == 45)  || (m_pNpcList[i]->m_sType == 47) || (m_pNpcList[i]->m_sType == 50) || (m_pNpcList[i]->m_sType == 52)) && 
				(m_pNpcList[i]->m_bIsKilled == false)) {
					m_pNpcList[i]->m_bIsSummoned = true ; 
					NpcKilledHandler(iClientH, OWNERTYPE_PLAYER, i, 0);
		}
	}
}

char CGame::_cGetSpecialAbility(int iKindSA)
{
	char cSA;

	switch (iKindSA) {
	case 1: 
		switch (dice(1,2)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		}
		break;

	case 2:
		switch (dice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 3:
		switch (dice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		case 4: cSA = 6; break;
		}
		break;

	case 4:
		switch (dice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		}
		break;

	case 5:
		switch (dice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		case 4: cSA = 8; break;
		}
		break;

	case 6:
		switch (dice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 7:
		switch (dice(1,3)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		}
		break;

	case 8:
		switch (dice(1,5)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		case 4: cSA = 3; break;
		case 5: cSA = 8; break;
		}
		break;

	case 9:
		cSA = dice(1,8);
		break;

	case 10:
		cSA = 1;
		break;
	}

	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cNpcName[256], cWaypoint[11], cSA; 
	int    pX, pY, iNum;
	bool   bSummoned, isBerserked;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();

	if (token != NULL) 
		iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;

	bSummoned = false;
	token = pStrTok->pGet();
	if (token != NULL)
		if (token[0]=='1')bSummoned = true;

	token = pStrTok->pGet();
	if (token != NULL){
		cSA = atoi(token);
		if(cSA < 0 || cSA > 10){
			cSA = 0;
		}
	} else cSA = 0;

	isBerserked = false;
	token = pStrTok->pGet();
	if (token != NULL && token[0]=='1') {
		isBerserked = true;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	wsprintf(g_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(g_cTxt);

	wsprintf(g_cTxt, "GM Order(%s): Summon NPC(%s)-Count(%d)",m_pClientList[iClientH]->m_cCharName, cNpcName, iNum);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

	CNpc * master = CreateNpc( cNpcName, m_pClientList[iClientH]->m_cMapIndex, cSA, MOVETYPE_RANDOM, &pX, &pY, (Side)-1, cWaypoint, NULL, NULL, false, bSummoned, isBerserked, true);
	
	if(!master)
	{
		return;
	}

	for(int j = 0; j < (iNum - 1); j++) 
	{
		CNpc * slave = CreateNpc( cNpcName, m_pClientList[iClientH]->m_cMapIndex, cSA, 
			MOVETYPE_RANDOM, &pX, &pY, (Side)-1, cWaypoint, NULL, NULL, false, bSummoned, isBerserked);

		if(!slave)
			break;

		slave->Follow( master );
	}

}


void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * cp, * token, cName[11], cBuff[256];
	uint16   * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {

		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (strlen(token) > 10)
			memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));


		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {

				if (i == iClientH) {
					return;
				}

#ifdef TAIWANLOG
				short sX = 0,sY = 0 ;
				char cMapName[22] ; 

				ZeroMemory(cMapName,sizeof(cMapName)) ;

				sX = m_pClientList[i]->m_sX ;
				sY = m_pClientList[i]->m_sY ;
				strcpy(cMapName, m_pClientList[i]->m_cMapName) ;

				m_pClientList[i]->m_sX = m_pClientList[iClientH]->m_sX;
				m_pClientList[i]->m_sY = m_pClientList[iClientH]->m_sY;
				strcpy(m_pClientList[i]->m_cMapName, m_pClientList[iClientH]->m_cMapName) ;

				_bItemLog(ITEMLOG_SUMMONPLAYER, i, m_pClientList[iClientH]->m_cCharName,NULL) ;

				m_pClientList[i]->m_sY = sY ; 
				m_pClientList[i]->m_sX = sX ;

				strcpy(m_pClientList[i]->m_cMapName,cMapName) ;

#endif 

				RequestTeleportHandler(i, 2, m_pClientList[iClientH]->m_cMapName ,m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
				return;
			}

			wsprintf(g_cTxt, "GM Order(%s): PC(%s) Summoned to (%s)",m_pClientList[iClientH]->m_cCharName, cName,m_pClientList[iClientH]->m_cMapName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);

			ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_SUMMONPLAYER;
			cp++;

			memcpy(cp, cName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
			cp += 10;

			wp = (uint16 *)cp;
			*wp = m_pClientList[iClientH]->m_sX ;
			cp += 2;

			wp = (uint16 *)cp;
			*wp = m_pClientList[iClientH]->m_sY;
			cp += 2;


			bStockMsgToGateServer(cBuff, 25);

			return;
	}

}

void CGame::AdminOrder_CleanMap(int iClientH, char * pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cMapName[11], cBuff[256];
	bool bFlag = false;	//Used to check if we are on the map we wanna clear
	int i;
	CItem *pItem;
	short sRemainItemSprite, sRemainItemSpriteFrame, dX, dY;
	char cRemainItemColor, len;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);

		for (i = 0; i < MAXMAPS; i++)	//Enum all maps
			if (m_pMapList[i] != NULL) {	//Is allocated map
				if (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) {	//is map same name
					bFlag = true; //Set flag
					//Get X and Y coords
					int m_x = m_pMapList[i]->m_sSizeX;
					int m_y = m_pMapList[i]->m_sSizeY;
					for(int j = 1; j < m_x; j++)
						for(int k = 1; k < m_y; k++){
							do {	//Delete all items on current tile
								pItem = m_pMapList[i]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
								if (pItem != NULL) {
									delete pItem;	//Delete item;
								}
							} while(pItem != NULL);
						}
					break;	//Break outo f loop
				}
			}

		if (!bFlag) {	//Notify GM he has to be on the map he clears
		}
		else{	//Notify GM that all items have been cleared
			for(int i = 1; i < MAXCLIENTS; i++){
				if (m_pClientList[i] != NULL) {
				len = strlen(cMapName);
				if(len > 10) len = 10;
				if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cMapName, len) != 0) return;
				dX = m_pClientList[i]->m_sX;
				dY = m_pClientList[i]->m_sY;
				ZeroMemory(cMapName,sizeof(cMapName));
				strcpy(cMapName, m_pClientList[i]->m_cMapName);
				RequestTeleportHandler(i, 2, cMapName, dX, dY);
				}
			}
		}
	}

	return;
}

void CGame::AdminOrder_DisconnectAll(int iClientH)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 5) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	_iForcePlayerDisconect(MAXCLIENTS);
}

void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem = NULL;
	char  cItemName[21], cTemp[20];
	bool  bIsGold;
	int   iGenLevel = 0, iResult, iItemID = 0;
	double dTmp1, dTmp2, dTmp3;
	uint32 dwValue;
	SYSTEMTIME SysTime;

	CNpc *& npc = m_pNpcList[iNpcH];
	if (!npc) return;

	if (cAttackerType != OWNERTYPE_PLAYER || (npc->m_bIsSummoned == true)) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = false;

	switch (npc->m_sType) {
	case NPC_GUARD:
	case NPC_DUMMY:
	case NPC_AGT:
	case NPC_CGT:
	case NPC_DT:
		return;
	}

	if( NpcDeadItemGeneratorWithItemEvent(iNpcH, sAttackerH, cAttackerType) == true)
		return;

	int iItemprobability = 4500;

	if(m_pClientList[sAttackerH]->GetPartyStatus() == PS_INPARTY)
	{
		iItemprobability += 650;
	}

	if(m_pClientList[sAttackerH]->HasPartyHuntBonus())
	{
		iItemprobability += 650;
	}

	if(m_pClientList[sAttackerH]->IsHeldWinner())
	{
		iItemprobability += 300;
	}

	if(m_eventWinner[ET_CAPTURE] == m_pClientList[sAttackerH]->m_side)
	{
		iItemprobability += 300;
	}

	if(npc->IsHighlyTrained())
		iItemprobability += 1500; 

	CClient * killer = npc->GetKiller();
	if(killer)
		iItemprobability += 1000 * (1 - killer->GetDropFactor());

	if (iItemprobability > dice(1,10000)) 
	{

		if (dice(1,10000) <= 3400
			- ((killer && killer->HasPartyHuntBonus()) ? 300 : 0)
			- (npc->IsHighlyTrained() ? 700 : 0)
			- ( (killer != NULL) ? 300*2 * ( 1 - killer->GetDropFactor() ) : 0) )
		{
			strcpy(cItemName, "Gold");

			pItem = new class CItem;
			if (pItem->InitItemAttr(cItemName) == false) {
				delete pItem;
				return;
			}
			// Gold ratio
			if(npc->dwGoldDropValue == 0) {
				delete pItem;
				return;
			}
			else if(npc->dwGoldDropValue <= 4) pItem->m_dwCount = dice(1, npc->dwGoldDropValue);
			else
				switch(dice(1,2)){
				case 1:
					pItem->m_dwCount = (uint32)(npc->dwGoldDropValue + dice(1, npc->dwGoldDropValue/5));
					break;

				case 2:
					pItem->m_dwCount = (uint32)(npc->dwGoldDropValue - dice(1, npc->dwGoldDropValue/5));
					break;
			}

			//if npc had an attribute, double gold
			if(npc->m_cSpecialAbility != NULL) pItem->m_dwCount *= 2;

			// check for items that give +gold%
			if ((cAttackerType == OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}
		}
		else {

			if((npc->m_sType == NPC_HELLCLAW || npc->m_sType == NPC_TIGERWORM) && drops.HasPrimaryDrop(npc))
			{
				iItemID = drops.Roll(npc);

				if(iItemID == ITEM_NONE) return;

				pItem = new class CItem;
				if (!pItem->InitItemAttr(iItemID)) {
					delete pItem;
					return;
				}
			}else if (dice(1,10000) <= 8750 
				- ((killer && killer->HasPartyHuntBonus()) ? 200 : 0)
				- (npc->IsHighlyTrained() ? 900 : 0)
				- ((killer != NULL) ? 200*2 * ( 1 - killer->GetDropFactor() ) : 0))
			{
				// pots/zem/stones/etc...
				int reduction = npc->IsHighlyTrained() ? 5000 : 0;
				reduction += (killer != NULL) ? 1750*2 * ( 1 - killer->GetDropFactor() ) : 0;
				reduction += (m_pClientList[sAttackerH]->HasPartyHuntBonus()) ? 1500 : 0;

				iResult = dice(1,10000 - reduction) + reduction; 
				if ((iResult >= 1) && (iResult <= 4000)) dwValue = 1;
				else if ((iResult >= 4000) && (iResult <= 9600)) dwValue = 2;
				else if ((iResult >= 9600) && (iResult <= 9950)) dwValue = 3;
				else if ((iResult >= 9950) && (iResult <= 10000)) dwValue = 4; 

				switch (dwValue) 
				{
				case 1: 
					if(npc->GetGenLevel() < 3)
					{
						iItemID = ITEM_BIGGREENPOTION;
						break;
					}
					// case jump
				case 2: 
					if(dice(1,2) == 1)
						iItemID = ITEM_BIGBLUEPOTION;
					else
						iItemID = ITEM_BIGREDPOTION; 
					break; 
				case 3: 
					iItemID = ITEM_POWERGREENPOTION;
					break; 
				case 4:
					switch (dice(1,8)) 
					{
					case 1:
					case 2: 
						iItemID = ITEM_ZEM;
						break;
					case 3:
					case 4: 
					case 5: 
					case 6: 
						iItemID = ITEM_SUPERGREENPOTION;
						break;
					case 7:
					case 8: 
						switch (dice(1,8)) 
						{ 
						case 1: 
						case 2: 
						case 3:
						case 4:
						case 5:
							iItemID = ITEM_BIGBLUEPOTION;
							break;
						case 6:
							iItemID = ITEM_STONEOFXELIMA;
							break;
						case 7:
							iItemID = ITEM_STONEOFMERIEN; 
							break;
						case 8:
							break;
						}
					}
				}

				pItem = new class CItem;
				if (pItem->InitItemAttr(iItemID) == false) {
					delete pItem;
					return;
				}
			}else{
				iGenLevel = npc->GetGenLevel(); 

				if (iGenLevel == 0) return;

				if(drops.HasPrimaryDrop(npc))
				{
					iItemID = drops.Roll(npc);

					if(iItemID == ITEM_NONE) return;
				} else if (dice(1,12000) <= 8000) {
					// weapons
					if (dice(1,10000) <= 7950) {
						// regular
						switch (iGenLevel) {
						case 1:
							switch (dice(1,3)) {
							case 1: iItemID = 1; break;   // Dagger
							case 2: iItemID = 8; break;   // ShortSword
							case 3: iItemID = 59; break;  // LightAxe
							}
							break;

						case 2:
							switch (dice(1,6)) {
							case 1: iItemID = 12; break;  //MainGauche
							case 2: iItemID = 15; break;  //Gradius
							case 3: iItemID = 65; break;  //SexonAxe
							case 4: iItemID = 62; break;  //Tomahoc
							case 5: iItemID = 23; break;  //Sabre
							case 6: iItemID = 31; break;  //Esterk
							}
							break;

						case 3: 
							switch (dice(1,4)) {
							case 1: iItemID = 17; break;  //LongSword
							case 2: iItemID = 68; break;  //DoubleAxe
							case 3: iItemID = 23; break;  //Sabre
							case 4: iItemID = 31; break;  //Esterk
							}
							break;

						case 4: 
							switch (dice(1,5)) {
							case 1: iItemID = 23; break;   //Sabre
							case 2: iItemID = 25; break;   //Scimitar
							case 3: iItemID = 28; break;   //Falchion
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							}
							break;

						case 5:
							switch (dice(1,3)) {
							case 1: iItemID = 31; break;   //Esterk
							case 2: iItemID = 34; break;   //Rapier
							case 3: iItemID = 71; break;   //WarAxe
							}
							break;

						case 6:
							switch (dice(1,5)) {
							case 1: iItemID = 50; break;   //GreatSword
							case 2: iItemID = 54; break;   //Flameberge
							case 3: iItemID = 46; break;   //Claymore
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							}
							break;

						case 7:
							switch (dice(1,4)) {
							case 1: iItemID = 50; break;   //GreatSword
							case 2: iItemID = 54; break;   //Flameberge
							case 3: iItemID = 31; break;   //Esterk
							case 4: iItemID = 34; break;   //Rapier
							}
							break;

						case 8:
							switch (dice(1,7)) {
							case 1: iItemID = 50; break;   //GreatSword
							case 2: iItemID = 54; break;   //Flameberge
							case 3: iItemID = 560; break;  //BattleAxe
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							case 6: iItemID = 55; break;   //Flameberge+1
							case 7: iItemID = 615; break;  //GiantSword
							}
							break;

						case 9: // Mountain-Giant
							switch( dice(1, 6) ) {
							case 1: iItemID = 23; break;   //Sabre
							case 2: iItemID = 25; break;   //Scimitar
							case 3: iItemID = 28; break;   //Falchion
							case 4: iItemID = 31; break;   //Esterk
							case 5: iItemID = 34; break;   //Rapier
							case 6: iItemID = 760; break;  //Hammer
							default: break;
							}
							break;

						case 10: // Ettin
							switch( dice(1, 5) ) {
							case 1: iItemID = 31; break;   //Esterk
							case 2: iItemID = ITEM_GIANTSWORD; break;
							case 3: iItemID = 760; break;  //Hammer
							case 4: iItemID = 761; break;  //BattleHammer
							default: break;
							}
							break;


						}
					}
					else {
						// wands
						switch (iGenLevel) {
						case 1:	break;
						case 2:
						case 3:	iItemID = 258; break;  // MagicWand(MS0)
						case 4:
						case 5:
						case 6: iItemID = 257; break;  // MagicWand(MS10)
						case 7:
						case 8:	iItemID = 256; break;  // MagicWand(MS20)
						}
					}
				}
				else {
					// armors
					switch (dice(1, iGenLevel)) {
					case 1:
					case 2:
						switch (dice(1,2)) {
						case 1: iItemID = 79; break; // WoodShield
						case 2: iItemID = 81; break; // TargeShield
						}
						break;

					case 3:
						iItemID = 81;  break;   // TargeShield
						break;

					case 4:
						switch (dice(1,5)) {
						case 1: iItemID = 454; break; // Hauberk(M)
						case 2: iItemID = 472; break; // Hauberk(W)
						case 3: iItemID = 461; break; // ChainHose(M)
						case 4: iItemID = 482; break; // ChainHose(W)
						case 5: iItemID = 83;  break; // BlondeShield
						}
						break;

					case 5:
						switch (dice(1,5))
						{
						case 1: iItemID = 455; break; // LeatherArmor(M)
						case 2: iItemID = 475; break; // LeatherArmor(W)
						case 3: iItemID = 84;  break; // IronShield
						case 4:
							switch (dice(1,2))
							{
							case 1: iItemID = 600; break; // Helm(M)
							case 2: iItemID = 602; break; // Helm(W)
							}
							break;
						case 5:
							switch (dice(1,2))
							{
							case 1: iItemID = 601; break; // FullHelm(M)
							case 2: iItemID = 603; break; // FullHelm(W)
							}
							break; 
						}
						break;

					case 6:
						switch (dice(1,4)) 
						{
						case 1: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 456; break; // ChainMail(M)
							case 2: iItemID = 476; break; // ChainMail(W)
							}
							break;
						case 2: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 85; break; // LagiShield
						case 4:
							switch(dice(1,2))
							{
							case 1:
								switch (dice(1,2))
								{
								case 1: iItemID = ITEM_WIZARD_CAP_M; break;
								case 2: iItemID = ITEM_WIZARD_CAP_W; break;
								}
								break;
							case 2:
								switch (dice(1,2))
								{
								case 1: iItemID = ITEM_WINGS_HELM_M; break;
								case 2: iItemID = ITEM_WINGS_HELM_W; break;
								}
								break;
							}
							break; 
						}
						break;

					case 7:
						switch (dice(1,5)) 
						{
						case 1: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 457; break; // ScaleMail(M)
							case 2: iItemID = 477; break; // ScaleMail(W)
							}
							break;
						case 2: 
							switch (dice(1,2)) 
							{
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 86; break; // KnightShield
						case 4: iItemID = 87; break; // TowerShield
						case 5:
							switch (dice(1,2)) 
							{
							case 1:
								switch (dice(1,2))
								{
								case 1: iItemID = ITEM_WIZARD_HAT_M; break;
								case 2: iItemID = ITEM_WIZARD_HAT_W; break;
								}
								break;
							case 2:
								switch (dice(1,2))
								{
								case 1: iItemID = ITEM_HORNED_HELM_M; break;
								case 2: iItemID = ITEM_HORNED_HELM_W; break;
								}
								break; 
							}
							break;
						}
						break;

					case 8:	iItemID = 402; break; 
					}
				}

				if(!iItemID)
					return;

				pItem = new class CItem;
				if (pItem->InitItemAttr(iItemID) == false) {
					delete pItem;
					return;
				}

				if( bCheckInItemEventList(iItemID, iNpcH) == true ) {
					delete pItem;
					return;
				}
			}
		}

		pItem->InitStats( npc->GetGenLevel() );


		pItem->m_sTouchEffectType   = ITET_ID;
		pItem->m_sTouchEffectValue1 = dice(1,100000);
		pItem->m_sTouchEffectValue2 = dice(1,100000);
#ifdef LOGTIME
		pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		//		wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
		wsprintf(cTemp, "%d%02d%",  (short)SysTime.wMonth, (short)SysTime.wDay);

		pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif

		if(m_pMapList[ npc->m_cMapIndex ]->iCheckItem(
			npc->m_sX, npc->m_sY) == ITEMTYPE_RELIC)
		{
			delete pItem;
		}
		else
		{
			m_pMapList[ npc->m_cMapIndex ]->bSetItem(npc->m_sX, 
				npc->m_sY, 
				pItem);


			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, npc->m_cMapIndex,
				npc->m_sX, npc->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

			_bItemLog(ITEMLOG_NEWGENDROP, 0, npc->m_cNpcName, pItem);

			AddGroundItem(pItem, npc->m_sX, npc->m_sY, npc->m_cMapIndex, TILECLEANTIME);
		}
	}
} 


/*
; mapdata  
;item-event = index	item_name	amount	TotalNumber	month	day		type	mob_list[Max:5]
;	type = 0 :       .
;	       1 : Item Event       .

item-event = 	1		1		10			11		1		0		Cannibal-Plant Ettin EOL
item-event = 	2		1		10			11		1		0		Giant-Frog Scorpion EOL
*/
bool CGame::NpcDeadItemGeneratorWithItemEvent(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem;
	char  cTemp[20];
	int   i, j, iT1, iT2, iT3;
	int	iNumMob;
	SYSTEMTIME SysTime;


	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{
		GetLocalTime(&SysTime);
		for ( i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++ )
			if (
				( SysTime.wMonth == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iMonth) &&
				( SysTime.wDay   == m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iDay) &&

				( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum )
				)
			{

				iNumMob = m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iNumMob;


				for( j=0; j<iNumMob; j++) {
					if( strcmp(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cMob[j], m_pNpcList[iNpcH]->m_cNpcName) == 0)
						break;
				}

				if( j == iNumMob )
					continue;

				if (SysTime.wHour < 12 ) {
					if(dice(1,9000) != 6433)
						continue;
				} else if (SysTime.wHour < 18 ) {
					if(dice(1,3000) != 1433)  
						continue;
				} 


				iT1 = 1440 / m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iTotalNum;
				iT2 = iT1 * m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum;
				iT3 = (SysTime.wHour*60) + SysTime.wMinute;


				if ( (iT1 / 2) > iT3 )
					continue;

				if ( ((iT2 <= iT3) && (iT3 <= iT2 + iT1)) || (iT2+iT1 < iT3) ) {

					int	iT4 = iT1 / 4;
					if( (iT4 > 10) && dice(1, iT4) != 5 )
						continue;

					pItem = new class CItem;
					if (pItem->InitItemAttr(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName) == false) {
						delete pItem;
						pItem = NULL;
					}
					else {

						pItem->m_sTouchEffectType   = ITET_ID;
						pItem->m_sTouchEffectValue1 = dice(1,100000);
						pItem->m_sTouchEffectValue2 = dice(1,100000);

#ifdef LOGTIME
						pItem->m_sTouchEffectValue3 = timeGetTime();
#else 
						ZeroMemory(cTemp, sizeof(cTemp));
						//					wsprintf(cTemp, "%d%02d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay,(short) SysTime.wHour);
						wsprintf(cTemp, "%d%02d",  (short)SysTime.wMonth, (short)SysTime.wDay);
						pItem->m_sTouchEffectValue3 = atoi(cTemp);
#endif


						/*
						.			if( pItem->m_sIDnum >= 651 &&  pItem->m_sIDnum <= 655 )
						{
						if(  SysTime.wYear == 2002 && SysTime.wMonth == 11 && (SysTime.wDay >= 1 && SysTime.wDay <=7 ) )
						pItem->m_sItemSpecEffectValue2 = 113; 
						}
						*/ 


						m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX,
							m_pNpcList[iNpcH]->m_sY,
							pItem);


						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
							m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
							pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

						_bItemLog(ITEMLOG_NEWGENDROP, 0, m_pNpcList[iNpcH]->m_cNpcName, pItem);
						wsprintf(g_cTxt,"Event Item (%s)",pItem->m_cName) ;
						PutLogFileList(g_cTxt, DEBUG_LOGFILE);

						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iCurNum++;

						return true;
					}

					// return false;
				}
			}
	} 

	return false;
} // NpcDeadItemGeneratorWithItemEvent


bool CGame::bCheckInItemEventList(int iItemID, int iNpcH)
{
	int		i;
	char	cItemName[21];

	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents != NULL)
	{

		for (i = 0; i < MAXITEMTYPES; i++ )
		{
			if( m_pItemConfigList[i] == NULL )
				continue;

			if( m_pItemConfigList[i]->m_sIDnum == iItemID ) {
				strcpy(cItemName, m_pItemConfigList[i]->m_cName);
				break;
			}
		}

		for (i = 0; i < m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalItemEvents; i++)
		{
			if( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].iType != 0 )
				continue;

			if( strcmp( m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stItemEventList[i].cItemName, cItemName) == 0 )
				return true;
		}
	}

	return false;
} // bCheckInItemEventList()


bool CGame::_bDecodeDupItemIDFileContents(char *pData, uint32 dwMsgSize)
{
	char * pContents, * token, cTxt[120];
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iIndex = 0;
	

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(pContents, seps));
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
			case 1:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				if (m_pDupItemIDList[atoi(token)] != NULL) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
					delete[] pContents;
					return false;
				}
				m_pDupItemIDList[atoi(token)] = new class CItem;
				iIndex = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 3;
				break;

			case 3:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_wPrice
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pDupItemIDList[iIndex]->m_wPrice = (uint16)atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}

		}
		token = pStrTok->pGet();
	}

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return false;
	}

	wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return true;
}

bool CGame::_bCheckDupItemID(CItem *pItem)
{
	int i;

	for (i = 0; i < MAXDUPITEMID; i++)
		if (m_pDupItemIDList[i] != NULL) {
			if ((pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
				(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
				(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) &&
				(pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3) ) {

					pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
					return true;
			}
		}

		return false;
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
	char * cp, cData[120];
	int  * ip, iRet, iClientSize;
	uint32 * dwp;
	uint16  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		cp = new char[m_dwNoticementDataSize + 2 + INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + INDEX2_MSGTYPE + 2);
		memcpy((cp + INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);

		dwp  = (uint32 *)(cp + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (uint16 *)(cp + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + INDEX2_MSGTYPE + 2);

		delete[] cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));

		dwp  = (uint32 *)(cData + INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
		*wp  = MSGTYPE_CONFIRM;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
}

void CGame::_bDecodeNoticementFileContents(char *pData, uint32 dwMsgSize)
{
	char * cp;

	cp = (pData);

	if (m_pNoticementData != NULL) {
		delete m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(g_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(g_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, uint32 dwMsgSize)
{
	int * ip, i, iLevel;
	char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {

			if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
				wsprintf(g_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
				PutLogList(g_cTxt);
				DeleteClient(i, false, true);
				return;
			}
		}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
	int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
	short sOwnerH;
	char  cOwnerType;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;

	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; 

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
		for (iY = dY - iRange; iY <= dY + iRange; iY++) {
			sOwnerH = NULL;
			if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
				m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

			if (sOwnerH != NULL) {
				switch (cOwnerType) {
			case OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) break;
				break;

			case OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				iTamingLevel = 10;
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 10:
				case 16: iTamingLevel = 1; break;
				case 22: iTamingLevel = 2; break;
				case 17:
				case 14: iTamingLevel = 3; break;
				case 18: iTamingLevel = 4; break;   
				case 11: iTamingLevel = 5; break;
				case 23:
				case 12: iTamingLevel = 6; break;
				case 28: iTamingLevel = 7; break;
				case 13:
				case 27: iTamingLevel = 8; break;
				case 29: iTamingLevel = 9; break;
				case 33: iTamingLevel = 9; break;
				case 30: iTamingLevel = 9; break;  
				case 31:
				case 32: iTamingLevel = 10; break;  				}

				iResult = (iSkillLevel/10);

				if (iResult < iTamingLevel) break;

				break;
				}
			}
		}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC] != 0) return;

	m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC] = 20;
	SendNotifyMsg(NULL, iClientH, NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[SKILL_MAGIC], NULL, NULL);

	m_pClientList[iClientH]->CheckTotalSkillMasteryPoints(4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
	char  * cp, cDir, cData[3000];
	uint32 * dwp;
	uint16  * wp;
	short * sp, dX, dY;
	int   iRet, iSize;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5:	dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	if (dX < 1 || dX > m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX ||
		dY < 1 || dY > m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY){
		 return 0;
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = OBJECTMOVE_CONFIRM;

	cp = (char *)(cData + INDEX2_MSGTYPE+2);

	sp  = (short *)cp;
	*sp = dX - 10; 
	cp += 2;

	sp  = (short *)cp;
	*sp = dY - 7; 
	cp += 2;

	*cp = cDir;
	cp++;

	iSize = iComposeMoveMapData(dX - 10, dY - 7, iClientH, cDir, cp);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsObserverMode == true) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_EVENT_CONFIRM, NULL, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = false;
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*1,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_EVENT_REJECT, NULL, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = true;
	}
}

void CGame::RequestRestartHandler(int iClientH)
{
	char  cTmpMap[32];
	CClient * player = m_pClientList[iClientH];

	if (!player || !player->m_bIsKilled) return;
	strcpy(cTmpMap,player->m_cMapName) ;
	ZeroMemory(player->m_cMapName, sizeof(player->m_cMapName));
	if (player->m_cMagicEffectStatus[ MAGICTYPE_CONFUSE ] != 0)
		player->RemoveMagicEffect(MAGICTYPE_CONFUSE);

	switch(player->m_side)
	{
	case ARESDEN:
		if ((strcmp(cTmpMap, sideMap[ELVINE]) == 0) && !player->IsGM()){
			strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ELVINE]);
		}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
		}else if (player->m_iLevel > 80)
			strcpy(player->m_cMapName, sideMapRes[ARESDEN]);
		else 
			strcpy(player->m_cMapName, sideMapFarm[ARESDEN]);
		break;
	case ELVINE:
		if ((strcmp(cTmpMap, sideMap[ARESDEN]) == 0) && !player->IsGM()){
			strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
		}else if (strcmp(cTmpMap, sideMap[ISTRIA]) == 0){
			strcpy(player->m_cLockedMapName, sideMapJail[ISTRIA]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ISTRIA]);
		}else if (player->m_iLevel > 80)
			strcpy(player->m_cMapName, sideMapRes[ELVINE]);
		else 
			strcpy(player->m_cMapName, sideMapFarm[ELVINE]);
		break;
	case ISTRIA:
		if ((strcmp(cTmpMap, sideMap[ARESDEN]) == 0) && !player->IsGM()){
			strcpy(player->m_cLockedMapName, sideMapJail[ARESDEN]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ARESDEN]);
		}else if ((strcmp(cTmpMap, sideMap[ELVINE]) == 0) && !player->IsGM()){
			strcpy(player->m_cLockedMapName, sideMapJail[ELVINE]);
			player->m_iLockedMapTime = 60*3; 
			strcpy(player->m_cMapName, sideMapJail[ELVINE]);
		}else if (player->m_iLevel > 80)
			strcpy(player->m_cMapName, sideMapRes[ISTRIA]);
		else 
			strcpy(player->m_cMapName, sideMapFarm[ISTRIA]);
		break;
	case NEUTRAL:
		strcpy(player->m_cMapName, sideMap[NEUTRAL]);
		break;
	}

	player->m_bIsKilled = false;
	player->m_iHP = player->GetMaxHP();
	player->m_iHungerStatus = 100;

	ZeroMemory(cTmpMap, sizeof(cTmpMap));
	strcpy(cTmpMap, player->m_cMapName);

	RequestTeleportHandler(iClientH, 2, cTmpMap);
}

void CGame::AdminOrder_CreateItem(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cItemName[256], cTemp[256];
	SYSTEMTIME SysTime;
	CItem * pItem;
	int    iTemp, iEraseReq, manuEndu, amount;
	uint32 attribute;
	uint16  wTemp;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel != 0)
			SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	//	if (memcmp(m_pClientList[iClientH]->m_cIPaddress, "203.234.215.", 12) != 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	} else return;

	token = pStrTok->pGet();
	if (token != NULL) {
		attribute = atoi(token);
	} else attribute = 0;

	token = pStrTok->pGet();
	if (token != NULL) {
		manuEndu = atoi(token);
	} else manuEndu = 0;

	token = pStrTok->pGet();
	if (token != NULL) {
		amount = atoi(token);
	} else amount = 1;

	for (int i = amount; i > 0; i--){
		pItem = new CItem;
		if (pItem->InitItemAttr(cItemName) == false) {
			delete pItem;
			return;
		}

		if (pItem->m_cItemType == ITEMTYPE_CONSUME || pItem->m_cItemType == ITEMTYPE_ARROW){
			pItem->m_dwCount = amount;
			i = 0; //Breaks loop early for stackable items
		}

		if (attribute != 0) {
			pItem->m_dwAttribute = attribute;
			if (pItem->IsManued())
			{
				if ((manuEndu >= 1) && (manuEndu <= 200)) {

					pItem->m_cItemColor = 2;
					pItem->m_sItemSpecEffectValue2 = manuEndu - 100;


					dV2 = (double)pItem->m_sItemSpecEffectValue2;
					dV3 = (double)pItem->m_wMaxLifeSpan;
					dV1 = (dV2/100.0f)*dV3;

					iTemp  = (int)pItem->m_wMaxLifeSpan;
					iTemp += (int)dV1;

					if (iTemp <= 0) 
						wTemp = 1;
					else wTemp = (uint16)iTemp;

					if (wTemp <= pItem->m_wMaxLifeSpan*2) {
						pItem->m_wMaxLifeSpan = wTemp;
						pItem->m_sItemSpecEffectValue1 = (short)wTemp;
						pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
					}
					else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;

				}
				else pItem->m_dwAttribute = NULL;
			}
			else {

				if (pItem->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK) {
					switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
					case 6:	pItem->m_cItemColor = 2; break;
					case 8:	pItem->m_cItemColor = 3; break;
					case 1:	pItem->m_cItemColor = 5; break;
					case 5:	pItem->m_cItemColor = 1; break;
					case 3:	pItem->m_cItemColor = 7; break;
					case 2:	pItem->m_cItemColor = 4; break;
					case 7:	pItem->m_cItemColor = 6; break;
					case 9:	pItem->m_cItemColor = 8; break;
					}
				}
				else if (pItem->m_sItemEffectType == ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
					case 10: pItem->m_cItemColor = 5; break;
					}
				}
			}
		}


		switch (pItem->m_sIDnum) {
		case 511: 	case 513:
		case 515:
		case 517:
		case 530:
		case 531:
		case 532:
		case 533:
		case 534:
			GetLocalTime(&SysTime);
			pItem->m_sTouchEffectType   = ITET_DATE;

			pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
			pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
			pItem->m_sTouchEffectValue3 = 24 ;
			break;

		default:
			GetLocalTime(&SysTime);
			pItem->m_sTouchEffectType   = ITET_GM_MADE;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
			break;
		}

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) {

			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, false);
			
#ifdef TAIWANLOG 
			_bItemLog(ITEMLOG_CREATE, iClientH, (int) -1, pItem);
#endif

			if (iEraseReq == 1) {
				delete pItem;
				pItem = NULL ;
			}

			wsprintf(g_cTxt, "GM Order(%s): Create ItemName(%s)", m_pClientList[iClientH]->m_cCharName, cItemName);
			bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,g_cTxt);
		}
		else {
			delete pItem;
			return;
		}
	}
}

void CGame::AdminOrder_SetWeather(int iClientH, char *pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cItemName[256], cTemp[256];
	SYSTEMTIME SysTime;
	CItem * pItem;
	int    iTemp, iEraseReq, manuEndu, amount;
	uint32 attribute;
	uint16  wTemp;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {
		if (m_pClientList[iClientH]->m_iAdminUserLevel != 0)
			SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	Weather weather = Weather(-1);
	if (token != NULL) {
		weather = Weather( atoi(token) );
	}

	token = pStrTok->pGet();

	uint32 last = 3 _m + dice(1,7) _m;
	if (token != NULL) {
		last = atoi(token) _m;
	}

	CMap * map = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ];
	if(weather >= WEATHER_SUNNY && weather <= WEATHER_HEAVYSNOW)
	{
		map->m_dwWeatherStartTime = timeGetTime();
		map->m_dwWeatherLastTime  = last;

		if(weather != map->m_weather)
		{
			map->m_weather = weather;

			for(int j = 1; j < MAXCLIENTS; j++) 
				if(m_pClientList[j] && m_pClientList[j]->m_bIsInitComplete && m_pClientList[j]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
					SendNotifyMsg(NULL, j, NOTIFY_WEATHERCHANGE, map->m_weather, NULL, NULL, NULL);
		}
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
	int i, * ip, iAmount;
	char * cp, cIndex;
	struct {
		char cIndex;
		int  iAmount;
	} stTemp[12];

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}


	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;


		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		if (m_pClientList[iClientH] == NULL) return;
	}
}

void CGame::DeleteOccupyFlags(int iMapIndex)
{
	if (!m_pMapList[iMapIndex]) return;

	uint32 dwTime = timeGetTime();

	for (int i = 1; i < MAXOCCUPYFLAG; i++) 
	{	
		if (COccupyFlag *& flag = m_pMapList[iMapIndex]->m_pOccupyFlag[i])
		{	
			wsprintf(g_cTxt, "(*)Delete OccupyFlag: Side(%d) XY(%d, %d)", flag->m_side, flag->m_sX, flag->m_sY);
			PutLogList(g_cTxt);
			int dX = flag->m_sX;
			int dY = flag->m_sY;
			int iDynamicObjectIndex = flag->m_iDynamicObjectIndex;
			CDynamicObject *& dynObj = m_pDynamicObjectList[iDynamicObjectIndex];

			delete flag;
			flag = NULL;			
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
			CTile * tile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
			tile->m_iOccupyFlagIndex = NULL;

			if (!dynObj) continue;

			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, MSGTYPE_REJECT,
				iMapIndex, dX, dY, dynObj->m_sType,
				iDynamicObjectIndex, NULL);
			m_pMapList[iMapIndex]->SetDynamicObject(NULL, NULL, dX, dY, dwTime);

			delete dynObj;
			dynObj = NULL;
		}
	}
}

void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
	CClient * player = m_pClientList[iClientH];
	CClient * requestee = NULL;

	if(!player) return;

	switch (iV1)
	{
	case 0: 
		partyMgr.RemoveFromParty( player );
		break;

	case 1: 
		if (player->GetParty() || player->GetPartyStatus() != PS_NOTINPARTY)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);
			return;
		}

		for(int i = 1; i < MAXCLIENTS; i++)
		{
			if (m_pClientList[i] && strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)
			{
				requestee = m_pClientList[i];
				break;
			}
		}

		if(!requestee)
			return;

		if( requestee->IsInCombatMode() || requestee->m_side != player->m_side)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);
		}
		else if (requestee->GetPartyStatus() == PS_PROCESSING)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);

			player->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(player->m_cReqJoinPartyName, sizeof(player->m_cReqJoinPartyName));
			player->SetPartyStatus(PS_NOTINPARTY);
		}
		else if (m_pMapList[requestee->m_cMapIndex]->m_isPartyDisabled && !requestee->IsGM())
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_PARTY, 7, 0, NULL, NULL);
		}
		else
		{
			requestee->m_iReqJoinPartyClientH = iClientH;
			ZeroMemory(requestee->m_cReqJoinPartyName, sizeof(requestee->m_cReqJoinPartyName));
			strcpy(requestee->m_cReqJoinPartyName, player->m_cCharName);
			requestee->Notify(NULL, NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, player->m_cCharName);

			player->m_iReqJoinPartyClientH = requestee->m_handle;
			ZeroMemory(player->m_cReqJoinPartyName, sizeof(player->m_cReqJoinPartyName));
			strcpy(player->m_cReqJoinPartyName, requestee->m_cCharName);

			player->SetPartyStatus(PS_PROCESSING);
		}
		break;

	case 2: 
		if(!player->GetParty())
			return;

		player->GetParty()->NotifyMemberList( player );
		break;
	}
}

bool CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{	
	int i, sX,sY, dX, dY, GoalAmount = 20;
	char cContrib;

	CClient * player = m_pClientList[sAttackerH];
	CNpc * npc = m_pNpcList[iNpcH];
	CMap * map = m_pMapList[player->m_cMapIndex];

	if (!player) return false;
	if (player->m_bIsInitComplete == false) return false;
	if (!npc) return false;

	if (!map->m_bIsFightZone)  return false;
	if (!m_SoccerMode) return false;

		sX = npc->m_sX;
		sY = npc->m_sY;	

		dX = map->m_stEnergySphereGoalList_aresdenX;
		dY = map->m_stEnergySphereGoalList_aresdenY;

		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) 
		{		
			if ((cAttackerType ==  OWNERTYPE_PLAYER) && player) 
			{	
				if (player->m_side == 1) 
				{	
					cContrib = dice(3,10);
					player->m_iContribution += cContrib;
					player->m_iRewardGold += 10000;
					if (player->m_iRewardGold >  MAXREWARDGOLD) 
						player->m_iRewardGold =  MAXREWARDGOLD;
					SendNotifyMsg(NULL, sAttackerH,  NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
					wsprintf(g_cTxt, "(!) EnergySphere Goal for Aresden (%s)", player->m_cCharName);
					PutLogList(g_cTxt);	
				} else {	
					player->m_iContribution -= 10;
					cContrib = -10;
					wsprintf(g_cTxt, "(!) EnergySphere Goal for Aresden (by Elvine player %s)", player->m_cCharName);
					PutLogList(g_cTxt);		 
				}  
				for (i = 1; i <  MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) 
					{	
						SendNotifyMsg(NULL, i,  NOTIFY_ENERGYSPHEREGOALIN, cContrib, player->m_side, 2, player->m_cCharName);
					}
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON,  COMMONTYPE_MAGIC, player->m_cMapIndex
						, dX, dY, dX, dY, 246, player->m_sType); // Aresden Goal
					
					m_SoccerAresdenGoals += 1;
					UpdateSoccerEvent();
					if (m_SoccerAresdenGoals < GoalAmount) EnergySphereProcessor(false, sAttackerH);
					else SoccerEventWon((Side)player->m_side, player->m_cMapIndex);
			}
			return true;
		}

		dX = map->m_stEnergySphereGoalList_elvineX;
		dY = map->m_stEnergySphereGoalList_elvineY;

		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) 
		{	
			map->m_iCurEnergySphereGoalPointIndex = -1;
			if ((cAttackerType ==  OWNERTYPE_PLAYER) && player) 
			{	
				if (player->m_side == 2)
				{ 	
					cContrib = dice(3,10);
					player->m_iContribution += cContrib; 
					player->m_iRewardGold += 10000;
					if (player->m_iRewardGold >  MAXREWARDGOLD) 
						player->m_iRewardGold =  MAXREWARDGOLD;
					SendNotifyMsg(NULL, sAttackerH,  NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
					wsprintf(g_cTxt, "(!) EnergySphere Goal for Elvine (%s)", player->m_cCharName);
					PutLogList(g_cTxt); 
				} else {	
					player->m_iContribution -= 10;
					cContrib = -10;
					wsprintf(g_cTxt, "(!) EnergySphere Goal for Elvine (by Aresden player %s)", player->m_cCharName);
					PutLogList(g_cTxt);		 	
				}

				for (i = 1; i <  MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) 
					{	
						SendNotifyMsg(NULL, i,  NOTIFY_ENERGYSPHEREGOALIN, cContrib, player->m_side, 1, player->m_cCharName);
					}
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON,  COMMONTYPE_MAGIC, player->m_cMapIndex
						, dX, dY, dX, dY, 245, player->m_sType); // Elvine Goal
					
					m_SoccerElvineGoals += 1;
					UpdateSoccerEvent();
					if (m_SoccerElvineGoals < GoalAmount) EnergySphereProcessor(false, sAttackerH);	
					else SoccerEventWon((Side)player->m_side, player->m_cMapIndex);
			}
			return true;
		}
		return false;
}

void CGame::EnergySphereProcessor(bool bIsAdminCreate, int iClientH)
{	
	int iCIndex, iTemp, pX, pY, inbePlayersML;
	char cSA, cWaypoint[31];

	CClient * player = m_pClientList[iClientH];
	CMap * map = m_pMapList[player->m_cMapIndex];

	if (!bIsAdminCreate) 	
	{	
		if (map == NULL || m_bIsCrusadeMode == true) return;
		if (map->m_iCurEnergySphereGoalPointIndex >= 0) return;

		iCIndex = dice(1, map->m_iTotalEnergySphereCreationPoint);
		if (map->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;

		cSA = 0;
		pX = map->m_stEnergySphereCreationList[iCIndex].sX;
		pY = map->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));	

		CNpc * sphere = CreateNpc("Energy-Sphere", player->m_cMapIndex, cSA,  MOVETYPE_RANDOM, 
			&pX, &pY, (Side)-1, cWaypoint, NULL, NULL, false, false, false);

		if(!sphere) 
			return;

		wsprintf(g_cTxt, "(!) Sucess Goal Sphere Auto-Created! (%d, %d)", pX, pY);
		PutLogList(g_cTxt);
	} 
	else 
	{	
		if (map->m_iCurEnergySphereGoalPointIndex >= 0) return;
		iCIndex = dice(1, map->m_iTotalEnergySphereCreationPoint);
		if (map->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		cSA = 0;
		pX = map->m_stEnergySphereCreationList[iCIndex].sX;
		pY = map->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));	
	
		CNpc * sphere = CreateNpc("Energy-Sphere", player->m_cMapIndex, cSA,  MOVETYPE_RANDOM, 
			&pX, &pY, (Side)-1, cWaypoint, NULL, NULL, false, false, false);

		if(!sphere) 
			return;

		wsprintf(g_cTxt, "Admin Order(%s): Energy Sphere Created! (%s) (%d, %d)",
			m_pClientList[iClientH]->m_cCharName, player->m_cMapName, pX, pY);			
		PutLogList(g_cTxt);
	}

	while(CClient * player = objMgr.GetPlayers())
	{
		player->Notify(NULL,  NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, m_pClientList[iClientH]->m_cMapName);
	}
}
void CGame::UpdateSoccerEvent() const
{	
	int shortCutIndex = 0;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		SendNotifyMsg(NULL, index, NOTIFY_SOCCER, 
			m_SoccerAresdenGoals, m_SoccerElvineGoals, NULL, NULL);
	}
}
void CGame::SoccerEventWon(Side side, int MapIndex)
{	
	char cTxt[120];
	int Winner;

	m_SoccerAresdenGoals	= 0;
	m_SoccerElvineGoals		= 0;
	m_SoccerMode	= false;

	switch(side) 
	{
	case ARESDEN: 
		wsprintf(cTxt, "Soccer Event Finished. Aresden won.");
		Winner = 1;
		break;
	case ELVINE: 
		wsprintf(cTxt, "Soccer Event Finished. Elvine won.");
		Winner = 2;
		break;
	default: 
		wsprintf(cTxt, "Soccer Event Finished. Draw.");
		Winner = 0;
		break;
		PutLogList(cTxt);
	}
	for (int j = 0; j < MAXCLIENTS; j++)
	{	
		if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == true))
		{	
			SendNotifyMsg(NULL, j, NOTIFY_SOCCERVICTORY,  side, NULL, NULL, NULL); 

			if (m_pClientList[j]->m_side != side && !m_pClientList[j]->IsGM()
				 && (m_pClientList[j]->m_cMapIndex == MapIndex)) 
			{	
				SendNotifyMsg(NULL, j, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				m_pClientList[j]->m_bIsWarLocation = true;
				m_pClientList[j]->m_iTimeLeft_ForceRecall = 300;
				RequestTeleportHandler(j, 0);
			}	
		}	
	}
	CreateSoccerFile(Winner);
	UpdateSoccerEvent();
	PutLogList("(!!) Energy Sphere Event Finished.");
}
void CGame::CreateSoccerFile(int Winner) const
{	
	char * cp, cTxt[120], cFn[256], cTemp[1024];
	FILE * pFile;

	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));

	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"Soccer.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{
		wsprintf(cTxt, "(!) Cannot create Soccer file");
		PutLogList(cTxt);
	} else {
		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Soccer-Winner = %d\n", Winner);
		strcat(cTemp, cTxt);
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		wsprintf(cTxt, "(O) Soccerfile created");
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

bool CGame::ReadSoccerFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120];
	char seps[] = "= \t\n";
	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{
		PutLogList("(!) Cannot open Soccer file.");
		return false;
	} else {
		PutLogList("(!) Reading Soccer file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		while( token != NULL )   
		{
			if (cReadMode != 0) 
			{
				switch (cReadMode) 
				{
				case 1:
					m_SoccerWinner = atoi(token);
					wsprintf(cTxt, "Soccer-Winner = %d", m_SoccerWinner);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				}
			} else {
				if (memcmp(token, "Soccer-Winner", 13) == 0) cReadMode = 1;
			}
			token = pStrTok->pGet();
		}
		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);
	switch (m_SoccerWinner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned In Last Soccer Event.");
		break;
	case 2: PutLogList("(!!) Elvine Owned In Last  Soccer Event.");
		break;		
	default: PutLogList("(!!) Nobody Owned In Last  Soccer Event.");
		break;
	} 
	return true;
}
void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
	uint32 dwTime = timeGetTime();
	short sTemp;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == true) return;
	
	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = true;
	m_pClientList[iClientH]->m_specialAbilityStartTime = dwTime;


	m_pClientList[iClientH]->m_iSpecialAbilityTime = SPECABLTYTIMESEC;

	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	SendNotifyMsg(NULL, iClientH, NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_specialAbilityLastSec, NULL);
	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	_ClearQuestStatus(iClientH);

	SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

bool CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType, int iItemprobability)
{
	if (dice(1,iItemprobability) != 1) return false ;

	switch (sNpcType) {
		case 79: if (dice(1,200) != 11) return false; break;	  // Nizie
		case 70: if (dice(1,200) != 11) return false; break;	  // Barlog
		case 71: if (dice(1,200) != 11) return false; break;	  // Centaurus
		default: return false;
	}


	switch (sNpcType) 
	{
		case 79: // Nizie
			if (dice(1,20) == 11) iItemID = 845; break; // StormBringer

		case 70: // Barlog
			if (dice(1,40) == 11) iItemID = 846; break; // The_Devastator

		case 71: // Centaurus
			if (dice(1,20) == 11) iItemID = 848; break; // Lighting Blade
	}

	if (iItemID == 0) 
		return false;
	else return true;
} // bGetItemNameWhenDeleteNpc


void CGame::UpdateMapSectorInfo()
{
	int i, ix, iy;
	int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;

	for (i = 0; i < MAXMAPS; i++) 
		if (m_pMapList[i] != NULL) {

			iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;
			m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
			m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
			m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

			for (ix = 0; ix < MAXSECTORS; ix++)
				for (iy = 0; iy < MAXSECTORS; iy++) {
					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
						iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
						m_pMapList[i]->m_iMaxNx = ix;
						m_pMapList[i]->m_iMaxNy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
						iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
						m_pMapList[i]->m_iMaxAx = ix;
						m_pMapList[i]->m_iMaxAy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
						iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
						m_pMapList[i]->m_iMaxEx = ix;
						m_pMapList[i]->m_iMaxEy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
						iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
						m_pMapList[i]->m_iMaxMx = ix;
						m_pMapList[i]->m_iMaxMy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
						iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
						m_pMapList[i]->m_iMaxPx = ix;
						m_pMapList[i]->m_iMaxPy = iy;
					}
				}

				m_pMapList[i]->ClearTempSectorInfo();

				if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
				if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
				if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
				if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
				if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
		}
}


void CGame::AgingMapSectorInfo()
{
	int i, ix, iy;

	for (i = 0; i < MAXMAPS; i++) 
		if (m_pMapList[i] != NULL) {
			for (ix = 0; ix < MAXSECTORS; ix++)
				for (iy = 0; iy < MAXSECTORS; iy++) {
					m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;

					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
				}
		}
}


bool CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
	int ix, iy, tX, tY;
	char cNpcName[21], cNpcWaypoint[11], cOwnerType;
	short sOwnerH;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= MAXCRUSADESTRUCTURES) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return false;
	}

	if(!m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->IsBuild(dX,dY)) 
		return false;

	if(!m_bIsCrusadeMode && !m_astoria.get())
		return false;

	for (ix = dX -1; ix <= dX +1; ix++)
	{
		for (iy = dY -1; iy <= dY +1; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if (sOwnerH && cOwnerType == OWNERTYPE_NPC && m_pNpcList[sOwnerH]->m_cActionLimit == 5) return false;
		}
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	switch(m_pClientList[iClientH]->m_side)
	{
	case ARESDEN:
		switch (iType) 
		{
		case 1: strcpy(cNpcName, "AGT-Aresden"); break;
		case 2: strcpy(cNpcName, "CGT-Aresden"); break;
		case 3: strcpy(cNpcName, "MS-Aresden"); break;
		case 4: strcpy(cNpcName, "DT-Aresden"); break;
		}
		break;
	case ELVINE:
		switch (iType) 
		{
		case 1: strcpy(cNpcName, "AGT-Elvine"); break;
		case 2: strcpy(cNpcName, "CGT-Elvine"); break;
		case 3: strcpy(cNpcName, "MS-Elvine"); break;
		case 4: strcpy(cNpcName, "DT-Elvine"); break;
		}
		break;
	case ISTRIA:
		switch (iType) 
		{
		case 1: strcpy(cNpcName, "AGT-Istria"); break;
		case 2: strcpy(cNpcName, "CGT-Istria"); break;
		case 3: strcpy(cNpcName, "MS-Istria"); break;
		case 4: strcpy(cNpcName, "DT-Istria"); break;
		}
		break;
	default:
		return false;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	tX = (int)dX;
	tY = (int)dY;

	if(!CreateNpc(cNpcName, m_pClientList[iClientH]->m_cMapIndex, 0, 
		MOVETYPE_RANDOM, &tX, &tY, (Side)-1, cNpcWaypoint, NULL, NULL, false, false)) 
	{
		return false;
	}
	
	//wsprintf(g_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
	//PutLogList(g_cTxt);
	return true;
}

void CGame::CheckCrusadeResultCalculation(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if ((!m_bIsCrusadeMode) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
	//removed if (m_pClientList[iClientH]->m_iWarContribution > 300000 ) m_pClientList[iClientH]->m_iWarContribution = 300000;
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution*5);
				SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
				_bCrusadeLog(CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution*5),NULL) ;
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_side) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 160) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*125;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*75;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution*35;
					SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(CRUSADELOG_GETEXP,iClientH,m_pClientList[iClientH]->m_iWarContribution*35,NULL) ;
				}else{
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*200;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 160) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*125;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*75;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution*5;
					SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, NULL, -1*m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution*5),NULL) ;
				}
			}
		}
		else {
			SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, NULL, 0, NULL, -1);
		}
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
	}
}


void CGame::LocalStartCrusadeMode(uint32 dwCrusadeGUID)
{
	int i;

	if (m_bIsCrusadeMode) return;
	m_bIsCrusadeMode = true;
	m_iCrusadeWinnerSide = 0;

	for(i = 0; i < MAXSIDES; i++)
	{
		m_iCollectedMana[i] = 0;
		m_mana[i] = 0;
	}

	if (dwCrusadeGUID != NULL) {
		_CreateCrusadeGUID(dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, 0, 0, 1, NULL); // 1: Don't show to player
		
			SendNotifyMsg(NULL, i, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, NULL, NULL);
			//wsprintf(g_cTxt, "m_pClientList[i]->m_iCrusadeDuty(%d)", m_pClientList[i]->m_iCrusadeDuty);
			//PutLogList(g_cTxt);

			// Recall from enemy city if already inside when crusade begins...
			if (m_pClientList[i]->m_iAdminUserLevel == 0) {
				if (m_pClientList[i]->IsInFoeMap()) {
					m_pClientList[i]->m_bIsWarLocation = true;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				}
				else if (m_pClientList[i]->IsNeutral() &&
					(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, sideMap[ARESDEN], 7) == 0	|| 
					memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, sideMap[ELVINE], 6) == 0 ||
					memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "middleland", 10) == 0))
				{	
						m_pClientList[i]->m_bIsWarLocation = true;
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				} else if(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap) {
					m_pClientList[i]->m_bIsWarLocation = true;
					m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
				}
			}		
		}

	for (i = 0; i < MAXMAPS; i++)
		if (m_pMapList[i] != NULL) m_pMapList[i]->RestoreStrikePoints();

	CreateCrusadeStructures();
	PutLogList("(!) Crusade Mode ON.");

	_bCrusadeLog(CRUSADELOG_STARTCRUSADE,NULL,NULL,NULL) ;
}


void CGame::LocalEndCrusadeMode(int crusadeWinnerSide)
{
	int i;
	if (!m_bIsCrusadeMode) return;
	m_bIsCrusadeMode = false;
	m_iCrusadeWinnerSide = crusadeWinnerSide;

	PutLogList("(!) Crusade Mode OFF.");

	KillCrusadeObjects();

	_CreateCrusadeGUID(m_dwCrusadeGUID, m_iCrusadeWinnerSide);

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			SendNotifyMsg(NULL, i, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
		}

	if (m_iCrusadeWinnerSide == 2)
		_bCrusadeLog(CRUSADELOG_ENDCRUSADE,NULL,NULL,"Elvine Win!") ;
	else if (m_iCrusadeWinnerSide == 1)
		_bCrusadeLog(CRUSADELOG_ENDCRUSADE,NULL,NULL,"Aresden Win!") ;
	else 
		_bCrusadeLog(CRUSADELOG_ENDCRUSADE,NULL,NULL,"Drawn!") ;
}


void CGame::SaveOccupyFlagData()
{
	char * pData;
	int iSize;
	FILE * pFile;

	return;

	PutLogList("(!) Middleland OccupyFlag data saved.");

	pData = new char[1000000+1];
	if (pData == NULL) return;
	ZeroMemory(pData, 1000000);

	iSize = _iComposeFlagStatusContents(pData);

	_mkdir("GameData");

	pFile = fopen("GameData\\OccupyFlag.txt", "wt");
	if (pFile == NULL) return;

	fwrite(pData, 1, iSize, pFile);

	delete[] pData;
	fclose(pFile);
}


void CGame::CreateCrusadeStructures()
{
	int i, z, tX, tY, iTotalMS, iMSIndex[100], iMSSelected[MAXCRUSADESTRUCTURES], iMSLeft;
	char cNpcName[21], cNpcWayPoint[11];
	bool bFlag;

	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));


	for (i = 0; i < 100; i++) iMSIndex[i] = -1;

	iTotalMS = 0;
	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) 
		if (m_stCrusadeStructures[i].cType == NPC_MANASTONE) {
			iMSIndex[iTotalMS] = i;
			iTotalMS++;
			iMSSelected[i] = -1;
		}

	if (iTotalMS <= 3) {

		iMSSelected[ iMSIndex[0] ] = 1;
		iMSSelected[ iMSIndex[1] ] = 1;
		iMSSelected[ iMSIndex[2] ] = 1;
	}
	else {
		iMSLeft = 3;
		bFlag = false;
		while (bFlag == false) {
			i = dice(1, iTotalMS) -1;
			if (iMSIndex[i] != -1) {
				iMSSelected[ iMSIndex[i] ] = 1;
				iMSIndex[i] = -1;
				iMSLeft--;
				if (iMSLeft <= 0) bFlag = true;
			}
		}
	}


	for (i = 0; i < MAXCRUSADESTRUCTURES; i++) 
	{
		if(!m_stCrusadeStructures[i].cType)
			continue;

		for (z = 0; z < MAXMAPS; z++)
		{
			if(!m_pMapList[z] || (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) != 0)) 
				continue;

			ZeroMemory(cNpcName, sizeof(cNpcName));

			switch (m_stCrusadeStructures[i].cType) 
			{
			case NPC_AGT:
				if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
					strcpy(cNpcName, "AGT-Aresden");
				else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
					strcpy(cNpcName, "AGT-Elvine");
				break;

			case NPC_CGT: 
				if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
					strcpy(cNpcName, "CGT-Aresden");
				else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
					strcpy(cNpcName, "CGT-Elvine");
				break;

			case NPC_ESG:
				if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
					strcpy(cNpcName, "ESG-Aresden");
				else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
					strcpy(cNpcName, "ESG-Elvine");
				break;

			case NPC_GMG:
				if (strcmp(m_pMapList[z]->m_cName, sideMap[ARESDEN]) == 0)
					strcpy(cNpcName, "GMG-Aresden");
				else if (strcmp(m_pMapList[z]->m_cName, sideMap[ELVINE]) == 0)
					strcpy(cNpcName, "GMG-Elvine");
				break;

			case NPC_MANASTONE:
				if (iMSSelected[i] == 1) strcpy(cNpcName, "ManaStone");
				break;

			default: 
				strcpy(cNpcName, m_npcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
				break;
			}

			tX = (int)m_stCrusadeStructures[i].dX;
			tY = (int)m_stCrusadeStructures[i].dY;

			if(CreateNpc(cNpcName, z, 0, MOVETYPE_RANDOM, &tX, &tY, (Side)-1, cNpcWayPoint, NULL, NULL)) 
			{
				//wsprintf(g_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
				//PutLogList(g_cTxt);
			}
			break;
		}
	}
}


void CGame::SendCollectedMana()
{
	char * cp, cData[120];
	uint16 * wp;
	if (!m_bIsCrusadeMode) return;
	
	if ((m_iCollectedMana[1] == 0) && m_iCollectedMana[2] == 0) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (uint16 *)cp;
	*wp = (uint16)m_iCollectedMana[1];
	cp += 2;

	wp = (uint16 *)cp;
	*wp = (uint16)m_iCollectedMana[2];
	cp += 2;

	m_mana[ARESDEN] += m_iCollectedMana[1];
	m_mana[ELVINE] += m_iCollectedMana[2];
	bStockMsgToGateServer(cData, 5);

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}


void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
	int i;
	uint32 dwTime = timeGetTime();

	if (!m_bIsCrusadeMode) return;
	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, sideMap[ELVINE]) == 0) {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			RegisterDelayEvent(DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 5000, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for (i = 1; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, sideMap[ARESDEN]) == 0) {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			RegisterDelayEvent(DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

void CGame::_LinkStrikePointMapIndex()
{
	int i, z, x;

	for (i = 0; i < MAXMAPS; i++)
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
			for (z = 0; z < MAXSTRIKEPOINTS; z++) 
				if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
					for (x = 0; x < MAXMAPS; x++) 
						if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
							m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
							//testcode
							wsprintf(g_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
							PutLogList(g_cTxt);

							break;
						}
				}
		}
}

void CGame::MeteorStrikeHandler(int iMapIndex)
{
	int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
	int iTargetArray[MAXSTRIKEPOINTS];
	short sOwnerH;
	char  cOwnerType, g_cTxt[120];
	uint32 dwTime = timeGetTime();
	
	if (!m_bIsCrusadeMode) return;
	PutLogList("(!) Beginning Meteor Strike Procedure...");
	if (iMapIndex == -1) 
	{	PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}	
	if (m_pMapList[iMapIndex] == NULL) 
	{	PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) 
	{	PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}	
	for (i = 0; i < MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) 
	{	if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) 
		{	iTargetArray[iIndex] = i; 
			iIndex++;
		}
	}
	wsprintf(g_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(g_cTxt);

	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) 
	{	PutLogList("(!) No strike points!");
		RegisterDelayEvent(DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}else 
	{	for (i = 1; i < MAXCLIENTS; i++)
		{	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == true) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) 
			{	SendNotifyMsg(NULL, i, NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
			}
		}
		for (i = 0; i < iIndex; i++) 
		{	iTargetIndex = iTargetArray[i];
			if (iTargetIndex == -1) 
			{	PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}
			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;
			iTotalESG = 0;
			for (ix = dX-30; ix <= dX+30; ix++) 
			for (iy = dY-30; iy <= dY+30; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == NPC_ESG)) {
					iTotalESG++;
				}
			}			
			wsprintf(g_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(g_cTxt);
		if (iTotalESG < 2) 
			{	m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (dice(1,3) - iTotalESG);//(2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) 
				{	m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// Should have been a way to prevent people to go in destructed building, never implemented
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = true;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}else 
				{	m_stMeteorStrikeResult.iStructureDamageAmount += (dice(1,3) - iTotalESG);// (2 - iTotalESG);
					iEffect = dice(1,5)-1;
					iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_FIRE2, iMapIndex, 
					                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(dice(1,3) -2), 
									  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(dice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}
		RegisterDelayEvent(DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		RegisterDelayEvent(DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 3000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		RegisterDelayEvent(DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 5000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		RegisterDelayEvent(DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 7000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}

void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
	char * cp, cData[120];
	int i;
	int *ip, iIndex;
	uint32 dwTemp;
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (!m_bIsCrusadeMode) return;

	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	if((dwTime - player->m_lastDamageTime) > 15 _s || player->IsGM())
	{
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_SETGUILDTELEPORTLOC;
		cp++;

		ip = (int *)cp;
		*ip = iGuildGUID;
		cp += 4;

		ip = (int *)cp;
		*ip = dX;
		cp += 4;

		ip = (int *)cp;
		*ip = dY;
		cp += 4;

		memcpy(cp, pMapName, 10);
		cp += 10;

		wsprintf(g_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
		PutLogList(g_cTxt);
		PutLogFileList(g_cTxt, CRUSADE_LOGFILE);

		for (i = 0; i < MAXGUILDS; i++)
			if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) 
			{
				if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) 
				{
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					return;
				}
				else {
					m_pGuildTeleportLoc[i].m_sDestX = dX;
					m_pGuildTeleportLoc[i].m_sDestY = dY;
					ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
					strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;

					bStockMsgToGateServer(cData, 23);
					return;
				}
			}

			dwTemp = 0;
			iIndex = -1;
			for (i = 0; i < MAXGUILDS; i++) 
			{
				if (m_pGuildTeleportLoc[i].m_iV1 == NULL) 
				{
					m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
					m_pGuildTeleportLoc[i].m_sDestX = dX;
					m_pGuildTeleportLoc[i].m_sDestY = dY;
					ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
					strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;

					bStockMsgToGateServer(cData, 23);
					return;
				} else {
					if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) 
					{
						dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
						iIndex = i;
					}
				}
			}
			if (iIndex == -1) return;

			wsprintf(g_cTxt, "No more GuildTeleportLoc Space! Replaced.");
			PutLogList(g_cTxt);
			PutLogFileList(g_cTxt, CRUSADE_LOGFILE);

			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			bStockMsgToGateServer(cData, 23);
	} else {
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCRUSADE, 0, NULL, NULL, NULL);	
		return;
	}
}

void CGame::RequestGuildTeleportHandler(int iClientH)
{	
	int i;
	char cMapName[11];
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (!m_bIsCrusadeMode) return;

	if (player->m_iLockedMapTime != NULL) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_LOCKEDMAP, player->m_iLockedMapTime, NULL, NULL, player->m_cLockedMapName);
		return;
	}
	if((dwTime - player->m_lastDamageTime) > 15 _s || player->IsGM())
	{
		if (player->IsInFoeMap()) return;
		for (i = 0; i < MAXGUILDS; i++) 
			if (m_pGuildTeleportLoc[i].m_iV1 == player->m_iGuildGUID)
			{
				ZeroMemory(cMapName, sizeof(cMapName));
				strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);
				RequestTeleportHandler(iClientH, 2, cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
				return;
			}

	} else {
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCRUSADE, 1, NULL, NULL, NULL);
		return;	
	}
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
	char * cp, cData[120];
	int i;
	int *ip, iIndex;
	uint32 dwTemp;
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (!m_bIsCrusadeMode) return;

	if((dwTime - player->m_lastDamageTime) > 15 _s || player->IsGM())
	{
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_SETGUILDCONSTRUCTLOC;
		cp++;

		ip = (int *)cp;
		*ip = iGuildGUID;
		cp += 4;

		ip = (int *)cp;
		*ip = dX;
		cp += 4;

		ip = (int *)cp;
		*ip = dY;
		cp += 4;

		memcpy(cp, pMapName, 10);
		cp += 10;

		dwTime = timeGetTime();

		for (i = 0; i < MAXGUILDS; i++)
			if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) 
			{
				if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) 
				{
					m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
					return;
				} else {
					m_pGuildTeleportLoc[i].m_sDestX2 = dX;
					m_pGuildTeleportLoc[i].m_sDestY2 = dY;
					ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
					strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
					m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
					bStockMsgToGateServer(cData, 23);
					return;
				}
			}
			dwTemp = 0;
			iIndex = -1;
			for (i = 0; i < MAXGUILDS; i++) 
			{
				if (m_pGuildTeleportLoc[i].m_iV1 == NULL) 
				{
					m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
					m_pGuildTeleportLoc[i].m_sDestX2 = dX;
					m_pGuildTeleportLoc[i].m_sDestY2 = dY;
					ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
					strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
					m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
					bStockMsgToGateServer(cData, 23);
					return;
				}
				else {
					if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) 
					{
						dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
						iIndex = i;
					}
				}
			}
			if (iIndex == -1) return;
			PutLogList("(X) No more GuildConstructLoc Space! Replaced.");
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			bStockMsgToGateServer(cData, 23);
	} else {
		SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCRUSADE, 2, NULL, NULL, NULL);
		return;	
	}
}
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
	char cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
	int i, x;
	int tX, tY, ix, iy;
	short sOwnerH;
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (!m_bIsCrusadeMode) return;

	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));

	if (cType < 0) return;
	if (cType >= MAXNPCTYPES) return;
	if (cNum  >  10) return;

	if (player->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	if ((m_pMapList[player->m_cMapIndex] != NULL) && (m_pMapList[player->m_cMapIndex]->m_bIsFixedDayMode == true)) return; 

	cNum = 1;
	for (x = 1; x <= cNum; x++) 
	{
		switch (cType) 
		{
		case NPC_LWB: // Light War Beetle
			switch (player->m_side) {
			case 1: strcpy(cNpcName, "LWB-Aresden"); break;
			case 2: strcpy(cNpcName, "LWB-Elvine"); break;
			}
			break;

		case NPC_AGT: // Arrow Guard Tower
			switch (player->m_side) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "AGT-Elvine"); break;
			}
			break;

		case NPC_CGT: // Cannon Guard Tower
			switch (player->m_side) {
			case 1: strcpy(cNpcName, "CGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			}
			break;

		case NPC_MS: // Mana Collector
			switch (player->m_side) {
			case 1: strcpy(cNpcName, "MS-Aresden"); break;
			case 2: strcpy(cNpcName, "MS-Elvine"); break;
			}
			break;

		case NPC_DT: // Detector
			switch (player->m_side) {
			case 1: strcpy(cNpcName, "DT-Aresden"); break;
			case 2: strcpy(cNpcName, "DT-Elvine"); break;
			}
			break;

		case NPC_CP: // Catapult
			switch (player->m_side) {
			case 1: strcpy(cNpcName, "CP-Aresden"); break;
			case 2: strcpy(cNpcName, "CP-Elvine"); break;
			}
			break;

		case NPC_GHK:
			strcpy(cNpcName, "GHK");
			break;

		case NPC_GHKABS:
			strcpy(cNpcName, "GHKABS");
			break;

		case NPC_TK:
			strcpy(cNpcName, "TK");
			break;

		case NPC_BG:
			strcpy(cNpcName, "BG");
			break;
		}

		wsprintf(g_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
		PutLogList(g_cTxt);

		tX = (int)dX;
		tY = (int)dY;

		switch (cType) 
		{
		case NPC_AGT:
		case NPC_CGT:
		case NPC_MS:
		case NPC_DT:
			if (strcmp(player->m_cConstructMapName, player->m_cMapName) != 0
				|| abs(player->m_sX - player->m_iConstructLocX) > 10
				|| abs(player->m_sY - player->m_iConstructLocY) > 10)
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
				return;
			}

			for (i = 0; i < MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == player->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= MAXCONSTRUCTNUM) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
						return;
					}
					else {
						m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}

			SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
			return;

		case NPC_LWB:
		case NPC_GHK:
		case NPC_GHKABS:
		case NPC_TK:
		case NPC_BG:
		case NPC_CP:
			if(player->m_cMapIndex != m_iMiddlelandMapIndex &&
				player->m_cMapIndex != m_iAresdenMapIndex &&
				player->m_cMapIndex != m_iElvineMapIndex)
			{
				player->Notify(NULL, NOTIFY_CANNOTCONSTRUCT, 5, NULL, NULL, NULL);
				return;
			}

			for (i = 0; i < MAXGUILDS; i++) 
			{
				if (m_pGuildTeleportLoc[i].m_iV1 != player->m_iGuildGUID)
					continue;

				if (m_pGuildTeleportLoc[i].m_iNumSummonNpc >= MAX_CRUSADESUMMONMOB)
				{
					SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 4, NULL, NULL, NULL);
					return;
				} else {
					m_pGuildTeleportLoc[i].m_iNumSummonNpc ++;
					goto RSWU_LOOPBREAK;
				}
			}

			SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
			return;
		}
RSWU_LOOPBREAK:;

		bool bRet = false;
		switch (cType) {
		case NPC_AGT:
		case NPC_CGT:
			for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) {
					m_pMapList[player->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == OWNERTYPE_NPC)) {
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case NPC_AGT:
						case NPC_CGT:
							bRet = true;
							break;
						}
					}
				}
			if ((dY <= 32) || (dY >= 783)) bRet = true;
			break;
		}

		if (bRet) 
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
			return;
		}

		CNpc * summon = CreateNpc(cNpcName, player->m_cMapIndex, 0, cMode ? MOVETYPE_GUARD : MOVETYPE_FOLLOW,
			&tX, &tY, (Side)-1, cNpcWayPoint, NULL, NULL, false, false, false, false, player->m_iGuildGUID);

		if(summon) 
		{
			if(cMode == NULL) {
				summon->Follow(player);
			}

			player->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
			if (player->m_iConstructionPoint < 0) player->m_iConstructionPoint = 0;
			SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, player->m_iConstructionPoint, player->m_iWarContribution, NULL, NULL);
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
	char * cp;
	uint32 * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == NULL) return;

	dwTime = timeGetTime();
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	dwp = (uint32 *)cp;
	dwTimeRcv = *dwp;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);

		if (dwTimeGapClient < dwTimeGapServer) return;

		if(m_pClientList[iClientH]->m_timeHackTurn == 0)
		{
			m_pClientList[iClientH]->m_timeHack = dwTimeGapClient - dwTimeGapServer;
			m_pClientList[iClientH]->m_timeHackDif = 0;
		}else{
			m_pClientList[iClientH]->m_timeHackDif += (dwTimeGapClient - dwTimeGapServer) - m_pClientList[iClientH]->m_timeHack;
		}

		if(m_pClientList[iClientH]->m_timeHackTurn == 3 &&
			m_pClientList[iClientH]->m_timeHackDif > 1400*4)
		{
			wsprintf(g_cTxt, "(!) Client(%s) Timeout/Hack(1400+) %u Time gap %u", m_pClientList[iClientH]->m_cCharName, 
				m_pClientList[iClientH]->m_timeHackDif/4,   dwTimeGapClient - dwTimeGapServer );
			PutLogList(g_cTxt);
			PutLogFileList(g_cTxt);

			if(m_pClientList[iClientH]->m_timeHackDif > 2500*4)
			{
				//SYSTEMTIME SysTime;
				//GetLocalTime(&SysTime);

				//m_pClientList[iClientH]->m_iPenaltyBlockYear  = SysTime.wYear;
				//m_pClientList[iClientH]->m_iPenaltyBlockMonth = SysTime.wMonth+1;
				//m_pClientList[iClientH]->m_iPenaltyBlockDay   = SysTime.wDay;
				wsprintf(g_cTxt, "(!) Client(%s) Speed hacker timeout(3000+) %u Time gap %u. Banned to BI", m_pClientList[iClientH]->m_cCharName, 
					m_pClientList[iClientH]->m_timeHackDif/4,   dwTimeGapClient - dwTimeGapServer );
				PutLogFileList(g_cTxt);
				DeleteClient(iClientH, true, true, true, true);
				return;
			}
		}

		++m_pClientList[iClientH]->m_timeHackTurn %= 4;
	}

	if (m_pClientList[iClientH]->m_bIsManager == true) {
		char cTemp[256] ;
		short * sp ; 
		uint16 * wp ;

		cp += 4;
		memcpy(cTemp, cp, 10);
		cp += 10;

		if (memcmp(cTemp,"?BWordMtr?",10) != 0) return ;

		ZeroMemory(cTemp, sizeof(cTemp));

		dwp = (uint32 *)cTemp;
		*dwp = MSGID_RESPONSE_CHECKCONNECTION;

		wp  = (uint16 *)(cTemp + INDEX2_MSGTYPE);
		*wp = NULL;

		cp  = (char *)(cTemp + INDEX2_MSGTYPE + 2);
		sp  = (short *)cp;

		if ((m_bIsGameStarted == true) && (m_bIsItemAvailable == true) && 
			(m_bIsNpcAvailable == true) && (m_bIsMagicAvailable == true) &&
			(m_bIsSkillAvailable == true) && (m_bIsPortionAvailable == true) &&
			(m_bIsQuestAvailable == true)
			) {

				*sp =  1 ; 
		} 
		else 
		{
			*sp =  0 ; 
		}
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iMaxClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalGameServerClients ;
		cp += 2 ;

		sp  = (short *)cp;
		*sp = m_iTotalGameServerMaxClients ;
		cp += 2 ;

		m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16 );

	}

}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{
	CClient * player = m_pClientList[iClientH];
	if(!player || !m_bIsCrusadeMode) return;

	if(iDuty == 3)
	{
		if(!player->m_guild || !gldRankPerm[ player->m_iGuildRank ].crusadeCommander)
			return;

		for(int i = 1; i < MAXCLIENTS; i++)
		{
			if(g_clientList[i] && g_clientList[i]->m_iGuildGUID == player->m_iGuildGUID && 
				g_clientList[i]->m_iCrusadeDuty == 3)
			{
				// there's already one commander
				SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, -1, NULL, NULL);
				return;
			}
		}

		if( m_iCrusadeWinnerSide != player->m_side)
		{
			player->m_iConstructionPoint = 3000;
		}
	}


	player->m_iCrusadeDuty = iDuty;

	SendNotifyMsg(NULL, iClientH, NOTIFY_CRUSADE, (uint32)m_bIsCrusadeMode, player->m_iCrusadeDuty, NULL, NULL);
	if (iDuty == 1) 
		_bCrusadeLog(CRUSADELOG_SELECTDUTY, iClientH, NULL, "Fighter");
	else if (iDuty == 2) 
		_bCrusadeLog(CRUSADELOG_SELECTDUTY, iClientH, NULL, "Constructor");
	else
		_bCrusadeLog(CRUSADELOG_SELECTDUTY, iClientH, NULL, "Commander");
}


void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;//add in

	switch (iMode) {
	case 1:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

		for (i = 0; i < MAXGUILDS; i++) 
			if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
					NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
					NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);

				ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
				memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
				m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
				m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
				return;
			}

			break;

	case 3:
		
		for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
					if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {

			}
		}
		_SendMapStatus(iClientH);
		break;
	}
}


void CGame::_SendMapStatus(int iClientH)
{
	int i, iDataSize;
	char *cp, cData[MAXCRUSADESTRUCTURES*6];
	short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;

	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = true;

	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;

		if ((m_pClientList[iClientH]->m_iCSIsendPoint >= 3) && (m_pClientList[iClientH]->m_iCrusadeDuty != 3) )  goto SMS_ENDOFDATA;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;

	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = false;

	return;
}


bool CGame::bStockMsgToGateServer(char *pData, uint32 dwSize)
{
	char * cp;

	//testcode
	//wsprintf(g_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	//PutLogList(g_cTxt);

	if ((m_iIndexGSS + dwSize) >= MAXGATESERVERSTOCKMSGSIZE-10) return false;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return true;
}


void CGame::SendStockMsgToGateServer()
{
	uint32 * dwp;
	uint16 * wp;
	char * cp;

	if (m_iIndexGSS > 6) {
		bSendMsgToLS(MSGID_SERVERSTOCKMSG, NULL, false, m_cGateServerStockMsg);

		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		cp = (char *)m_cGateServerStockMsg;
		dwp = (uint32 *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (uint16 *)cp;
		*wp = MSGTYPE_CONFIRM;
		cp += 2;

		m_iIndexGSS = 6;
	}
}


void CGame::ServerStockMsgHandler(char *pData)
{
	char * cp, cTemp[120], cTemp2[120], cTemp3[120], cName[11], cBuffer[256];
	short * sp ;
	uint16 * wp, wServerID, wClientH, wV1, wV2, wV3, wV4 , wV5;
	uint32 * dwp;
	bool bFlag = false;
	int * ip, i, iTotal, iV1, iV2, iV3, iRet;

	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == false) {
		iTotal++;
		switch (*cp) {
		case GSM_DISCONNECT:
			ZeroMemory(cName, sizeof(cName));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;

			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex != -1) && (strcmp(m_pClientList[i]->m_cWhisperPlayerName, cName) == 0)) {
					m_pClientList[i]->m_iWhisperPlayerIndex = -1;
					SendNotifyMsg(NULL, i, NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
					goto SSMH_LOOPBREAK; 
				}
				break;

		case GSM_WHISPERMSG:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			wp = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;

			memcpy(cBuffer, cp, wV1);
			cp += wV1;

			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
					if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
						char cTxt[200],cTmpName[12] ;
						ZeroMemory(cTxt,sizeof(cTxt)) ;
						ZeroMemory(cTmpName,sizeof(cTmpName)) ;

						memcpy(cTmpName,cBuffer+10,10) ;
						wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
						bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL, cTxt);
					}
					break;
				}

				break;

		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (uint16)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;

		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;

			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;
			}
			break;

		case GSM_BEGINAPOCALYPSE:
			cp++;
			LocalStartApocalypse();
			break;

		case GSM_ENDAPOCALYPSE:
			cp++;
			LocalEndApocalypse();
			break;

		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (uint32 *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;

		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;

		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (uint16 *)cp;
			wV2 = *wp;
			cp += 2;
			break;

		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (uint16 *)cp;
			wV2 = *wp;
			cp += 2;

			switch (wV1) {
				case 1: 				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;

		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			wp  = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (uint16 *)cp;
			wV2 = *wp;
			cp += 2;
			wp  = (uint16 *)cp;
			wV3 = *wp;
			cp += 2;
			wp  = (uint16 *)cp;
			wV4 = *wp;
			cp += 2;


			wp  = (uint16 *)cp;
			wV5 = *wp;


			/*	cp++ ;


			wp  = (uint16 *)cp;
			wV5 = *wp;
			cp += 2;
			wp  = (uint16 *)cp;
			wV6 = *wp;
			cp += 2;
			wp  = (uint16 *)cp;
			wV7 = *wp;
			cp += 2;
			wp  = (uint16 *)cp;
			wV8 = *wp;
			cp += 2; */ 

			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4,wV5,cp);
			break;


		case GSM_REQUEST_SUMMONPLAYER:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;


			wp  = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (uint16 *)cp;
			wV2 = *wp;
			cp += 2;

			for (i = 1; i < MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {

#ifdef TAIWANLOG
					short sX = 0,sY = 0 ;
					char cMapName[22] ; 

					ZeroMemory(cMapName,sizeof(cMapName)) ;

					sX = m_pClientList[i]->m_sX ;
					sY = m_pClientList[i]->m_sY ;
					strcpy(cMapName, m_pClientList[i]->m_cMapName) ;

					m_pClientList[i]->m_sX = wV1;
					m_pClientList[i]->m_sY = wV2;
					strcpy(m_pClientList[i]->m_cMapName, cTemp) ;

					_bItemLog(ITEMLOG_SUMMONPLAYER, i, cTemp2,NULL) ;

					m_pClientList[i]->m_sY = sY ; 
					m_pClientList[i]->m_sX = sX ;

					strcpy(m_pClientList[i]->m_cMapName,cMapName) ;

#endif
					RequestTeleportHandler(i, 2, cTemp ,wV1, wV2);
					break;
				}
				break ;


		case GSM_REQUEST_SHUTUPPLAYER:
			cp++;
			wp = (uint16 *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (uint16 *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);

			break ;

		case GSM_RESPONSE_SHUTUPPLAYER:
			cp++;
			wp = (uint16 *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (uint16 *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			if (wServerID == GSID) {
				if ((m_pClientList[wClientH] != NULL)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
					SendNotifyMsg(NULL, wClientH, NOTIFY_PLAYERSHUTUP, wV1, NULL, NULL, cTemp);
				}
			}
			break;

		case GSM_REQUEST_FINDCHARACTER:
			cp++;
			wp = (uint16 *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (uint16 *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			GSM_RequestFindCharacter(wServerID, wClientH, cTemp,cTemp2);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			cp++;
			wp = (uint16 *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (uint16 *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			ZeroMemory(cTemp3, sizeof(cTemp3));
			memcpy(cTemp3, cp, 14);
			cp += 14;

			if (wServerID == GSID) {
				if (m_pClientList[wClientH] != NULL) {
					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer == true) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
						m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer = false;
						SendNotifyMsg(NULL, wClientH, NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[wClientH]->m_cWhisperPlayerName);
					}
					else{
						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) 
							ZeroMemory(cTemp3, sizeof(cTemp3));

						if (strcmp(m_pClientList[wClientH]->m_cCharName,cTemp2) == 0)
							SendNotifyMsg(NULL, wClientH, NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp, NULL, NULL, NULL, NULL, NULL, NULL, cTemp3);
					}
				}
			}
			break;

		case GSM_REQUEST_FINDFRIEND:
			cp++;
			wp = (uint16 *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (uint16 *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			wp = (uint16 *)cp;
			wV1 = *wp;
			cp += 2;

			GSM_RequestFindFriend(wServerID, wClientH, cTemp,cp, wV1);
			cp += wV1;
			break;

		case GSM_RESPONSE_FINDFRIEND:
			cp++;
			wp = (uint16 *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (uint16 *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			if (wServerID == GSID)
				if (m_pClientList[wClientH] != NULL)
					if (strcmp(m_pClientList[wClientH]->m_cCharName,cTemp) == 0)
						SendNotifyMsg(NULL, wClientH, NOTIFY_FRIENDONGAME, NULL, NULL, NULL, cTemp2, NULL, NULL, NULL, NULL, NULL, NULL, "");
			break;

		case GSM_REQUEST_SETFORCERECALLTIME:
			cp++;
			wp = (uint16 *)cp;
			m_sForceRecallTime = *wp;
			cp += 2;

			wsprintf(g_cTxt,"(!) GSM: Force Recall Time (%d)min",m_sForceRecallTime) ;
			PutLogList(g_cTxt) ;

		default:
			bFlag = true;
			break;
		}

SSMH_LOOPBREAK:;
	}

	//testcode
	//wsprintf(g_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(g_cTxt);
}

void CGame::GSM_RequestFindFriend(uint16 reqServerID, uint16 reqClientH, char * requesterName, char * names, uint16 nameSize){
	char * cp, response[120];
	uint16 * wp;
	char   seps[] = ", ";
	char   * token, friendName[11];
	int i;

	StrTok pStrTok(new CStrTok(names, seps));
	token = pStrTok->pGet();

	for (int j = 0;token != NULL && j < 13; j++) {
		if(strlen(token) == 0) continue;
		ZeroMemory(friendName, sizeof(friendName));
		if (strlen(token) > 10)	memcpy(friendName, token, 10);
		else memcpy(friendName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, friendName, 10) == 0)) {
				ZeroMemory(response, sizeof(response));
				cp = (char *)(response);
				*cp = GSM_RESPONSE_FINDFRIEND;
				cp++;

				wp = (uint16 *)cp;
				*wp = reqServerID;
				cp += 2;

				wp = (uint16 *)cp;
				*wp = reqClientH;
				cp += 2;

				memcpy(cp, requesterName, 10);
				cp += 10;

				memcpy(cp, friendName, 10);
				cp += 10;

				bStockMsgToGateServer(response, 25);
			}
			token = pStrTok->pGet();
	}
}


void CGame::GSM_RequestShutupPlayer(char * pGMName,uint16 wReqServerID, uint16 wReqClientH, uint16 wTime,char * pPlayer )
{
	char * cp, cTemp[120];
	uint16 * wp;
	int i;

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {

			ZeroMemory(cTemp, sizeof(cTemp));
			cp = (char *)(cTemp);
			*cp = GSM_RESPONSE_SHUTUPPLAYER;
			cp++;

			wp = (uint16 *)cp;
			*wp = wReqServerID;
			cp += 2;

			wp = (uint16 *)cp;
			*wp = wReqClientH;
			cp += 2;

			memcpy(cp, pGMName, 10);
			cp += 10;

			wp = (uint16 *)cp;
			*wp = (uint16) wTime;
			cp += 2;

			memcpy(cp, pPlayer, 10);
			cp += 10;


			m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; 

			SendNotifyMsg(NULL, i, NOTIFY_PLAYERSHUTUP, wTime, NULL, NULL, pPlayer);

#ifdef TAIWANLOG

			_bItemLog(ITEMLOG_SHUTUP,i,pGMName,NULL) ;

			// Admin Log

			wsprintf(g_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min",pGMName, 
				m_pClientList[i]->m_cCharName, wTime);

			bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL,g_cTxt);
#endif

			bStockMsgToGateServer(cTemp, 27);
			return;
		}
}

void CGame::GSM_RequestFindCharacter(uint16 wReqServerID, uint16 wReqClientH, char *pName,char * cRequestCharName)
{
	char * cp, cTemp[120];
	uint16 * wp;
	int i;

	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {

			ZeroMemory(cTemp, sizeof(cTemp));
			cp = (char *)(cTemp);
			*cp = GSM_RESPONSE_FINDCHARACTER;
			cp++;

			wp = (uint16 *)cp;
			*wp = wReqServerID;
			cp += 2;

			wp = (uint16 *)cp;
			*wp = wReqClientH;
			cp += 2;

			memcpy(cp, pName, 10);
			cp += 10;

			memcpy(cp, cRequestCharName, 10);
			cp += 10;


			memcpy(cp, m_pClientList[i]->m_cMapName, 10) ;
			cp += 10 ;

			wp = (uint16 *)cp;
			*wp =(uint16) m_pClientList[i]->m_sX;
			cp += 2;

			wp = (uint16 *)cp;
			*wp = (uint16) m_pClientList[i]->m_sY;
			cp += 2;

			bStockMsgToGateServer(cTemp, 39);
			return;
		}
}

void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;
 uint32 dwTime = timeGetTime();
	if (!m_bIsCrusadeMode) return;

	for (i = 1; i < MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_side != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		iDamage = dice(1, m_pClientList[i]->m_iLevel*3);
		if (m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_PROTECT ] == 2) {
			iDamage = (iDamage/2) - 2;
		}
		if (m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_PROTECT ] == 5) {
			iDamage = 0;
		}		
		if (m_pClientList[i]->IsInvincible()) {
			iDamage = 0;
		}
		if (iDamage > 400) iDamage = 400;	
		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			m_pClientList[i]->KilledHandler(NULL, NULL, iDamage);
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				SendNotifyMsg(NULL, i, NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_MOTION_DAMAGE, iDamage, NULL, NULL);
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}			
				if (m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] != 0) { // 100% unPara
					SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ], NULL, NULL);
					m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					RemoveFromDelayEventList(i, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);
	}	}	}	}
}
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
	int i, iActiveStructure, iStructureHP[MAXSTRIKEPOINTS];
	char * cp, * cp2, cData[120], cWinnerSide, cTempData[120], g_cTxt[120];
	uint16 * wp;
	if (!m_bIsCrusadeMode) return;
	for(i = 0 ; i < MAXSTRIKEPOINTS; i++)
	iStructureHP[i] = 0;
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	if (MAXSTRIKEPOINTS > 6)
	{	wsprintf(g_cTxt, "ActiveStructure:%d  MapIndex:%d Life: %d %d %d %d %d %d", iActiveStructure, iMapIndex, iStructureHP[1], iStructureHP[2], iStructureHP[3], iStructureHP[4], iStructureHP[5], iStructureHP[6]);
		PutLogList(g_cTxt);		
	}
	if (iActiveStructure == 0) {	
		if (iMapIndex == m_iAresdenMapIndex) {	
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); 
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); 
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0);
		}

		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;
		*cp = cWinnerSide;
		cp++;
		wp  = (uint16 *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;
		bStockMsgToGateServer(cData, 18);
	} else {	
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;
		wp  = (uint16 *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;
		wp  = (uint16 *)cp;
		*wp = (uint16) iActiveStructure;
		cp += 2;
		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 
		wp = (uint16 *)cp2;
		*wp = (uint16) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;
		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++)
		{	wp = (uint16 *)cp2;
			*wp = (uint16) iStructureHP[i];
			cp2 += 2;
		}
		memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;
		bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure,m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}



void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iSTcount,char * pData)
{
	int i;
	if (!m_bIsCrusadeMode) return;
	for (i = 1; i < MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			SendNotifyMsg(NULL, i, NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure,0,0,0,0,iSTcount,pData);
		}
}

void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
	char * cp, cBuff[120];
	uint16 * wp;
	if (!m_bIsCrusadeMode) return;
	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (uint16 *)cp;
	*wp = (uint16)iType;
	cp += 2;

	wp = (uint16 *)cp;
	*wp = (uint16)cAttackerSide;
	cp += 2;

	bStockMsgToGateServer(cBuff, 5);
}


void CGame::SyncMiddlelandMapInfo()
{
	int i;
	char * cp;
	short * sp;
	if (!m_bIsCrusadeMode) return;
	if (m_iMiddlelandMapIndex != -1) {
		for (i = 0; i < MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;

		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;

			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}

		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//wsprintf(g_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(g_cTxt);
			bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
	int i, iIndex;
	uint32 dwTemp, dwTime;
	if (!m_bIsCrusadeMode) return;

	dwTime = timeGetTime();

	for (i = 0; i < MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
		}
		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
					iIndex = i;
				}
			}
		}
		if (iIndex == -1) return;
		m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
		m_pGuildTeleportLoc[i].m_sDestX = dX;
		m_pGuildTeleportLoc[i].m_sDestY = dY;
		ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
		strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
		m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
	int i, iIndex;
	uint32 dwTemp, dwTime;
	if (!m_bIsCrusadeMode) return;

	dwTime = timeGetTime();

	for (i = 0; i < MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
		}	
		dwTemp = 0;
		iIndex = -1;
		for (i = 0; i < MAXGUILDS; i++) {
			if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
					iIndex = i;
				}
			}
		}
		if (iIndex == -1) return;
		m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
		m_pGuildTeleportLoc[i].m_sDestX2 = dX;
		m_pGuildTeleportLoc[i].m_sDestY2 = dY;
		ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
		strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
		m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}


void CGame::GlobalStartCrusadeMode()
{
	char * cp, cData[120];
	uint32 * dwp, dwCrusadeGUID;
	SYSTEMTIME SysTime;
	if (m_bIsCrusadeMode) return;
	GetLocalTime(&SysTime);

	dwCrusadeGUID = timeGetTime();

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (uint32 *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
	char * cp, cData[120];
	int  * ip, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (!m_bIsCrusadeMode) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: 
	case 2: 
		for (i = 0; i < MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
				(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
					m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;

					m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 6);

					if (m_pClientList[i]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

					if (m_pClientList[i]->m_iWarContribution > MAXWARCONTRIBUTION)
						m_pClientList[i]->m_iWarContribution = MAXWARCONTRIBUTION;

					SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					m_pClientList[iClientH]->m_iConstructionPoint = 0; 
					return;
			}


			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			*cp = GSM_CONSTRUCTIONPOINT;
			cp++;
			ip = (int*)cp;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp += 4;
			ip = (int*)cp;
			*ip = m_pClientList[iClientH]->m_iConstructionPoint;
			cp += 4;
			bStockMsgToGateServer(cData, 9);

			m_pClientList[iClientH]->m_iConstructionPoint = 0; 
			break;
	}
}



void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
	int i;
	if (!m_bIsCrusadeMode) return;
	for (i = 1; i < MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {

				m_pClientList[i]->m_iConstructionPoint += iPoint;
				m_pClientList[i]->m_iWarContribution   += iPoint/6;

				if (m_pClientList[i]->m_iConstructionPoint > MAXCONSTRUCTIONPOINT) 
					m_pClientList[i]->m_iConstructionPoint = MAXCONSTRUCTIONPOINT;

				if (m_pClientList[i]->m_iWarContribution > MAXWARCONTRIBUTION)
					m_pClientList[i]->m_iWarContribution = MAXWARCONTRIBUTION;

				SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
				return;
		}
}



bool CGame::bAddClientShortCut(int iClientH)
{
	int i; 

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == iClientH) return false;

	for (i = 0; i < MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == 0) {
			m_iClientShortCut[i] = iClientH;
			return true;
		}

	return false;
}

void CGame::RemoveClientShortCut(int iClientH)
{
	int i;

	for (i = 0; i < MAXCLIENTS+1; i++)
		if (m_iClientShortCut[i] == iClientH) {
			m_iClientShortCut[i] = 0;
			break;
		}

	for (i = 0; i < MAXCLIENTS; i++)
		if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
			m_iClientShortCut[i] = m_iClientShortCut[i+1];
			m_iClientShortCut[i+1] = 0;
		}
}

void CGame::_CreateCrusadeGUID(uint32 dwCrusadeGUID, int m_iCrusadeWinnerSide)
{
	char * cp, cTxt[256], cFn[256], cTemp[1024];
	FILE * pFile;

	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));

	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {

		wsprintf(cTxt, "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", m_iCrusadeWinnerSide);
		strcat(cTemp, cTxt);

		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}


bool CGame::bReadCrusadeGUIDFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32  dwFileSize;
	char * cp, * token, cReadMode;
	char seps[] = "= \t\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {

		PutLogList("(!) Cannot open CrusadeGUID file.");
		return false;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();

		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					wsprintf(g_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(g_cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iCrusadeWinnerSide = atoi(token);
					wsprintf(g_cTxt, "CrusadeWinnerSide = %d", m_iCrusadeWinnerSide);
					PutLogList(g_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}

			token = pStrTok->pGet();
		}

		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);

	return true;
}


void CGame::ManualEndCrusadeMode(int m_iCrusadeWinnerSide)
{
	char * cp, cData[256];
	uint16 * wp;

	if (!m_bIsCrusadeMode) return;
	LocalEndCrusadeMode(m_iCrusadeWinnerSide);

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)m_iCrusadeWinnerSide;
	cp++;

	wp  = (uint16 *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (uint16 *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (uint16 *)cp;
	*wp = NULL;
	cp += 2;

	cp += 10;

	bStockMsgToGateServer(cData, 18);
}

int CGame::iGetMapLocationSide(char *pMapName)
{
	uint32 length = strlen(pMapName);

	if(length == 0) return 0;

	ASSERT(length <= 11);
	if(pMapName[ length - 2] == '_')
	{
		switch(pMapName[ length - 1])
		{
			case '1':
				return ARESDEN;
			case '2':
				return ELVINE;
			case '3':
				return ISTRIA;
		}
	}

	
	if (strcmp(pMapName, sideMap[ARESDEN]) == 0) return ARESDEN + 10 ;
	if (strcmp(pMapName, sideMap[ELVINE]) == 0)  return ELVINE + 10 ;
	if (strcmp(pMapName, sideMap[ISTRIA]) == 0)  return ISTRIA + 10 ;
	if (memcmp(pMapName, "arebrk11", 8) == 0) return ARESDEN + 10 ;
	if (memcmp(pMapName, "elvbrk11", 8) == 0) return ELVINE + 10 ;
	if (memcmp(pMapName, "istbrk1", 7) == 0) return ISTRIA + 10 ;

	if (memcmp(pMapName, "arefarm", 7) == 0) return ARESDEN ;
	if (memcmp(pMapName, "elvfarm", 7) == 0) return ELVINE ;
	if (memcmp(pMapName, "istfarm", 7) == 0) return ISTRIA ;

	if (memcmp(pMapName, "arewrhus", 8) == 0) return ARESDEN ;
	if (memcmp(pMapName, "elvwrhus", 8) == 0) return ELVINE ;
	if (memcmp(pMapName, "istwrhus", 8) == 0) return ISTRIA ;

	/*  memcmp    .
	if (memcmp(pMapName, "gshop_1f") == 0) return 1;
	if (memcmp(pMapName, "bsmith_1f") == 0) return 1;
	if (memcmp(pMapName, "wrhus_1f") == 0) return 1;

	if (memcmp(pMapName, "gshop_2f") == 0) return 2;
	if (memcmp(pMapName, "bsmith_2f") == 0) return 2;
	if (memcmp(pMapName, "wrhus_2f") == 0) return 2; */


	return 0;
}

bool CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return false;
	if (pCopy == NULL) return false;

	pCopy->m_sIDnum = pOriginal->m_sIDnum;
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;

	//short m_sSM_HitRatio, m_sL_HitRatio;

	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;

	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;

	return true;
}

void CGame::Scheduler()
{
	SYSTEMTIME SysTime;
	SYSTEMTIME announce2, announce30, announce10;
	GetLocalTime(&SysTime);
	announce2 = announce30 = announce10 = SysTime;
	announce2.wHour += 2;
	announce30.wMinute += 30;
	if(announce30.wMinute >= 60)
	{
		announce30.wHour++;
		announce30.wMinute -= 60;
	}
	announce10.wMinute += 10;
	if(announce10.wMinute >= 60)
	{
		announce10.wHour++;
		announce10.wMinute -= 60;
	}

	for (int i = 0; i < m_schedulesCnt; i++)
	{
		if (m_schedules[i] == SysTime && m_schedules[i].evStatus != ES_STARTED)
		{
			m_schedules[i].evStatus = ES_STARTED;
			switch(m_schedules[i].evType)
			{
			case ET_CAPTURE:
			case ET_DESTROY_SHIELD:
				EventStart(m_schedules[i].evType);
				break;
			case ET_CRUSADE:
				GlobalStartCrusadeMode();
				break;
			case ET_APOCALYPSE:
				GlobalStartApocalypseMode();
				break;
			}
		}
		else if (m_schedules[i].evStatus != ES_ANNOUNCED_ONCE &&
			m_schedules[i] == announce2)
		{
			m_schedules[i].evStatus = ES_ANNOUNCED_ONCE;
			int shortCutIndex = 0;
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				SendNotifyMsg(NULL, index, NOTIFY_EVENTSTARTING, m_schedules[i].evType, NULL, NULL, NULL);
			}
		}
		else if (m_schedules[i].evStatus != ES_ANNOUNCED_TWICE &&
			m_schedules[i] == announce30)
		{
			m_schedules[i].evStatus = ES_ANNOUNCED_TWICE;
			int shortCutIndex = 0;
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				SendNotifyMsg(NULL, index, NOTIFY_EVENTSTARTING2, m_schedules[i].evType, NULL, NULL, NULL);
			}
		}
		else if (m_schedules[i].evStatus != ES_ANNOUNCED_THRICE &&
			m_schedules[i] == announce10)
		{
			m_schedules[i].evStatus = ES_ANNOUNCED_THRICE;
			int shortCutIndex = 0;
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				SendNotifyMsg(NULL, index, NOTIFY_EVENTSTARTING3, m_schedules[i].evType, NULL, NULL, NULL);
			}
		}
		else if(m_schedules[i].evStatus != ES_ANNOUNCED_ONCE &&
			m_schedules[i].evStatus != ES_ANNOUNCED_TWICE &&
			m_schedules[i].evStatus != ES_ANNOUNCED_THRICE)
		{
			m_schedules[i].evStatus = ES_ENDED;
		} 
	}
}

bool CGame::bReadSchedulerConfigFile(char *pFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32  dwFileSize;
	char * cp, * token, cReadModeA, cReadModeB;
	char seps[] = "= \t\n";

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {

		PutLogList("(!) Cannot open Scheduler file.");
		return false;
	}
	else {
		PutLogList("(!) Reading Scheduler file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok strTok(new CStrTok(cp, seps));
		token = strTok->pGet();

		while(token)
		{
			if(cReadModeA != 0) {
				switch (cReadModeA) 
				{
				case 1:
					switch (cReadModeB) 
					{
					case 1:
						if (m_schedulesCnt >= MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many events in scheduler!"); 
							return true;
						}
						if(memcmp(token, "CTR", 3) == 0)
						{
							m_schedules[m_schedulesCnt].evType = ET_CAPTURE;
						}else if(memcmp(token, "DS", 2) == 0)
						{
							m_schedules[m_schedulesCnt].evType = ET_DESTROY_SHIELD;
						}else if(memcmp(token, "Crusade", 7) == 0)
						{
							m_schedules[m_schedulesCnt].evType = ET_CRUSADE;
						}else if(memcmp(token, "Apocalypse", 10) == 0)
						{
							m_schedules[m_schedulesCnt].evType = ET_APOCALYPSE;
						}else
						{
							cReadModeA = 0;
							cReadModeB = 0;
							break;
						}
						cReadModeB++;
						break;
					case 2:
						m_schedules[m_schedulesCnt].iDay = atoi(token);
						cReadModeB++;
						break;
					case 3:
						m_schedules[m_schedulesCnt].iHour = atoi(token);
						cReadModeB++;
						break;
					case 4:
						m_schedules[m_schedulesCnt].iMinute = atoi(token);
						m_schedulesCnt++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;
				}
			}
			else {
				if (memcmp(token, "event", 5) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}

			token = strTok->pGet();
		}
		delete[] cp;
	}
	if (pFile) fclose(pFile);

	return true;
}

void CGame::KillCrusadeObjects()
{
	int i;

	for (i = 1; i < MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			switch (m_pNpcList[i]->m_sType) 
			{
			case NPC_LWB:
			case NPC_GHK:
			case NPC_GHKABS:
			case NPC_TK:
			case NPC_BG:
			case NPC_CP:
			case NPC_AGT:
			case NPC_CGT:
			case NPC_MS:
			case NPC_DT:
			case NPC_ESG:
			case NPC_GMG:
			case NPC_MANASTONE:
				NpcKilledHandler(NULL, NULL, i, 0);
				break;
			}
		}
}





void CGame::AdminOrder_GetFightzoneTicket(int iClientH)
{
	int iReserveTime, iFightzoneTN, iFightzoneN;
	char cTemp[21];
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) {

		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +3);  

		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);

		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
	else {
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +2);  

		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = 1;

		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
}



void CGame::ResurrectPlayer(int iClientH)
{
	//testcode
	PutLogList("(*) Resurrect Player!");


	RemoveFromTarget(iClientH, OWNERTYPE_PLAYER);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(/*13,*/ iClientH, OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX,  m_pClientList[iClientH]->m_sY);

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_EVENT_REJECT, NULL, NULL, NULL);

	GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP();
	//m_pClientList[iClientH]->m_iMP = (2*m_pClientList[iClientH]->GetMag()) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->GetInt()/2);
	m_pClientList[iClientH]->m_iMP = m_pClientList[iClientH]->GetMaxMP();
	//m_pClientList[iClientH]->m_iSP = (2*m_pClientList[iClientH]->GetStr()) + (2*m_pClientList[iClientH]->m_iLevel);
	m_pClientList[iClientH]->m_iSP = m_pClientList[iClientH]->GetMaxSP();
	m_pClientList[iClientH]->m_bIsKilled = false;

	//RequestInitDataHandler(iClientH);
	return;
}

void CGame::RequestDismissPartyHandler(int iClientH)
{
	CClient * player = m_pClientList[iClientH];
	if(!player) return;

	partyMgr.RemoveFromParty( player );
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char *cp, cData[120];
	uint32 * dwp;
	uint16 * wp;
	int iH;

	CClient * requestee, * player = m_pClientList[iClientH];

	if(!player) return;

	switch (iResult)
	{
	case 0: // declined
		iH = player->m_iReqJoinPartyClientH;
		if(!m_pClientList[iH] ||
			strcmp(m_pClientList[iH]->m_cCharName, player->m_cReqJoinPartyName) != 0 ||
			m_pClientList[iH]->GetParty() || 
			m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH || 
			strcmp(m_pClientList[iH]->m_cReqJoinPartyName, player->m_cCharName) != 0) 
		{
			return;
		}

		SendNotifyMsg(NULL, iH, NOTIFY_PARTY, 7, 0, NULL, NULL);
		
		player->SetParty( NULL );
		m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		player->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(player->m_cReqJoinPartyName, sizeof(player->m_cReqJoinPartyName));
		break;

	case 1: // accept
		requestee = m_pClientList[ player->m_iReqJoinPartyClientH ];
		if (!requestee || strcmp(requestee->m_cCharName, player->m_cReqJoinPartyName) != 0 || 
			requestee->GetParty() ||
			requestee->m_iReqJoinPartyClientH != iClientH || 
			strcmp(requestee->m_cReqJoinPartyName, player->m_cCharName) != 0) 	
		{
			return;
		}

		ASSERT(requestee->m_pXSock);
		if(!requestee->m_pXSock) return;

		if(player->GetParty())
		{
			player->GetParty()->AddPlayer( requestee );
		}
		else
		{
			partyMgr.CreateParty( player, requestee );
		}
		break;

	case 2: // player cancelled request
		if(player->GetParty())
		{
			partyMgr.RemoveFromParty( player );
		}
		else
		{
			iH = player->m_iReqJoinPartyClientH;

			if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) && 
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, player->m_cCharName) == 0)) {
					m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
			}

			player->SetParty( NULL );
			player->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(player->m_cReqJoinPartyName, sizeof(player->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::GetExp(int iClientH, int iExp, bool bIsAttackerOwn)
{
	double dV1, dV2, dV3;
	int iUnitValue;
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (iExp <= 0) return;

	if (player->m_iLevel <= 80) {
		dV1 = (double)(80 - player->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (int)dV1;
	}
	else {
		if ((player->m_iLevel >= 100) &&((strcmp(m_pMapList[player->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[player->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
				iExp = (iExp/10) ;
		}
		else if ((strcmp(m_pMapList[player->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[player->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
				iExp = (iExp*1/4) ;
		}
	}

	CParty * party = player->GetParty();

	if(dwTime - player->m_dwLastActionTime >= 5 _m)
		return;

	if(party)
	{
		if(iExp >= 10 && party->GetPlayerCnt() > 1)
		{
			int iPartyTotalMember = party->GetAlivePlayerCnt();

			dV1 = (double)iExp;

			if(iPartyTotalMember == 1)	dV2 = dV1;
			else dV2 = (dV1 * ((log((float)(iPartyTotalMember +2)*9)/9)+0.65)) / iPartyTotalMember;

			dV3 = dV2 + 0.5f;
			iUnitValue = (int)dV3;

			while(CClient * member = party->GetMembers())
			{
				if(member->IsDead())
					continue;

				uint32 exp = 0;
				if(member->m_iLevel == PLAYERMAXLEVEL)
					exp += (iUnitValue/3);
				else
					exp += iUnitValue;

				if((member->m_iStatus & STATUS_GREENSLATE) != 0)
					exp *= 3;

				member->m_iExpStock += exp;
			}

			if((player->m_iStatus & STATUS_GREENSLATE) != 0) iUnitValue *= 3;
			if(player->m_iLevel == PLAYERMAXLEVEL)
				iUnitValue /= 3;
			if ((bIsAttackerOwn == true) && (iPartyTotalMember > 1))
				player->m_iExpStock += (int)(iUnitValue/10);

		}
		else
		{
			if((player->m_iStatus & STATUS_GREENSLATE) != 0) iExp *= 3;
			if(player->m_iLevel == PLAYERMAXLEVEL)
				iExp /= 3;
			player->m_iExpStock += iExp;
		}
	} // if
	else
	{
		if((player->m_iStatus & STATUS_GREENSLATE) != 0) iExp *= 3;
		if(player->m_iLevel == PLAYERMAXLEVEL)
			iExp /= 3;
		player->m_iExpStock += iExp;
	}
}

void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int i, iValue,  iItemX,iItemY, iSoM, iSoX, iSomH, iSoxH;
	uint32 dwTemp, dwSWEType, dwColor;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	if (m_pClientList[iClientH] == NULL) return;
	if ((iItemIndex < 0) || (iItemIndex >= MAXITEMS)) return;
	if(!m_pClientList[iClientH]->m_pItemList[iItemIndex] || 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_disabled) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0 ) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
		return;
	}

	/*wsprintf(g_cTxt, "value (%d)", iValue);
	PutLogList(g_cTxt);
	wsprintf(g_cTxt, "Weapon (%d)", m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);
	PutLogList(g_cTxt);*/

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) 
	{
	case 46: // Pendants
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType != 1) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are type 1
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are left finger or more
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType != 14) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are EffectType 14
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) 
		{
		default: // Other items are not upgradable
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);   
			return; // Pendants are EffectType 14
		case 16: // AngelicPendant(STR)
		case 17: // AngelicPendant(DEX)
		case 18: // AngelicPendant(INT)
		case 19: // AngelicPendant(MAG)
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			if(iValue >= 15) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}
			switch (iValue) {
			case 0: sItemUpgrade = 6; break;
			case 1: sItemUpgrade = 8; break;
			case 2: sItemUpgrade = 10; break;
			case 3: sItemUpgrade = 13; break;
			case 4: sItemUpgrade = 16; break;
			case 5: sItemUpgrade = 20; break;
			case 6: sItemUpgrade = 24; break;
			case 7: sItemUpgrade = 29; break;
			case 8: sItemUpgrade = 34; break;
			case 9: sItemUpgrade = 39; break;
			case 10: sItemUpgrade = 44; break;
			case 11: sItemUpgrade = 49; break;
			case 12: sItemUpgrade = 54; break;
			case 13: sItemUpgrade = 59; break;
			case 14: sItemUpgrade = 64; break;
			default:
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return;
			}

			if (   (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) 
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) 
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3)) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}
			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue++;
			if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			return;
		}
		break;
	case 1: //Weapons
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{
		case ITEM_DKFLAMEBERG:
		case ITEM_DKGIANTSWORD:
		case ITEM_BLACKKNIGHTTEMPLE:
		case ITEM_DKRAPIER:
		case ITEM_DKGREATSWORD:
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			sItemUpgrade = (iValue*(iValue+6)/8) + 2;

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}

			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0)
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 

			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

			if ((iValue == 2) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_DKFLAMEBERG)) 
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_DKGIANTSWORD);
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );

				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else if ((iValue == 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_DKGIANTSWORD))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_BLACKKNIGHTTEMPLE);
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;

			} 
			else if ((iValue == 14) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_BLACKKNIGHTTEMPLE))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_BLACKKNIGHTTEMPLE);
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwColor = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor;
				dwColor = 9; 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = dwColor;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			} 
			else 
			{
				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			break;
		case 717:  // DKRapier
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			sItemUpgrade = (iValue*(iValue+6)/8) + 2;

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}

			if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 

			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);
			iValue += 1;
			if (iValue > 7) iValue = 7;
			dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
			dwTemp = dwTemp& 0x0FFFFFFF;
			m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

			break;
		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == ITEMSTAT_ANCIENT) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) 
					{
					case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
					case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
					}
				}
				if (iSoX > 0) {
					if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
						if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, false);
						ItemDepleteHandler(iClientH, iSoxH, false); 
						return;
					}

					if(m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsManued())
					{
						iValue++;
						if (iValue > 10) 
							iValue = 10;
						else {
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp& 0x0FFFFFFF;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
							ItemDepleteHandler(iClientH, iSoxH, false);
						}
					}
					else {
						iValue++;
						if (iValue > 7) 
							iValue = 7;
						else {
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp& 0x0FFFFFFF;
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
							ItemDepleteHandler(iClientH, iSoxH, false);
						}
					}
				}

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		break;

	case 3: // Bows
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;

	case 5: // Shields

		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) {
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum)
		{
		case ITEM_MERIENSHIELD:
		case ITEM_GM_SHIELD:
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;
		default: break;
		}

		iSoX = iSoM = 0;
		for (i = 0; i < MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) 
				{
				case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
				case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
				}
			}

			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,true) == false) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; 
					if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, false); 
					ItemDepleteHandler(iClientH, iSomH, false); 
					return;
				}

				iValue++;
				if (iValue > 10) 
					iValue = 10;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					if(m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsManued())
					{
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					ItemDepleteHandler(iClientH, iSomH, false); 
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;


	case 12: //Cape
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{
		case ITEM_ARESDENHEROCAPE:
		case ITEM_ELVINEHEROCAPE:
		case ITEM_CAPE:

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}

			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum)
					{
					case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
					case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
					}
				}

			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,true) == false) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, false);
					return;
				}

				if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_CAPE))
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;

					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
									
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_CAPE_ADD1);
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp;

					if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					iValue++;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
					_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					m_pClientList[iClientH]->m_iContribution = m_pClientList[iClientH]->m_iContribution - 50;
					ItemDepleteHandler(iClientH, iSomH, false); 
					return;
				}

				if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_ARESDENHEROCAPE) && (m_pClientList[iClientH]->m_iContribution >= 50))
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_ARESDENHEROCAPE_ADD1);
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

					if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;


					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
					_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					m_pClientList[iClientH]->m_iContribution = m_pClientList[iClientH]->m_iContribution - 50;
					ItemDepleteHandler(iClientH, iSomH, false); 
					return;
				}

				if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == ITEM_ELVINEHEROCAPE) && (m_pClientList[iClientH]->m_iContribution >= 50))
				{

					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
					
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_ELVINEHEROCAPE_ADD1);
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

					if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;


					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
					_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					m_pClientList[iClientH]->m_iContribution = m_pClientList[iClientH]->m_iContribution - 50;
					ItemDepleteHandler(iClientH, iSomH, false); 
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;
		}
		break;

	case 11: //Robes
	case 13: //Cape+1
	case 15: //Costume
	case 6:  //Armor
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{
		case 621: // MerienPlateMailM
		case 622: // MerienPlateMailW
		case 700: // SangAhHauberk
		case 701: // SangAhFullHel 
		case 702: // SangAhLeggings
		case 704: // SangAhPlateMail

		case 706: // DKHauberk
		case 707: // DKFullHelm
		case 708: // DKLeggings
		case 710: // DKPlateMail
		case 711: // DMHauberk
		case 712: // DMChainMail
		case 713: // DMLeggings
		case 724: // DKHauberkW
		case 725: // DKFullHelmW
		case 726: // DKLeggingsW
		case 728: // DKPlateMailW
		case 729: // DMHauberkW
		case 730: // DMChainMailW
		case 731: // DMLeggingsW

		case 716: // DMLedderArmor
		case 719: // DMScaleMail
		case 775: // DMLArmorW
		case 776: // DMScaleMailW
		case 733: // DMRobeW
		case 715: // DMRobe

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
			return;

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				if (dwSWEType == 8) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
					return;
				}
			}
			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case ITEM_STONEOFXELIMA: iSoX++; iSoxH = i; break;
					case ITEM_STONEOFMERIEN: iSoM++; iSomH = i; break;
					}
				}

				if (iSoM > 0) {
					if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,true) == false) {
						SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
						if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, false);
						ItemDepleteHandler(iClientH, iSomH, false); 
						return;
					}
					iValue++;
					if (iValue > 10) 
						iValue = 10;
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp& 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

						if(m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsManued())
						{
							dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
							dV2 = 0.2f * dV1;
							dV3 = dV1 + dV2;
						}
						else {
							dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
							dV2 = 0.15f * dV1;
							dV3 = dV1 + dV2;
						}
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
						if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
						ItemDepleteHandler(iClientH, iSomH, false); 
					}
				}
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;
		}
		break;

	case 8: //Wands
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) 
		{

		case ITEM_DMMAGICSTAFF:
		case ITEM_DMMAGICWAND:
		case ITEM_BLACKMAGETEMPLE:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL);
				return; 
			}

			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			sItemUpgrade = (iValue*(iValue+6)/8) + 2;

			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
			{ 
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL);
				return; 
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

			if (iValue == 0 ){
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			}

			if( (iValue == 2) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 724) )
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
				
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_DMMAGICWAND);
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}

			if ((iValue == 6) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 725)) {
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_BLACKMAGETEMPLE);
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 2;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}

			if ((iValue == 14) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 726)) {

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem((ItemID)ITEM_BLACKMAGETEMPLE);
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (!m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsValid()) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					return;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = ITET_UNIQUE_OWNER;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwColor = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor;
				dwColor = 9; 
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = dwColor;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONEITEMCHANGE, iItemIndex, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute );
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break; 
			}
			else
			{
				iValue += 2;
				if (iValue > 15) iValue = 15; 
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp& 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
				_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
		default:
			iSoX = iSoM = 0;
			for (i = 0; i < MAXITEMS; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) 
					{
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
					}
				}
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
					SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 3) ItemDepleteHandler(iClientH, iItemIndex, false);
					ItemDepleteHandler(iClientH, iSoxH, false); 
					return;
				}

				iValue++;
				if (iValue > 7) 
					iValue = 7;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp& 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, false);
				}
			 }

			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
			break;
		}
		break;
		/* case 13:  switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 715:  case 733:   if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;
		break;

		default:
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
		}
		break;
		*/
	default:
		SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
	}
}



bool CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, bool bBonus)
{
	int iValue, iProb, iResult;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return false;
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 30; break; 
	case 1: iProb = 25; break;
	case 2: iProb = 20; break;
	case 3: iProb = 15; break;
	case 4: iProb = 10; break;
	case 5: iProb = 10; break;
	case 6: iProb =  8; break;
	case 7: iProb =  8; break;
	case 8: iProb =  5; break;
	case 9: iProb =  3; break;
	default: iProb = 1; break;
	}

	if(m_pClientList[iClientH]->m_pItemList[iItemIndex]->IsManued() && 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100) 
	{
		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus == true) iProb *=2 ;

	iProb *= 100;
	iResult = dice(1,10000);

	if (iProb >= iResult) {
		_bItemLog(ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return true;
	}

	_bItemLog(ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return false;
}


void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
	int iTemp;

	if (m_pClientList[iAttackerH] == NULL) return ;

	switch (cOwnerType) {
	case OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case OWNERTYPE_NPC:	return;
	default: return;
	}


	if (m_pClientList[iAttackerH]->m_side == m_pClientList[iTargetH]->m_side && 
		!m_pMapList[m_pClientList[iAttackerH]->m_cMapIndex]->m_bIsFightZone) return;
	if (m_pClientList[iTargetH]->IsNeutral()) return;

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, true);  
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, true);  
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_BOOTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, true);  
		}
	}


	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, true);  
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;

			SendNotifyMsg(NULL, iTargetH, NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);

			ReleaseItemHandler(iTargetH, iTemp, true);  
		}
	}
}



void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] != NULL) {
		// SendNotifyMsg(NULL, iClientH, NOTIFY_REQGUILDNAMEANSWER, iObjectID, iIndex, m_pClientList[iObjectID]->m_iGuildRank, m_pClientList[iObjectID]->m_cGuildName);
		// SendNotifyMsg(NULL, iClientH, NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, m_pClientList[iObjectID]->m_iGuildRank, m_pClientList[iObjectID]->m_cGuildName);
		SendNotifyMsg(NULL, iClientH, NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);
	}
}
bool CGame::bCheckClientAttackFrequency(int iClientH)
{
	uint32 dwTimeGap;
	uint32 dwTime = timeGetTime();

	if (m_pClientList[iClientH] == NULL) return false;

	if(m_pClientList[iClientH]->IsGM())
		return true;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwTime;
	else {
		dwTimeGap = dwTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwTime;

#ifndef NO_MSGSPEEDCHECK_ATTACK
		if (dwTimeGap < 320) {
			wsprintf(g_cTxt, "(!) Speed hack suspect(%s) - attack(%i)", 
				m_pClientList[iClientH]->m_cCharName, dwTimeGap);
			PutLogList(g_cTxt);
			return false;
		}else if (dwTimeGap < 240) {
			wsprintf(g_cTxt, "(!) Speed hack suspect(%s) - attack(%i). Disconnected", 
				m_pClientList[iClientH]->m_cCharName, dwTimeGap);
			PutLogList(g_cTxt);
			DeleteClient(iClientH, true, true);
			return false;
		}
#endif
	}

	return true;
}


bool CGame::bCheckClientMagicFrequency(int iClientH)
{
	uint32 dwTimeGap;
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	if(!player) return false;
	
	if(player->IsGM())
		return true;

	if (player->m_dwMagicFreqTime == NULL) 
		player->m_dwMagicFreqTime = dwTime;
	else {
		dwTimeGap = dwTime - player->m_dwMagicFreqTime;
		player->m_dwMagicFreqTime = dwTime;

#ifndef NO_MSGSPEEDCHECK_MAGIC
		if (dwTimeGap < 1200) {
			wsprintf(g_cTxt, "(-~-HACKING-~-) Speed hacker detected(%s) - magic(%i). Disconnected", player->m_cCharName, dwTimeGap);
			PutLogList(g_cTxt);
			DeleteClient(iClientH, true, true);
			return false;
		}else if(dwTimeGap < 1600) {
			wsprintf(g_cTxt, "(-~-HACKING-~-) Speed hack suspect(%s) - magic(%i)", player->m_cCharName, dwTimeGap);
			PutLogList(g_cTxt);
			return false;
		}
#endif
	}

	return true;
}


bool CGame::bCheckClientMoveFrequency(int iClientH, bool running)
{
	uint32 dwTimeGap;
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	if(!player) return false;
	
	if(player->IsGM())
		return true;

	if (player->m_dwMoveFreqTime == NULL) 
		player->m_dwMoveFreqTime = dwTime;
	else {
		if (player->m_resetMoveFreq == true) {
			player->m_dwMoveFreqTime = NULL;
			player->m_resetMoveFreq = false;
			return true;
		}

		if (player->m_bIsAttackModeChange == true) {
			player->m_dwMoveFreqTime = NULL;
			player->m_bIsAttackModeChange = false;
			return true;
		}

		dwTimeGap = dwTime - player->m_dwMoveFreqTime;
		player->m_dwMoveFreqTime = dwTime;

		if(running)
		{
			if(dwTimeGap < 30) dwTimeGap = 300;
			player->m_runTime[ player->m_runTurn ] = dwTimeGap;

			uint32 sum = 0;
			for(int i = 0; i < SPEEDCHECKTURNS; i++)
				sum += player->m_runTime[i];

			if(sum < 210*SPEEDCHECKTURNS)
			{
				wsprintf(g_cTxt, "(-~-HACKING-~-) Speed hacker detected(%s) - run-avg(%i). BI banned", player->m_cCharName, sum/SPEEDCHECKTURNS);
				PutLogList(g_cTxt);
				
				DeleteClient(iClientH, true, true, true, true);
				return false;
			}else if(sum < 230*SPEEDCHECKTURNS)
			{
				wsprintf(g_cTxt, "(-~-HACKING-~-) Speed hack suspect(%s) - run-avg(%i)", player->m_cCharName, sum/SPEEDCHECKTURNS);
				PutLogList(g_cTxt);

				++player->m_runTurn %= SPEEDCHECKTURNS;
				return false;
			}
			++player->m_runTurn %= SPEEDCHECKTURNS;
		}else{
			if(dwTimeGap < 30) dwTimeGap = 540;
			player->m_moveTime[ player->m_moveTurn ] = dwTimeGap;

			uint32 sum = 0;
			for(int i = 0; i < SPEEDCHECKTURNS; i++)
				sum += player->m_moveTime[i];

			/*if(sum < 330*SPEEDCHECKTURNS)
			{
				wsprintf(g_cTxt, "(-~-HACKING-~-) Speed hacker detected(%s) - move-avg(%i). BI banned", player->m_cCharName, sum/SPEEDCHECKTURNS);
				PutLogList(g_cTxt);

				DeleteClient(iClientH, true, true, true, true);
				return false;
			}else */if(sum < 350*SPEEDCHECKTURNS)
			{
				wsprintf(g_cTxt, "(-~-HACKING-~-) Speed hack suspect(%s) - move-avg(%i)", player->m_cCharName, sum/SPEEDCHECKTURNS);
				PutLogList(g_cTxt);

				++player->m_moveTurn %= SPEEDCHECKTURNS;
				return false;
			}
			++player->m_moveTurn %= SPEEDCHECKTURNS;
		}
	}

	return true;
}
void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0 ;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return ;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {

		if (m_sForceRecallTime > 0 ) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sForceRecallTime ;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1*20; break;  
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1*20; break;  
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1*20; break;  
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1*20; break;  
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 60*20; break; 
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 60*20; break; 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 60*20; break; 
			}
		}
	}
	else {
		if (m_sForceRecallTime > 0 ) {
			iTL_ =  20*m_sForceRecallTime ;
		}
		else {

			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 1*20; break;  
			case 2:	iTL_ = 1*20; break;  
			case 3:	iTL_ = 1*20; break;  
			case 4:	iTL_ = 1*20; break;  
			case 5:	iTL_ = 60*20; break; 
			case 6:	iTL_ = 60*20; break; 
			case 0:	iTL_ = 60*20; break; 
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = iTL_;
		m_pClientList[iClientH]->m_bIsWarLocation = true;
	}
	return ;
}

int CGame::iSetSide(int iClientH)
{
	if ( m_pClientList[iClientH] == NULL ) return -1;

	char	cLocationName[12], cMapLocationName[12];

	ZeroMemory(cLocationName, sizeof(cLocationName));
	ZeroMemory(cMapLocationName, sizeof(cMapLocationName));

	strcpy(cLocationName, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapLocationName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);

	m_pClientList[iClientH]->m_side = NEUTRAL ; 
	m_pClientList[iClientH]->m_iIsOnTown = PK;

	if (memcmp(cLocationName,cMapLocationName,3) == 0)
		m_pClientList[iClientH]->m_iIsOnTown = NONPK;

	if (memcmp(cLocationName, "are", 3) == 0) {
		m_pClientList[iClientH]->m_side = ARESDEN;
	} else if (memcmp(cLocationName, "elv", 3) == 0) {
		m_pClientList[iClientH]->m_side = ELVINE;
	} else if (memcmp(cLocationName, "ist", 3) == 0) {
		m_pClientList[iClientH]->m_side = ISTRIA;
	}
	else {
		if (strcmp(cMapLocationName, sideMap[ELVINE]) == 0 ||
			strcmp(cMapLocationName, sideMap[ARESDEN]) == 0 ||
			strcmp(cMapLocationName, sideMap[ISTRIA]) == 0)
		{
			m_pClientList[iClientH]->m_iIsOnTown = NONPK;
		}
		m_pClientList[iClientH]->m_bIsNeutral = false ;
	}

	m_pClientList[iClientH]->SetSideFlag((Side) m_pClientList[iClientH]->m_side);

	if (memcmp(m_pClientList[iClientH]->m_cMapName, sideMap[NEUTRAL], 7) == 0) { // Jehovah - Added so trav's cannot fight in trav zone.
		m_pClientList[iClientH]->m_bIsNeutral = true;
	}

	if((memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith",6) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall",7) == 0) ||
		(memcmp(m_pClientList[iClientH]->m_cMapName, "gshop",5) == 0) )
		m_pClientList[iClientH]->m_bIsOnShop = true;
	else
		m_pClientList[iClientH]->m_bIsOnShop = false;


	if(memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus",5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName + 3, "wrhus",5) == 0)
		m_pClientList[iClientH]->m_bIsOnWarehouse = true;
	else
		m_pClientList[iClientH]->m_bIsOnWarehouse = false;


	if(memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr",6) == 0 )
		m_pClientList[iClientH]->m_bIsOnTower = true;
	else
		m_pClientList[iClientH]->m_bIsOnTower = false;

	return m_pClientList[iClientH]->m_side;
}



bool CGame::__bSetAgricultureItem(int iMapIndex, int dX, int dY, int iType,int iSsn, int iClientH)  
{
	int tX, tY;
	char cNpcName[21], cNpcWaypoint[11];

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= MAXAGRICULTURE) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
		return false;
	}

	if(iSsn > m_pClientList[iClientH]->m_cSkillMastery[SKILL_FARMING]) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);  //??
		return false;
	}

	//		for (ix = dX -1; ix <= dX +3; ix++)
	//		for (iy = dY -1; iy <= dY +3; iy++) {
	CNpc * closecrops = (CNpc*)m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(dX, dY);
	if(closecrops && closecrops->IsNPC() && closecrops->m_cActionLimit == 5)
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
		return false;
	}
	// 		}

	if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX,dY) == false)
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
		return false;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, "Crops");

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	tX = (int)dX;
	tY = (int)dY;

	CNpc * crop = CreateNpc(cNpcName, m_pClientList[iClientH]->m_cMapIndex, 0, 
		MOVETYPE_RANDOM, &tX, &tY, NEUTRAL, cNpcWaypoint, NULL, false , false, true);

	if(!crop)
		return false;

	crop->m_iNpcCrops = iType;

	switch (iType) 
	{
	case 1: 
	case 2: 
	case 3: 
	case 4: 
	case 5: 
	case 6: 
	case 7: 
	case 8: 
	case 9: 
	case 10: 
	case 11: 
	case 12: 
	case 13:
	case 14:
		crop->m_iCropsSkillLV = iSsn;
		break;
	default: 
		crop->m_iCropsSkillLV = 100;
		break;
	}

	crop->m_sAppr2 = iType << 8 | 1;
	//			m_pNpcList[iRet]->m_sAppr2 = (char)1;

	SendEventToNearClient_TypeA(crop->m_handle, OWNERTYPE_NPC, MSGID_MOTION_EVENT_CONFIRM, NULL, NULL, NULL);

	//wsprintf(g_cTxt, "plant(%s) Agriculture begin(%d,%d) sum(%d)!", cNpcName, tX, tY,
	//	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
	//PutLogList(g_cTxt);
	return true;
}

void CGame::AdminOrder_CheckRep(int iClientH, char *pData,uint32 dwMsgSize)
{
	short m_iRating;
	char   * token, cName[11], cTargetName[11], cRepMessage[256], cTemp[256], seps[] = "= \t\n", cBuff[256];
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cRepMessage, sizeof(cRepMessage));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();


	if (token != NULL) {
		if (!m_pClientList[iClientH]->IsGM()) return;
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} 
	else {
		wsprintf(cRepMessage, " You have %d reputation points.", m_pClientList[iClientH]->m_reputation);
		ShowClientMsg(iClientH, cRepMessage);
		return;
	}

	if (cName != NULL) {
		token = cName;

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				wsprintf(cRepMessage, " %s has %d reputation points.", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_reputation);
				ShowClientMsg(iClientH, cRepMessage);
			}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////
//		bool bCropsItemDrop(int iClientH, short iTargetH,bool bMobDropPos)  

//////////////////////////////////////////////////////////////////////////////////////////////
bool CGame::bCropsItemDrop(int iClientH, short iTargetH,bool bMobDropPos)  
{
	class CItem * pItem;
	int	  iItemID = 0 ;
	int	  iSeedID = 0 ;

	iSeedID = m_pNpcList[iTargetH]->m_iNpcCrops;

	switch (iSeedID) 
	{
	case 1: iItemID = 820;	GetExp(iClientH, dice(3, 10));  break;
	case 2: iItemID = 821;	GetExp(iClientH, dice(3, 10));  break;
	case 3: iItemID = 822;	GetExp(iClientH, dice(4, 10));  break;
	case 4: iItemID = 823;	GetExp(iClientH, dice(4, 10));  break;
	case 5: iItemID = 824;	GetExp(iClientH, dice(5, 10)); 	break;
	case 6: iItemID = 825;	GetExp(iClientH, dice(5, 10));  break;
	case 7: iItemID = 826;	GetExp(iClientH, dice(6, 10));  break;
	case 8: iItemID = 827;	GetExp(iClientH, dice(6, 10));  break;
	case 9: iItemID = 828;	GetExp(iClientH, dice(7, 10));  break;
	case 10: iItemID = 829;	GetExp(iClientH, dice(7, 10));  break;
	case 11: iItemID = 830;	GetExp(iClientH, dice(8, 10));  break;
	case 12: iItemID = 831; GetExp(iClientH, dice(8, 10));  break;
	case 13: iItemID = 832;	GetExp(iClientH, dice(9, 10));  break;
	case 14: iItemID = 731;	GetExp(iClientH, dice(10, 10)); break;
	default: return false;
	}

	pItem = new class CItem;
	if (pItem->InitItemAttr(iItemID) == false) {
		delete pItem;
		return false;
	}
	else {
		if( bMobDropPos == false)
		{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
		}
		else
		{
			m_pMapList[ m_pNpcList[iTargetH]->m_cMapIndex ]->bSetItem(m_pNpcList[iTargetH]->m_sX, 
				m_pNpcList[iTargetH]->m_sY, 
				pItem);


			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pNpcList[iTargetH]->m_cMapIndex,
				m_pNpcList[iTargetH]->m_sX, m_pNpcList[iTargetH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
		}
	}

	return true;
}

//=============================================================================
bool CGame::IsDatePast(char *Date)
{
	char *token;
	SYSTEMTIME SysTime;

	char seps[] = " :-";
	StrTok pStrTok(new CStrTok(Date, seps));

	GetLocalTime(&SysTime);

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wYear){
		return true;
	}
	else if (atoi(token) > SysTime.wYear){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wMonth){
		return true;
	}
	else if(atoi(token) > SysTime.wMonth){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wDay){
		return true;
	}
	else if(atoi(token) > SysTime.wDay){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wHour){
		return true;
	}
	else if(atoi(token) > SysTime.wHour){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wMinute){
		return true;
	}
	else if(atoi(token) > SysTime.wMinute){
		return false;
	}

	token = pStrTok->pGet();
	if(atoi(token) < SysTime.wSecond){
		return true;
	}
	else if(atoi(token) > SysTime.wSecond){
		return false;
	}

	return true;
}
/*********************************************************************************************************************
**  bool CGame::SetAngel(short sOwnerH, char cOwnerType, int iStatus, iTemp)  Snoopy   ** 
** description   :: Sets the status to send or not Angels to every client       **
*********************************************************************************************************************/
void CGame::SetAngel(short sOwnerH, char cOwnerType, int iStatus, bool notify) 
{
	if (cOwnerType != OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == NULL) return;
	switch (iStatus) {
	case 1: // STR Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELSTR;  
		break;
	case 2: // DEX Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELDEX;
		break;
	case 3: // INT Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELINT;
		break;
	case 4: // MAG Angel
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | STATUS_ANGELMAG;
		break;
	default:
	case 0: // Remove all Angels
		m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFF0FFF;
		break;
	}
	if(notify)
		SendEventToNearClient_TypeA(sOwnerH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
}

/*********************************************************************************************************************
**  bool CGame::GetAngelHandler(int iClientH, char * pData, uint32 dwMsgSize)          ** 
** description   :: Reversed and coded by Snoopy                 **
*********************************************************************************************************************/
/*
void CGame::GetAngelHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
char  *cp, cData[256], cTmpName[21];
int   iAngel, iItemNbe;
class CItem * pItem;
int   iRet, iEraseReq;
short * sp;
uint16  * wp;
int   * ip;
uint32 * dwp;

if (m_pClientList[iClientH] == NULL)      return;
if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

if (_iGetItemSpaceLeft(iClientH) == 0) 
{ SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
return;
}

if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5 )
return;

m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;
SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

cp = (char *)(pData + INDEX2_MSGTYPE + 2);
ZeroMemory(cTmpName, sizeof(cTmpName));
strcpy(cTmpName, cp);
cp += 20;
ip = (int *)cp;
iAngel = (int) *ip; // 0x00 l a i
cp += 2;
wsprintf(g_cTxt, "PC(%s) obtained an Angel (%d).   %s(%d %d)"
, m_pClientList[iClientH]->m_cCharName
, iAngel
, m_pClientList[iClientH]->m_cMapName
, m_pClientList[iClientH]->m_sX
, m_pClientList[iClientH]->m_sY); 
PutLogList(g_cTxt); 
switch (iAngel) {
case 1: // STR
iItemNbe = 908;
break;
case 2: // DEX
iItemNbe = 909;
break;
case 3: // INT
iItemNbe = 910;
break;
case 4: // MAG
iItemNbe = 911;
break;
default:
PutLogList("Gail asked to create a wrong item!"); 
break;
}
pItem = NULL;
pItem = new class CItem;
if (pItem == NULL) return;
if ((pItem->InitItemAttr(iItemNbe) == true)) 
{ pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) 
{ ZeroMemory(cData, sizeof(cData));
dwp  = (uint32 *)(cData + INDEX4_MSGID);
*dwp = MSGID_NOTIFY;
wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
*wp  = NOTIFY_ITEMOBTAINED;    
cp = (char *)(cData + INDEX2_MSGTYPE + 2);    
*cp = 1;
cp++;    
memcpy(cp, pItem->m_cName, 20);
cp += 20;    
dwp  = (uint32 *)cp;
*dwp = pItem->m_dwCount;
cp += 4;    
*cp = pItem->m_cItemType;
cp++;    
*cp = pItem->m_cEquipPos;
cp++;    
*cp = (char)0; 
cp++;    
sp  = (short *)cp;
*sp = pItem->m_sLevelLimit;
cp += 2;    
*cp = pItem->m_cGenderLimit;
cp++;    
wp = (uint16 *)cp;
*wp = pItem->m_wCurLifeSpan;
cp += 2;    
wp = (uint16 *)cp;
*wp = pItem->m_wWeight;
cp += 2;    
sp  = (short *)cp;
*sp = pItem->m_sSprite;
cp += 2;    
sp  = (short *)cp;
*sp = pItem->m_sSpriteFrame;
cp += 2;
*cp = pItem->m_cItemColor;
cp++;
*cp = (char)pItem->m_sItemSpecEffectValue2; 
cp++;    
dwp = (uint32 *)cp;
*dwp = pItem->m_dwAttribute;
cp += 4;
if (iEraseReq == 1) delete pItem;    
iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
switch (iRet) {
case XSOCKEVENT_QUENEFULL:
case XSOCKEVENT_SOCKETERROR:
case XSOCKEVENT_CRITICALERROR:
case XSOCKEVENT_SOCKETCLOSED:
DeleteClient(iClientH, true, true);
break;
}
}else 
{ m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
m_pClientList[iClientH]->m_sY, pItem);   
SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
dwp  = (uint32 *)(cData + INDEX4_MSGID);
*dwp = MSGID_NOTIFY;
wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
*wp  = NOTIFY_CANNOTCARRYMOREITEM;    
iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
switch (iRet) {
case XSOCKEVENT_QUENEFULL:
case XSOCKEVENT_SOCKETERROR:
case XSOCKEVENT_CRITICALERROR:
case XSOCKEVENT_SOCKETCLOSED:
DeleteClient(iClientH, true, true);
break;
} }
}else 
{ delete pItem;
pItem = NULL;
} 
} */


void CGame::GetAngelHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char  *cp, cTmpName[21];
	int   iAngel;
	class CItem * pItem;
	int   iEraseReq;
	char  cItemName[21];
	int   * ip;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{
		SendItemNotifyMsg(iClientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return;
	} 

	if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5 )
		return;

	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;
	SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int *)cp;
	iAngel = (int) *ip;
	cp += 2;
	wsprintf(g_cTxt, "PC(%s) obtained an Angel (%d).   %s(%d %d)"
		, m_pClientList[iClientH]->m_cCharName
		, iAngel
		, m_pClientList[iClientH]->m_cMapName
		, m_pClientList[iClientH]->m_sX
		, m_pClientList[iClientH]->m_sY); 
	PutLogList(g_cTxt); 
	switch (iAngel) {
	case 1:
		wsprintf(cItemName, "AngelicPendant(STR)");
		break;
	case 2:
		wsprintf(cItemName, "AngelicPendant(DEX)");
		break;
	case 3:
		wsprintf(cItemName, "AngelicPendant(INT)");
		break;
	case 4:
		wsprintf(cItemName, "AngelicPendant(MAG)");
		break;
	default:
		PutLogList("Gail asked to create a wrong item!");
		break;
	}
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((pItem->InitItemAttr(cItemName) == true)) 
	{
		pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) 
		{
			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
		
			if (iEraseReq == 1) delete pItem;    
			
		}else { 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);   
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		}
	}else { 
		delete pItem;
		pItem = NULL;
	} 
} 

// Jehovah - Coded a DK item handler for cityhall from snoopys function.
void CGame::GetDKItemHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char  *cp, cTmpName[21];
	int   iAngel;
	int   iEraseReq;
	char  cItemName[21];
	int   * ip;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{
		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return;
	}
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	ip = (int *)cp;
	iAngel = (int) *ip;
	cp += 2;
	switch (iAngel) 
	{
		// Weapons
	case 10:
		wsprintf(cItemName, "DMMagicStaff");
		break;
	case 11:
		wsprintf(cItemName, "DKRapier");
		break;
	case 12:
		wsprintf(cItemName, "DKGreatSword");
		break;
	case 13:
		wsprintf(cItemName, "DKFlameberg");
		break;

	default:
		PutLogList("Cityhall officer asked to create a wrong item!");
		break;
	}

	if(m_pClientList[iClientH]->HasItem(cItemName) != ITEM_NONE)
		return;

	CItem * pItem = new class CItem; 

	if (pItem == NULL) return;
	if ((pItem->InitItemAttr(cItemName) == true)) 
	{
		pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) 
		{
			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

			if (iEraseReq == 1) delete pItem;
			
			/*	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= iRequiredMagesty; 
			SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL); */
		}
		else 
		{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		}
	}
	else 
	{
		delete pItem;
		pItem = NULL;
	}
}

void CGame::PlayerOrder_SetAFK(int iClientH)
{
	if (m_pClientList[iClientH]->GetStatusFlag(STATUS_AFK)){
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You are no longer AFK.");
		m_pClientList[iClientH]->SetStatusFlag(STATUS_AFK, false);

	}else
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOTICEMSG, NULL, NULL, NULL, "You are now AFK.");
		m_pClientList[iClientH]->SetStatusFlag(STATUS_AFK, true);
	}
}

void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int i;
	char cItemID[4], ctr[4];
	char *cp, cSlateColour, cData[120];
	bool bIsSlatePresent = false;
	CItem * pItem;
	int iSlateType, iEraseReq;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == true) return;

	for(i = 0; i < 4; i++){
		cItemID[i] = 0;
		ctr[i] = 0;
	}

	cp = (char *)pData;
	cp += 11;

	m_sSlateSuccessRate = 35; //Temporary: to be read from cfg
	// 35% chance of creating slates
	if (dice(1,100) < m_sSlateSuccessRate) bIsSlatePresent = true;

	try{
		// make sure slates really exist
		for(i = 0; i < 4; i++){
			cItemID[i] = *cp;
			cp++;

			if(cItemID[i] < 0 || cItemID[i] > MAXITEMS || !m_pClientList[iClientH]->m_pItemList[cItemID[i]] ||
				m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_disabled)
			{
				bIsSlatePresent = false;
				SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
				return; 
			}

			//No duping
			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_LU) // AncientTablet(LU)
				ctr[0] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_LD) // AncientTablet(LD)
				ctr[1] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_RU) // AncientTablet(RU)
				ctr[2] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == ITEM_ANCIENTTABLET_RD) // AncientTablet(RD)
				ctr[3] = 1;
		}
	}
	catch(...){
		//Crash Hacker Caught
		bIsSlatePresent = false;
		SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
		wsprintf(g_cTxt, "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutLogList(g_cTxt);
		DeleteClient(iClientH, true, true);
		return;
	}

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = false;
		return; 
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = true;

	// if we failed, kill everything
	if (!bIsSlatePresent) {
		for(i = 0; i < 4; i++) {
			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
				ItemDepleteHandler(iClientH,cItemID[i], false, false);
			}
		} 
		SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL); 
		return; 
	}

	// make the slates
	for(i = 0; i < 4; i++){
		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
			ItemDepleteHandler(iClientH,cItemID[i], false, false);
		}
	}

	pItem = new class CItem;

	i = dice(1,1000);

	if (i < 50) { // Health Slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Berserk Slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Experience Slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i <  1001) { // Health Slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(NULL, iClientH, NOTIFY_SLATE_CREATESUCCESS, iSlateType, NULL, NULL, NULL);

	ZeroMemory(cData,sizeof(cData));

	// Create slates
	if (pItem->InitItemAttr(ITEM_ANCIENTTABLET) == false) {
		delete pItem;
		return;
	}
	else{
		pItem->m_sTouchEffectType   = ITET_ID;
		pItem->m_sTouchEffectValue1 = dice(1,100000);
		pItem->m_sTouchEffectValue2 = dice(1,100000);
		pItem->m_sTouchEffectValue3 = (short)timeGetTime();

		_bItemLog(ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if(_bAddClientItemList(iClientH, pItem, &iEraseReq) == true){
			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);

			if (iEraseReq == 1) delete pItem;
		}
		else{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame,
				pItem->m_cItemColor);
			SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		}
	}
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (sType == NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_REDSLATE;
		m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_BLUESLATE;
		m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_GREENSLATE;
		return;
	}

	if (bFlag == true) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_iStatus |= STATUS_REDSLATE;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_iStatus |= STATUS_BLUESLATE;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_iStatus |= STATUS_GREENSLATE;
		}
	}
	else{
		if ((m_pClientList[iClientH]->m_iStatus & STATUS_REDSLATE) != 0) {
			m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_REDSLATE;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & STATUS_BLUESLATE) != 0) {
			m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_BLUESLATE;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & STATUS_GREENSLATE) != 0) {
			m_pClientList[iClientH]->m_iStatus &= STATUS_ALL - STATUS_GREENSLATE;
		}
	}

	SendEventToNearClient_TypeA(iClientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);
}

void CGame::AdminOrder_GoTo(int iClientH, char* pData, uint32 dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	char *cp;
	uint16 *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token == NULL) {
		return;
	}

	if (strlen(token) > 10) {
		memcpy(cPlayerName,token,10);
	}
	else{
		memcpy(cPlayerName,token,strlen(token));
	}

	for(int i = 1; i < MAXCLIENTS; i++){
		if (m_pClientList[i] != NULL) {
			if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName, 10) == 0) {
					if(m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sY == -1){
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)",m_pClientList[iClientH]->m_cCharName,m_pClientList[i]->m_cMapName);
					}
					else{
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName,
							m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					}
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH,false,cBuff);
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					RequestTeleportHandler(iClientH, 2 , cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);

				return;
			}
		}
	}

	ZeroMemory(cBuff,sizeof(cBuff));

	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (uint16 *)cp;
	*wp = GSID;
	cp += 2;

	wp = (uint16 *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp,cPlayerName,10);
	cp += 10;

	memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
	cp += 10;

	bStockMsgToGateServer(cBuff,25);

}

void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, uint32 dwMsgSize)
{
	//Push Player- By:ACiDx  Monday , September 2004
	//Teleports a Defined Player to Defined Destination
	// /push playername mapname sX dX
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
	int dX, dY;
	int i;
	bool   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	StrTok pStrTok(new CStrTok(cBuff, seps));
	token = pStrTok->pGet();
	token = pStrTok->pGet();


	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else return;

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				bFlag = false;
				//Asks For Flag on maps
				if (strcmp("2ndmiddle", cMapName) == 0) bFlag = true;
				if (strcmp("abaddon", cMapName) == 0) bFlag = true; 
				if (strcmp("arebrk11", cMapName) == 0) bFlag = true;
				if (strcmp("arebrk12", cMapName) == 0) bFlag = true;
				if (strcmp("arebrk21", cMapName) == 0) bFlag = true;
				if (strcmp("arebrk22", cMapName) == 0) bFlag = true;
				if (strcmp("arefarm", cMapName) == 0) bFlag = true;
				if (strcmp("arejail", cMapName) == 0) bFlag = true;
				if (strcmp("aremidl", cMapName) == 0) bFlag = true;
				if (strcmp("aremidr", cMapName) == 0) bFlag = true;
				if (strcmp(sideMap[ARESDEN], cMapName) == 0) bFlag = true;
				if (strcmp("aresdend1", cMapName) == 0) bFlag = true;
				if (strcmp("areuni", cMapName) == 0) bFlag = true;
				if (strcmp("arewrhus", cMapName) == 0) bFlag = true;
				if (strcmp("bisle", cMapName) == 0)   bFlag = true;
				if (strcmp("bsmith_1", cMapName) == 0) bFlag = true;
				if (strcmp("bsmith_1f", cMapName) == 0) bFlag = true;
				if (strcmp("bsmith_2", cMapName) == 0) bFlag = true;
				if (strcmp("bsmith_2f", cMapName) == 0) bFlag = true;
				if (strcmp("BtField", cMapName) == 0) bFlag = true;
				if (strcmp("cath_1", cMapName) == 0) bFlag = true;
				if (strcmp("cath_2", cMapName) == 0)      bFlag = true;
				if (strcmp("cityhall_1", cMapName) == 0) bFlag = true;
				if (strcmp("cityhall_2", cMapName) == 0) bFlag = true;
				if (strcmp("CmdHall_1", cMapName) == 0) bFlag = true;
				if (strcmp("CmdHall_2", cMapName) == 0) bFlag = true;
				if (strcmp(sideMap[NEUTRAL], cMapName) == 0) bFlag = true;
				if (strcmp("dglv2", cMapName) == 0) bFlag = true;
				if (strcmp("dglv3", cMapName) == 0) bFlag = true;
				if (strcmp("dglv4", cMapName) == 0) bFlag = true;
				if (strcmp("druncncity", cMapName) == 0) bFlag = true; 
				if (strcmp("elvbrk11", cMapName) == 0) bFlag = true;
				if (strcmp("elvbrk12", cMapName) == 0) bFlag = true;
				if (strcmp("elvbrk21", cMapName) == 0) bFlag = true;
				if (strcmp("elvbrk22", cMapName) == 0) bFlag = true;
				if (strcmp("elvfarm", cMapName) == 0) bFlag = true;
				if (strcmp(sideMap[ELVINE], cMapName) == 0)  bFlag = true;
				if (strcmp("elvined1", cMapName) == 0)    bFlag = true;
				if (strcmp("elvjail", cMapName) == 0)    bFlag = true;
				if (strcmp("elvmidl", cMapName) == 0) bFlag = true;
				if (strcmp("elvmidr", cMapName) == 0) bFlag = true;
				if (strcmp("elvuni", cMapName) == 0) bFlag = true;
				if (strcmp("elvwrhus", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone1", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone2", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone3", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone4", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone5", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone6", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone7", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone8", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone9", cMapName) == 0) bFlag = true;
				if (strcmp("fightzone10", cMapName) == 0) bFlag = true;
				if (strcmp("gldhall_1", cMapName) == 0) bFlag = true;
				if (strcmp("gldhall_2", cMapName) == 0)   bFlag = true;
				if (strcmp("GodH", cMapName) == 0)   bFlag = true;
				if (strcmp("gshop_1", cMapName) == 0) bFlag = true;
				if (strcmp("gshop_1f", cMapName) == 0) bFlag = true;
				if (strcmp("gshop_2", cMapName) == 0)     bFlag = true;
				if (strcmp("gshop_2f", cMapName) == 0)     bFlag = true;
				if (strcmp("HRampart", cMapName) == 0)     bFlag = true;
				if (strcmp("huntzone1", cMapName) == 0) bFlag = true;
				if (strcmp("huntzone2", cMapName) == 0) bFlag = true;
				if (strcmp("huntzone3", cMapName) == 0) bFlag = true;
				if (strcmp("huntzone4", cMapName) == 0) bFlag = true;
				if (strcmp("icebound", cMapName) == 0) bFlag = true; 
				if (strcmp("inferniaA", cMapName) == 0) bFlag = true; 
				if (strcmp("inferniaB", cMapName) == 0) bFlag = true; 
				if (strcmp("maze", cMapName) == 0) bFlag = true; 
				if (strcmp("middled1n", cMapName) == 0) bFlag = true;
				if (strcmp("middled1x", cMapName) == 0) bFlag = true;
				if (strcmp("middleland", cMapName) == 0) bFlag = true;
				if (strcmp("penalty", cMapName) == 0) bFlag = true;
				if (strcmp("procella", cMapName) == 0) bFlag = true;
				if (strcmp("resurr1", cMapName) == 0) bFlag = true;
				if (strcmp("resurr2", cMapName) == 0) bFlag = true;
				if (strcmp("toh1", cMapName) == 0) bFlag = true;
				if (strcmp("toh2", cMapName) == 0) bFlag = true;
				if (strcmp("toh3", cMapName) == 0) bFlag = true;
				if (strcmp("wrhus_1", cMapName) == 0) bFlag = true;
				if (strcmp("wrhus_1f", cMapName) == 0) bFlag = true;
				if (strcmp("wrhus_2", cMapName) == 0)     bFlag = true;
				if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = true;
				if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = true;
				if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = true;
				if (strcmp("barracks1", cMapName) == 0) bFlag = true;
				if (strcmp("barracks2", cMapName) == 0) bFlag = true;
				if (strcmp("bsmith", cMapName) == 0) bFlag = true;

				//Defines I as Max clients
				if (bFlag == true)
					//Reqeust the Push/Teleport
					RequestTeleportHandler(i, 2, cMapName, dX, dY);
				wsprintf(g_cTxt,"(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)",m_pClientList[iClientH]->m_cIPaddress, 
					m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, false, g_cTxt);
				return;
			}
	}
}

void CGame::StateChangeHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char * cp;
	uint8 cStr, cVit, cDex, cInt, cMag, cChar;
	int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
	int totalChanged;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	cStr = cVit = cDex = cInt = cMag = cChar = 0;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	Pop(cp, cStr);
	Pop(cp, cVit);
	Pop(cp, cDex);
	Pop(cp, cInt);
	Pop(cp, cMag);
	Pop(cp, cChar);

	iOldStr	= m_pClientList[iClientH]->GetBaseStr();
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->GetBaseDex();
	iOldInt = m_pClientList[iClientH]->GetBaseInt();
	iOldMag = m_pClientList[iClientH]->GetBaseMag();
	iOldChar = m_pClientList[iClientH]->m_iCharisma;
	
	if(iOldStr +iOldVit	+iOldDex +iOldInt +iOldMag +iOldChar != (179*3 + 70))
		return;

	if(cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0)
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}
	
	totalChanged = cStr + cVit + cDex + cInt + cMag + cChar;
	if ((totalChanged + 2) / 3 > m_pClientList[iClientH]->m_iGizonItemUpgradeLeft)
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}

	if(m_pClientList[iClientH]->m_iGuildRank == GUILDRANK_MASTER )
	{
		if(m_pClientList[iClientH]->m_iCharisma - cChar < 20)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
	}

	if ((m_pClientList[iClientH]->GetBaseStr() - cStr > CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->GetBaseStr() - cStr < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseDex() - cDex > CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->GetBaseDex() - cDex < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseInt() - cInt > CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->GetBaseInt() - cInt < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10))
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}

	if ((m_pClientList[iClientH]->GetBaseMag() - cMag > CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->GetBaseMag() - cMag < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}

	if ((m_pClientList[iClientH]->m_iCharisma - cChar > CHARPOINTLIMIT)
		 || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, NOTIFY_STATECHANGE_FAILED);
		return;
	}

	if (m_pClientList[iClientH]->m_iLU_Pool < totalChanged) m_pClientList[iClientH]->m_iLU_Pool = totalChanged;

	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= (totalChanged + 2) / 3;

	m_pClientList[iClientH]->SetStr( m_pClientList[iClientH]->GetBaseStr() - cStr);
	m_pClientList[iClientH]->m_iVit  -= cVit;
	if(m_pClientList[iClientH]->m_iHP > m_pClientList[iClientH]->GetMaxHP())
		m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP();
		
	m_pClientList[iClientH]->SetDex( m_pClientList[iClientH]->GetBaseDex() - cDex);
	m_pClientList[iClientH]->SetInt( m_pClientList[iClientH]->GetBaseInt() - cInt);
	if(cInt > 0){
		if(CheckMagicInt(iClientH))
			SendNotifyMsg(NULL, iClientH, NOTIFY_SPELL_SKILL);
	}
	m_pClientList[iClientH]->SetMag( m_pClientList[iClientH]->GetBaseMag() - cMag);
	m_pClientList[iClientH]->m_iCharisma -= cChar;

	m_pClientList[iClientH]->ValidateSkills(false);

	SendNotifyMsg(NULL, iClientH, NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	SendNotifyMsg(NULL, iClientH, NOTIFY_SETTING_SUCCESS);
}

bool CGame::CheckMagicInt(int iClientH)
{
	bool changed = false;

	if(m_pClientList[iClientH]->IsGM()) return false;
	for(int i = 0;i < MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if(m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->GetInt())
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
			changed = true;
		}
	}

	return changed;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{
	short sX, sY;
	char buff[100];

	if (m_pClientList[iClientH] == NULL) return;

	if (bResurrect == false) {
		m_pClientList[iClientH]->m_bIsBeingResurrected = false;
		return;
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	if (m_pClientList[iClientH]->m_bIsBeingResurrected == false) {
		wsprintf(buff, "(!!!) %s(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(buff);
		PutLogFileList(buff, HACK_LOGFILE);
		DeleteClient(iClientH, true, true, true, true);
		return;
	}

	m_pClientList[iClientH]->m_bIsKilled = false;
	m_pClientList[iClientH]->m_iHP = m_pClientList[iClientH]->GetMaxHP() / 2; 
	//m_pClientList[iClientH]->m_iMP = ((m_pClientList[iClientH]->m_iMag*2)+(m_pClientList[iClientH]->m_iLevel/2))+m_pClientList[iClientH]->m_iInt/2;
	//m_pClientList[iClientH]->m_iSP = (m_pClientList[iClientH]->m_iStr*2)+(m_pClientList[iClientH]->m_iLevel/2);
	//m_pClientList[iClientH]->m_iHungerStatus = 100;

	m_pClientList[iClientH]->m_bIsBeingResurrected = false;

	RequestTeleportHandler(iClientH, 2, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}

void CGame::RequestGuildBoard(CClient * player, char * data)
{
	if(player->IsFlooding(3) || player->m_iGuildGUID == -1)
		return;

	uint32 lastid;
	Pop(data, lastid);

	bSendMsgToLS(MSGID_REQ_GUILDBOARD, player->m_handle, NULL, NULL, lastid);
}

void CGame::ResponseGuildBoard(char * data, uint32 size)
{
	CClient * player = m_pClientList[ *(uint16*)(data + INDEX2_MSGTYPE + 2) ];

	if(!player)
		return;

	switch (player->m_pXSock->iSendMsg(data, size))
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(player->m_handle, true, true);
	}
}

void CGame::RequestGuildBoardPost(CClient * player, char * data)
{
	if(player->IsFlooding(5) || !player->m_guild)
		return;

	uint32 mailID;
	Pop(data, mailID);

	bSendMsgToLS(MSGID_REQ_GUILDPOSTDATA, player->m_handle, NULL, NULL, mailID);
}

void CGame::ResponseGuildBoardPost(char * data, uint32 size)
{
	CClient * player = m_pClientList[ *(uint16*)(data + INDEX2_MSGTYPE + 2) ];

	if(!player)
		return;

	switch (player->m_pXSock->iSendMsg(data, size))
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(player->m_handle, true, true);
	}
}

void CGame::RequestDeleteGuildBoardPost(CClient * player, char * data)
{
	if(player->IsFlooding(5) || !player->m_guild || 
		(player->m_iGuildRank != GUILDRANK_MASTER && player->m_iGuildRank != GUILDRANK_CAPTAIN))
	{
		return;
	}

	uint32 mailID;
	Pop(data, mailID);

	bSendMsgToLS(MSGID_REQ_DELETEGUILDPOST, player->m_handle, NULL, NULL, mailID);
}

void CGame::RequestPostGuildBoard(CClient * player, char * data, uint32 size)
{
	if(player->IsFlooding(3)  || !player->m_guild || 
		(player->m_iGuildRank != GUILDRANK_MASTER && player->m_iGuildRank != GUILDRANK_CAPTAIN))
	{
		return;
	}

	bSendMsgToLS(MSGID_REQ_POSTGUILDBOARD, player->m_handle, NULL, data, size);
}

void CGame::ResponsePostGuildBoard(char * data, uint32 size)
{
	char * p = data;
	p += 4;
	bool confirm = *(uint16*)p == MSGTYPE_CONFIRM ? true : false;
	p += 2;
	
	uint16 clientH;
	Pop(p, clientH);
	
	CClient * player = m_pClientList[ clientH ];
	
	if(!player)
	{
		ERR("Player disconnected after sending mail!");
		return;
	}

	if(confirm)
	{
		uint16 guildID;
		Pop(p, guildID);

		CGuild * guild = guildMgr.FindGuild(guildID);

		if(!guild)
			return;

		guild->Notify(NOTIFY_GUILDBOARDPOST, 0, 0, 0, player->m_cCharName);
	} else {
		switch (player->m_pXSock->iSendMsg(data, 6))
		{
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(player->m_handle, true, true);
		}
	}
	
	uint32 playerGold = player->GetItemCount(ITEM_GOLD);
	uint32 totalCost = GUILDBOARD_POST_COST;

	if(playerGold < totalCost)
	{
		ERR("Player has less gold after posting on guild board!");
		player->SetItemCount(ITEM_GOLD, 0);
	} else {
		player->SetItemCount(ITEM_GOLD, playerGold - totalCost);
	}
}

void CGame::RequestMailbox(CClient * player, char * data)
{
	if(player->IsFlooding(3) || memcmp(player->m_cMapName, "cityhall", 8) != 0)
		return;

	uint32 lastid;
	Pop(data, lastid);

	bSendMsgToLS(MSGID_REQ_MAILBOX, player->m_handle, NULL, NULL, player->m_charID, lastid);
}

void CGame::RequestDeleteMail(CClient * player, char * data)
{
	if(player->IsFlooding(5) || memcmp(player->m_cMapName, "cityhall", 8) != 0)
		return;

	uint32 mailID;
	Pop(data, mailID);

	bSendMsgToLS(MSGID_REQ_DELETEMAIL, NULL, NULL, NULL, player->m_charID, mailID);
}

void CGame::ResponseMailbox(char * data, uint32 size)
{
	CClient * player = m_pClientList[ *(uint16*)(data + INDEX2_MSGTYPE + 2) ];

	if(!player)
		return;

	switch (player->m_pXSock->iSendMsg(data, size))
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(player->m_handle, true, true);
	}
}

void CGame::RequestRetrieveMailItem(CClient * player, char * data)
{
	if(player->IsFlooding(5) || memcmp(player->m_cMapName, "cityhall", 8) != 0)
		return;

	char * p = data + 6 + 4 + sizeof(ItemUID);
	Push(p, (uint16)player->m_handle);
	Push(p, player->m_charID);

	bSendMsgToLS(MSGID_REQ_RETRIEVEMAILITEM, player->m_handle, NULL, data);
}

void CGame::ResponseRetrieveMailItem(char * data)
{
	uint16 clientH;
	Pop(data, clientH);
	CClient * player = m_pClientList[ clientH ];

	uint32 charid;
	Pop(data, charid);

	if(!player || player->m_charID != charid)
		return;


	CItem * item = new CItem();
	string itemname;
	Pop(data, itemname);
	item->InitItemAttr(itemname.c_str());

	Pop(data, item->m_dwCount);
	Pop(data, (uint16&)item->m_sTouchEffectType);
	Pop(data, (uint16&)item->m_sTouchEffectValue1);
	Pop(data, (uint16&)item->m_sTouchEffectValue2);
	Pop(data, (uint16&)item->m_sTouchEffectValue3);
	Pop(data, (uint8&)item->m_cItemColor);
	Pop(data, (uint16&)item->m_sItemSpecEffectValue1);
	Pop(data, (uint16&)item->m_sItemSpecEffectValue2);
	Pop(data, (uint16&)item->m_sItemSpecEffectValue3);
	Pop(data, (uint32&)item->m_wCurLifeSpan);
	Pop(data, item->m_dwAttribute);
	for(int j = 0; j < MAXITEMSOCKETS; j++)
		Pop(data, item->m_sockets[j]);
	Pop(data, item->ItemUniqueID);

	if(item->IsManued() && (item->m_sIDnum > ITEM_MAGICSAPPHIRE || item->m_sIDnum < ITEM_MAGINDIAMOND)) //Quick hack. TODO: Fix Endu for Magic jewels
		item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;

	int iValue = (item->m_dwAttribute & 0xF0000000) >> 28;
	if(iValue > 0)
	{
		switch (item->m_cCategory) {
		case 5:
		case 6:
			item->m_wMaxLifeSpan = item->m_sItemSpecEffectValue1;
			break;
		}
	}
	item->AdjustByStat();
	if(item->m_wCurLifeSpan > item->m_wMaxLifeSpan)
		item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
	
	_bItemLog(ITEMLOG_MAILRETRIEVE, player->m_handle, (int) -1, item);

	int erase;
	if(_bAddClientItemList(clientH, item, &erase)) 
	{
		SendItemNotifyMsg(clientH, NOTIFY_ITEMOBTAINED, item, NULL, true);
		if (erase == 1) delete item;
	}
	else 
	{
		SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX,	player->m_sY, item);
		
		_bItemLog(ITEMLOG_DROP, player->m_handle, (int) -1, item, true);

		AddGroundItem(item, player->m_sX, player->m_sY, player->m_cMapIndex, TILECLEANTIMEPLAYER);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex,
			player->m_sX, player->m_sY, item->m_sSprite, item->m_sSpriteFrame, item->m_cItemColor); 
	}

	char * p = G_cData50000;

	Push(p, (uint32)MSGID_RSP_RETRIEVEMAILITEM);
	Push(p, (uint16)MSGTYPE_CONFIRM);

	switch (player->m_pXSock->iSendMsg(G_cData50000, p - G_cData50000))
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(player->m_handle, true, true);
	}
}

void CGame::RequestMailData(CClient * player, char * data)
{
	if(player->IsFlooding(5) || memcmp(player->m_cMapName, "cityhall", 8) != 0)
		return;

	uint32 mailID;
	Pop(data, mailID);

	bSendMsgToLS(MSGID_REQ_MAILDATA, player->m_handle, NULL, NULL, player->m_charID, mailID);
}

void CGame::ResponseMailData(char * data)
{
	char * p = data + INDEX2_MSGTYPE + 2;

	uint16 clientH;
	Pop(p, clientH);
	CClient * player = m_pClientList[ clientH ];

	uint32 charid;
	Pop(p, charid);

	if(!player || player->m_charID != charid)
		return;

	uint32 mailid;
	Pop(p, mailid);

	string msg;
	Pop(p, msg);

	uint8 nitems;
	Pop(p, nitems);

	char * writep = p;

	CItem items[MAX_MAIL_ITEMS];

	// get the items
	for(int i = 0; i < nitems; i++)
	{
		string itemname;
		Pop(p, itemname);
		items[i].InitItemAttr(itemname.c_str());

		Pop(p, items[i].m_dwCount);
		Pop(p, (uint16&)items[i].m_sTouchEffectType);
		Pop(p, (uint32&)items[i].m_wCurLifeSpan);
		Pop(p, (uint8&)items[i].m_cItemColor);
		Pop(p, (uint16&)items[i].m_sItemSpecEffectValue2);
		Pop(p, items[i].m_dwAttribute);
		Pop(p, items[i].ItemUniqueID);
		for(int j = 0; j < MAXITEMSOCKETS; j++)
			Pop(p, items[i].m_sockets[j]);

		if(items[i].IsManued() && (items[i].m_sIDnum > ITEM_MAGICSAPPHIRE || items[i].m_sIDnum < ITEM_MAGINDIAMOND)) //Quick hack. TODO: Fix Endu for Magic jewels
			items[i].m_wMaxLifeSpan = items[i].m_sItemSpecEffectValue1;

		int iValue = (items[i].m_dwAttribute & 0xF0000000) >> 28;
		if(iValue > 0)
		{
			switch (items[i].m_cCategory) {
			case 5:
			case 6:
				items[i].m_wMaxLifeSpan = items[i].m_sItemSpecEffectValue1;
				break;
			}
		}
		items[i].AdjustByStat();
		if(items[i].m_wCurLifeSpan > items[i].m_wMaxLifeSpan)
			items[i].m_wCurLifeSpan = items[i].m_wMaxLifeSpan;
	}

	// write the items for client
	p = writep;
	for(int i = 0; i < nitems; i++)
	{
		Push(p, items[i].m_cName);
		Push(p, items[i].m_dwCount);
		Push(p, (uint8)items[i].m_cItemType);
		Push(p, (uint8)items[i].m_cEquipPos);
		Push(p, (uint16)items[i].m_sLevelLimit);
		Push(p, (uint8)items[i].m_cGenderLimit);
		Push(p, (uint16)items[i].m_wCurLifeSpan);
		Push(p, items[i].m_wWeight);
		Push(p, (uint16)items[i].m_sSprite);
		Push(p, (uint16)items[i].m_sSpriteFrame);
		Push(p, (uint8)items[i].m_cItemColor);
		Push(p, (uint16)items[i].m_sItemSpecEffectValue2);
		Push(p, items[i].m_dwAttribute);
		for(int j = 0; j < MAXITEMSOCKETS; j++)
			Push(p, items[i].m_sockets[j]);
		Push(p, items[i].ItemUniqueID);
	}

	switch (player->m_pXSock->iSendMsg(data, p - data))
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(player->m_handle, true, true);
	}
}

void CGame::RequestSendMail(CClient * player, char * data, uint32 size)
{
	if(player->IsFlooding(3)  || memcmp(player->m_cMapName, "cityhall", 8) != 0)
		return;

	string dump;

	char * cp = data + 6;
	Pop(cp, dump); // to
	Pop(cp, dump); // title
	Pop(cp, dump); // msg

	uint8 nitems;
	Pop(cp, nitems);

	uint32 sendCost = SEND_MAIL_COST + SEND_MAIL_ITEM_COST * nitems;

	if(player->GetItemCount(ITEM_GOLD) < sendCost)
		return;
	
	char * writep = data + size;
	CItem * item;
	for(int i = 0; i < nitems; i++)
	{
		uint8 index;
		uint32 count;

		Pop(cp, index);
		Pop(cp, count);

		item = player->m_pItemList[index];
		if(!item || count > item->m_dwCount || item->m_disabled)
			return;

		if(item->m_sIDnum == ITEM_GOLD && item->m_dwCount < count + sendCost)
			return;

		item->m_disabled = true;

		Push(writep, item->m_cName);
		Push(writep, (uint16)item->m_sTouchEffectType);
		Push(writep, (uint16)item->m_sTouchEffectValue1);
		Push(writep, (uint16)item->m_sTouchEffectValue2);
		Push(writep, (uint16)item->m_sTouchEffectValue3);
		Push(writep, (uint8)item->m_cItemColor);
		Push(writep, (uint16)item->m_sItemSpecEffectValue1);
		Push(writep, (uint16)item->m_sItemSpecEffectValue2);
		Push(writep, (uint16)item->m_sItemSpecEffectValue3);
		Push(writep, (uint16)item->m_wCurLifeSpan);
		Push(writep, item->m_dwAttribute);
		for(int j = 0; j < MAXITEMSOCKETS; j++)
			Push(writep, item->m_sockets[j]);
	}
		

	bSendMsgToLS(MSGID_REQ_SENDMAIL, player->m_handle, NULL, data, writep - data);
}

void CGame::ResponseSendMail(char * data)
{
	char * p = data;
	p += 4;
	bool confirm = *(uint16*)p == MSGTYPE_CONFIRM ? true : false;
	p += 2;
	
	uint16 clientH;
	Pop(p, clientH);
	
	CClient * player = m_pClientList[ clientH ];
	
	if(!player)
	{
		ERR("MAIL: Player disconnected after sending mail!");
		return;
	}
	
	if(confirm)
	{
		uint16 charid;
		Pop(p, charid);

		for(int i = 1; i < MAXCLIENTS; i++) 
		{
			if(m_pClientList[i] && m_pClientList[i]->m_charID == charid)
			{
				m_pClientList[i]->Notify(NULL, NOTIFY_MAILRECEIVED, 0, 0, 0, player->m_cCharName);
				break;
			}
		}

		uint8 nitems;
		Pop(p, nitems);

		for(int i = 0; i < nitems; i++)
		{
			uint8 ind;
			Pop(p, ind);

			uint32 cnt;
			Pop(p, cnt);

			CItem * item = player->m_pItemList[ind];

			if(!item)
			{
				ERR("MAIL: Sent item no longer exists!");
				continue;
			}

			if(cnt > item->m_dwCount)
			{
				ERR("MAIL: Item does not have enough count after sending!");
				cnt = item->m_dwCount;
			}
			
			_bItemLog(ITEMLOG_MAILSEND, player->m_handle, charid, item, true);

			item->m_dwCount -= cnt;
			
			if(item->m_dwCount == 0)
				ItemDepleteHandler(player->m_handle, ind, false, false, false);
			else {
				item->m_disabled = false;
			}
		}

		uint32 playerGold = player->GetItemCount(ITEM_GOLD);
		uint32 totalCost = SEND_MAIL_COST + nitems * SEND_MAIL_ITEM_COST;

		// SetItemCount here updates the player's weight (unless the player has no gold item at all?)
		if(playerGold < totalCost)
		{
			ERR("MAIL: Player has less gold after sending mail!");
			player->SetItemCount(ITEM_GOLD, 0);
		} else {
			player->SetItemCount(ITEM_GOLD, playerGold - totalCost);
		}
	}

	switch (player->m_pXSock->iSendMsg(data, 6))
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(player->m_handle, true, true);
	}
}

void CGame::RequestGuildBank(CClient * player, char * data)
{
	uint32 whVersion;
	Pop(data, whVersion);

	char * index = m_pMsgBuffer;
	Push(index, (uint32)MSGID_RESPONSE_GUILDBANK);

	if(player->m_iGuildGUID == GUILDGUID_NONE || player->IsFlooding(3))
	{
		Push(index, (uint16)MSGTYPE_REJECT);

		switch (player->m_pXSock->iSendMsg(m_pMsgBuffer, index-m_pMsgBuffer))
		{
		case XSOCKEVENT_QUENEFULL:
		case XSOCKEVENT_SOCKETERROR:
		case XSOCKEVENT_CRITICALERROR:
		case XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(player->m_handle, true, true);
		}
		return;
	}

	CGuild * guild = player->m_guild;

	if(!guild) return;

	if(whVersion == guild->warehouseVer)
		return;

	Push(index, (uint16)MSGTYPE_CONFIRM);

	guild->WriteWarehouse(index);

	switch (player->m_pXSock->iSendMsg(m_pMsgBuffer, index - m_pMsgBuffer))
	{
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(player->m_handle, true, true);
	}
}

void CGame::RequestGuildSummon(CClient * player, char * data)
{
	if(!player->m_guild)
		return;

	char memberName[11];
	memberName[10] = NULL;
	Pop(data, memberName, 10);
	player->m_guild->RequestTeleport(player, memberName);
}

void CGame::ResponseGuildSummon(CClient * player, char * data)
{
	time_t now = time(NULL);
	if(!player->m_guild || now - player->m_gldSummonsTime > GUILDSUMMONSTIME)
		return;

	bool acceptTele;
	Pop(data, (uint8&)acceptTele);

	CClient * master = player->m_guild->GetMaster();
	if(acceptTele && player->m_guild->CanSummon(master, player))
	{
		RequestTeleportHandler(player->m_handle, 2 , master->m_cMapName, master->m_sX, master->m_sY);
		master->m_guild->ReduceGold( GUILDSUMMONSGOLDCOST );
	}

	player->m_gldSummonsTime = 0;
}

void CGame::GuildContribute(CClient * player, char * data)
{
	if(!player->m_guild)
		return;

	uint8 type;
	Pop(data, type);
	uint32 amount;
	Pop(data, amount);

	switch(type)
	{
	case 0:
		player->m_guild->ContributeGold(player, amount);
		break;
	case 1:
		player->m_guild->ContributeMaj(player, amount);
		break;
	case 2:
		player->m_guild->ContributeCont(player, amount);
		break;
	}
}

void CGame::GuildUpgrade(CClient * player, char * data) const
{
	if(!player->m_guild)
		return;

	uint8 gu;
	Pop(data, (uint8&)gu);

	player->m_guild->GuildUpgrade(player, (GuildUpgrades)gu);
}

void CGame::GuildsmanChange(CClient * player, char * data) const
{
	if(!player->m_guild)
		return;

	uint8 gr;
	Pop(data, (uint8&)gr);
	char memberName[11];
	ZeroMemory(memberName, sizeof(memberName) );
	Pop(data, memberName, 10);

	player->m_guild->GuildsmanChange(player, (GuildRank)gr, memberName);
}

void CGame::RequestRetrieveGuildItem(CClient * player, char * data)
{
	if(!player->m_guild || !player->m_bIsInitComplete || !player->m_bIsOnWarehouse) return;

	CItem * item;
	Pop(data, (uint32&)item);

	if( player->m_guild->RetrieveFromWarehouse(item, player) )
		player->Save();
}

void CGame::HandlePingMap(const CClient * player, char * data) const
{
	// pinguid avoids pinging the same player twice if he happens to be in party AND in guild
	static uint32 pinguid = 1;

	uint16 type, x, y;

	Pop(data, type);
	Pop(data, x);
	Pop(data, y);

	if(type & PINGMAP_PARTY)
	{
		if(player->GetParty())
			player->GetParty()->PingMap(player, x, y, pinguid);
	}

	if(type & PINGMAP_GUILD)
	{
		if(player->m_guild)
			player->m_guild->PingMap(player, x, y, pinguid);
	}

	pinguid++;
}

static const Point ITEMSPREAD_FIXED_COORD [25] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};

uint32 CGame::RollMultiple(CNpc * npc, int iItemSpreadType, int iSpreadRange, int *iItemIDs, Point *BasePos)
{
	ItemID iItemID;
	uint32 num = 0;
	
	for(int i=0; i < drops.GetSecDropNum(npc->m_sType); i++ )
	{
		iItemID = drops.Roll(npc, ONNPCDELETE);

		if(iItemID != ITEM_NONE)
		{
			iItemIDs[num] = iItemID;

			// item position
			switch(iItemSpreadType)
			{
			case ITEMSPREAD_RANDOM:
				BasePos[num].x = npc->m_sX + iSpreadRange - dice(1, iSpreadRange * 2 );
				BasePos[num].y = npc->m_sY + iSpreadRange - dice(1, iSpreadRange * 2 );
				break;

			case ITEMSPREAD_FIXED:
				BasePos[num].x = npc->m_sX + ITEMSPREAD_FIXED_COORD[num%25].x;
				BasePos[num].y = npc->m_sY + ITEMSPREAD_FIXED_COORD[num%25].y;
				if(!m_pMapList[npc->m_cMapIndex]->bGetIsMoveAllowedTile(BasePos[num]))
				{
					BasePos[num].x = npc->m_sX + ITEMSPREAD_FIXED_COORD[0].x;
					BasePos[num].y = npc->m_sY + ITEMSPREAD_FIXED_COORD[0].y;
				}
				break;
			}
			num++;
		}

	}

	return num;
}

bool CGame::_bDecodeCraftingConfigFileContents(char *pData, uint32 dwMsgSize)
{
	char * pContents, * token;
	char seps[] = "= \t\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	char cTxt[120];
	int iCraftingConfigListIndex = 0;
	

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);
	StrTok pStrTok(new CStrTok(pContents, seps));

	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			 case 1:
				 switch (cReadModeB) {
				 case 1: //
					 if (_bGetIsStringIsNumber(token) == false)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format(1).");
					 delete[] pContents;return false;
					 }
					 if (m_pCraftingConfigList[atoi(token)] != NULL)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Duplicate crafting number.");
					 delete[] pContents;return false;
					 }
					 m_pCraftingConfigList[atoi(token)] = new class CCrafting;
					 iCraftingConfigListIndex = atoi(token);
					 cReadModeB = 2;
					 break;

				 case 2:
					 ZeroMemory(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, sizeof(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName));
					 memcpy(m_pCraftingConfigList[iCraftingConfigListIndex]->m_cName, token, strlen(token));
					 cReadModeB = 3;
					 break;

				 default: // m_sArray[0~10]
					 if (_bGetIsStringIsNumber(token) == false)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return false;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					 cReadModeB++;
					 break;

				 case 14: // m_sArray[11]
					 if (_bGetIsStringIsNumber(token) == false)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return false;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_sArray[11] = atoi(token);
					 cReadModeB = 15;
					 break;

				 case 15: //
					 if (_bGetIsStringIsNumber(token) == false)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return false;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_iSkillLimit = atoi(token);
					 cReadModeB = 16;
					 break;

				 case 16://
					 if (_bGetIsStringIsNumber(token) == false)
					 { PutLogList("(!!!) CRITICAL ERROR! CRAFTING configuration file error - Wrong Data format.");
					 delete[] pContents;return false;
					 }
					 m_pCraftingConfigList[iCraftingConfigListIndex]->m_iDifficulty = atoi(token);
					 cReadModeA = 0;
					 cReadModeB = 0;
					 break;

				 }
				 break;

			 default:
				 break;
			}
		}
		else {
			if (memcmp(token, "crafting", 8) == 0)
			{ 
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}

	delete[] pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0))
	{ PutLogList("(???) CRITICAL ERROR! CRAFTING configuration file contents error!");
	return false;
	}
	wsprintf(cTxt, "(!!) CRAFTING(Total:%d) configuration - success!", iCraftingConfigListIndex);
	PutLogList(cTxt);

	return true;
}


void CGame::ReqCreateCraftingHandler(int iClientH, char *pData)
{
	char * cp, cI[6], cCraftingName[21];
	int i, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
	short sTemp;
	short sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
	bool bDup, bFlag, bNeedLog;
	class CItem * pItem;
	char g_cTxt[120];
	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++)
	{ 
		cI[i] = -1;
		sItemIndex[i] = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	cp = (char *)(pData + 11);
	cp += 20;
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;

	for (i = 0; i < 6; i++)
	{ 
		if (cI[i] >= MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
		if (cI[i] >= 0)
		{ 
			bDup = false;
			for (j = 0; j < 6; j++)
				if (sItemIndex[j] == cI[i])
				{ 
					sItemNumber[j]++;
					bDup = true;
				}

			if (bDup == false)
			{ 
				for (j = 0; j < 6; j++)
					if (sItemIndex[j] == -1)
					{ 
						sItemIndex[j] = cI[i];
						sItemNumber[j]++;
						break;
					}
			} 
		}


	for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1)
		{ 
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;

			sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum == ITEM_STONEOFMERIEN)
			{ 
				sItemPurity[i] = 100; // Merien stones considered 100% purity.
			}
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_CONSUME)
			{ 
				sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
			}
			if (sItemNumber[i] > 1) // No purity for stacked items
			{ 
				sItemPurity[i] = -1;
			}
			// Prevent upgrade of alreaddy merienned Necks
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwAttribute & 0xF0000000) != 0)
			{				
				SendNotifyMsg(NULL, iClientH, NOTIFY_CRAFTING_FAIL, NULL, NULL, NULL, NULL); // "There is not enough material"
				return;
			} 

			if((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_EQUIP
				&& m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cEquipPos == EQUIPPOS_NECK) || 
				m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemEffectType == ITEMEFFECTTYPE_SOCKET)
			{ 
				// crafting of necks and gems requires 10 contrib
				iNeededContrib = 10; 
			} 
		}

	// Bubble Sort
	bFlag = true;
	while (bFlag == true)
	{ 
		bFlag = false;
		for (i = 0; i < 5; i++)
			if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1))
			{ 
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum))
				{ 
					sTemp = sItemIndex[i+1];
					sItemIndex[i+1] = sItemIndex[i];
					sItemIndex[i] = sTemp;
					sTemp = sItemPurity[i+1];
					sItemPurity[i+1] = sItemPurity[i];
					sItemPurity[i] = sTemp;
					sTemp = sItemNumber[i+1];
					sItemNumber[i+1] = sItemNumber[i];
					sItemNumber[i] = sTemp;
					bFlag = true;
				} 
			}

	}
	j = 0;
	for (i = 0; i < 6; i++)
	{ 
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	ZeroMemory(cCraftingName, sizeof(cCraftingName));
	for (i = 0; i < MAXCRAFTING; i++)
		if (m_pCraftingConfigList[i] != NULL)
		{	
			bFlag = false;
			for (j = 0; j < 12; j++) {
				if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true; // one item mismatch
			}
			if (bFlag == false) // good Crafting receipe
			{ 
				ZeroMemory(cCraftingName, sizeof(cCraftingName));
				memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, 20);
				iRiskLevel = m_pCraftingConfigList[i]->m_iSkillLimit; // % to loose item if crafting fails
				iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
			} 
		}
	// Check if recipe is OK
	if (strlen(cCraftingName) == 0)
	{ 
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOMATCHINGCRAFTING, 1, NULL, NULL, NULL); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{ 
		SendNotifyMsg(NULL, iClientH, NOTIFY_NO_CRAFT_CONTRIB, 2, NULL, NULL, NULL); // "There is not enough Contribution Point"
		return;
	}

	// Check possible Failure
	if (dice(1,100) > iDifficulty)
	{ 
		SendNotifyMsg(NULL, iClientH, NOTIFY_CRAFTING_FAIL, NULL, NULL, NULL, NULL); // "Crafting failed"
		// Remove parts...
		for (i = 0; i < 6; i++)
			if (sItemIndex[i] != -1)
			{ // Deplete any Merien Stone
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum == ITEM_STONEOFMERIEN)
				{ 
					ItemDepleteHandler(iClientH, sItemIndex[i], false, false);
				}else
					// Risk to deplete any other items (not stackable ones) // ITEMTYPE_CONSUME
					if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_EQUIP)
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_MATERIAL)
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemEffectType == ITEMEFFECTTYPE_SOCKET)
						)
					{ 
						if (dice(1,100) < iRiskLevel)
							ItemDepleteHandler(iClientH, sItemIndex[i], false);
					} 
			}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for (i = 0; i < 6; i++)
	{ 
		if (sItemIndex[i] != -1 && sItemPurity[i] != -1)
		{ 
			iTot += sItemPurity[i];
			iCount ++;
		} 
	}
	if (iCount == 0 )
	{ 
		iPurity = 20 + dice(1,80);
		if (iPurity >=95) bNeedLog = true;
		else bNeedLog = false; 
	}else{	
		iPurity = iTot/iCount;
		iTot = (iPurity*4)/5;
		iCount = iPurity - iTot;
		iPurity = iTot + dice(1,iCount); // Jewel completion depends off Wares purity
		bNeedLog = true;
	}
	if (iNeededContrib != 0)
	{ 
		iPurity = 0; // Necks require contribution but no purity/completion
		bNeedLog = true;
	}

	if(iPurity > 200) iPurity = 200;
	if(iPurity < 0) iPurity = 20;

	if (strlen(cCraftingName) != 0)
	{ 
		pItem = new class CItem;
		if (pItem == NULL) return;
		for (i = 0; i < 6; i++)
		{ 
			if (sItemIndex[i] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == ITEMTYPE_CONSUME) {
					SetItemCount(iClientH, sItemIndex[i], m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
				}else // So if item is not Type 5 (stackable items), you deplete item
				{ 
					ItemDepleteHandler(iClientH, sItemIndex[i], false, false);
				} 
			} 
		}
		if (iNeededContrib !=0)
		{ 
			m_pClientList[iClientH]->m_iContribution -= iNeededContrib;
			// No known msg to send info to client, so client will compute shown Contrib himself.
		}

		SendNotifyMsg(NULL, iClientH, NOTIFY_CRAFTING_SUCCESS, NULL, NULL, NULL, NULL);

		GetExp(iClientH, dice(2, 100));

		if ((pItem->InitItemAttr(cCraftingName) == true))
		{
			if (iPurity != 0)
			{ 
				pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->m_sTouchEffectType = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
			// pItem->m_sTouchEffectValue3 = timeGetTime();
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d", (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			if (bNeedLog)
			{ 
				wsprintf(g_cTxt, "PC(%s) Crafting (%s) Purity(%d)"
				, m_pClientList[iClientH]->m_cCharName
				, pItem->m_cName
				, pItem->m_sItemSpecEffectValue2);
				PutLogList(g_cTxt);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true)
			{ 
				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
				
				if (iEraseReq == 1) delete pItem;
				
			//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000)
			// SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}else
			{ 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX,	m_pClientList[iClientH]->m_sY, pItem);
				
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);

				SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
			} 
		}else
		{ 
			delete pItem;
			pItem = NULL;
		} 
	}
} 

void CGame::WriteItemData(char * &cp, CItem * pItem) const
{
	uint32 * dwp;
	uint16 * wp;
	short * sp;

	if(!cp) return;

	memcpy(cp, pItem->m_cName, 20);
	cp += 20;

	dwp  = (uint32 *)cp;
	*dwp = pItem->m_dwCount;
	cp += 4;

	*cp = pItem->m_cItemType;
	cp++;

	*cp = pItem->m_cEquipPos;
	cp++;

	*cp = (char)0; 
	cp++;

	sp  = (short *)cp;
	*sp = pItem->m_sLevelLimit;
	cp += 2;

	*cp = pItem->m_cGenderLimit;
	cp++;

	wp = (uint16 *)cp;
	*wp = pItem->m_wCurLifeSpan;
	cp += 2;

	wp = (uint16 *)cp;
	*wp = pItem->m_wWeight;
	cp += 2;

	sp  = (short *)cp;
	*sp = pItem->m_sSprite;
	cp += 2;

	sp  = (short *)cp;
	*sp = pItem->m_sSpriteFrame;
	cp += 2;

	*cp = pItem->m_cItemColor;
	cp++;

	return;

}

void CGame::TileCleaner()
{
	class CItem * pItem[ITEMS_PER_TILE] = {NULL};
	short sNextItemSprite, sNextItemSpriteFrame;
	char  cNextItemColor;
	bool bReplaceSprite;
	time_t now = time(NULL);

	for(int i = 0; i < MAXGROUNDITEMS; i++)
	{
		if(m_stGroundNpcItem[i].bEmpty || 
			m_stGroundNpcItem[i].dropTime > now)	
			continue;

		m_stGroundNpcItem[i].bEmpty = true;
		bReplaceSprite = true;
		sNextItemSprite = sNextItemSpriteFrame = 0;
		cNextItemColor = 0;

		for(int j = 0; j < ITEMS_PER_TILE; j++)
		{
			pItem[j] = m_pMapList[m_stGroundNpcItem[i].cMapIndex]->pGetItem(m_stGroundNpcItem[i].sx, m_stGroundNpcItem[i].sy, &sNextItemSprite, &sNextItemSpriteFrame, &cNextItemColor);

			if(!pItem[j]) 
				continue;
			else if(pItem[j] == m_stGroundNpcItem[i].item)
			{
				delete pItem[j];
				pItem[j] = NULL;
				continue;
			}
			else if(bReplaceSprite)
				bReplaceSprite = false;
		}

		for(int j=ITEMS_PER_TILE; j; j--)
		{
			if(pItem[j-1])
				m_pMapList[m_stGroundNpcItem[i].cMapIndex]->bSetItem(m_stGroundNpcItem[i].sx, m_stGroundNpcItem[i].sy, pItem[j-1]);
		}

		if(bReplaceSprite)
		{
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_SETITEM, m_stGroundNpcItem[i].cMapIndex,
				m_stGroundNpcItem[i].sx, m_stGroundNpcItem[i].sy,
				sNextItemSprite, sNextItemSpriteFrame, cNextItemColor);
		}
	}
}

void CGame::AddGroundItem(CItem * pItem, short x, short y, char mapIndex, uint32 dwTime)
{
	for(int i = 0; i < MAXGROUNDITEMS; i++)
	{
		if(m_stGroundNpcItem[i].bEmpty)
		{
			m_stGroundNpcItem[i].bEmpty = false;
			m_stGroundNpcItem[i].dropTime = time(NULL) + dwTime;
			m_stGroundNpcItem[i].item = pItem;
			m_stGroundNpcItem[i].sx = x;
			m_stGroundNpcItem[i].sy = y;
			m_stGroundNpcItem[i].cMapIndex = mapIndex;
			return;
		}
	}
	PutLogList("WARNING: Ground NPC item list is full, item will not be cleared.");
}

void CGame::HandleLegionService(char * data)
{
	uint16 clientH = *(uint16 *)(data+6);
	uint16 cmd = *(uint16 *)(data+4);
	CClient * player;

	player = m_pClientList[clientH];

	if (!player || !player->m_bIsInitComplete || 
		memcmp(player->m_cMapName, "cityhall", 8) != 0) return;

	int i=0;
	while(lgnPtsSvcs[i].price && 
		lgnPtsSvcs[i].cmd != cmd) 
	{i++;}

	switch(cmd)
	{
	case CMD_LGNSVC_TOARE:
		if(!ChangeNation(clientH, ARESDEN))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;
	case CMD_LGNSVC_TOELV:
		if(!ChangeNation(clientH, ELVINE))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;
	case CMD_LGNSVC_GOLD10:
		if(!GetLegionItemCount(clientH, "Gold", 10000))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;
	case CMD_LGNSVC_GOLD100:
		if(!GetLegionItemCount(clientH, "Gold", 100000))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;
	case CMD_LGNSVC_TOKEN1:
		if(!GetLegionItemCount(clientH, "LegionTokens", 1))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;
	case CMD_LGNSVC_TOKEN10:
		if(!GetLegionItemCount(clientH, "LegionTokens", 10))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;
	case CMD_LGNSVC_TOKEN100:
		if(!GetLegionItemCount(clientH, "LegionTokens", 100))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;
	case CMD_LGNSVC_MAGEHAT:
	case CMD_LGNSVC_BMAGEHAT:
	case CMD_LGNSVC_WARRIORHELM:
	case CMD_LGNSVC_BMAGEHELM:
	case CMD_LGNSVC_XPSLATE:
	case CMD_LGNSVC_ZERKSLATE:
	case CMD_LGNSVC_MPSLATE:
	case CMD_LGNSVC_HPSLATE:
	case CMD_LGNSVC_ZEM:
	case CMD_LGNSVC_SOM:
	case CMD_LGNSVC_SOX: 
		if(!GetLegionItem(clientH, cmd))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;

	case CMD_LGNSVC_TRADETOKEN1:
	case CMD_LGNSVC_TRADETOKEN10:
	case CMD_LGNSVC_TRADETOKEN100:
		if(!GetLegionPoints(clientH, cmd))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, false);
		break;

	case CMD_LGNSVC_TRADECANCEL:
	case CMD_LGNSVC_TRADEIMC:
	case CMD_LGNSVC_TRADEICESTORM:
	case CMD_LGNSVC_TRADEMFS:
	case CMD_LGNSVC_TRADEBS:
	case CMD_LGNSVC_TRADEESW:
		if(!GetSpellBack(clientH, cmd))
			return;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;

	case CMD_LGNSVC_MAJ2:
	case CMD_LGNSVC_MAJ20:
		player->m_iGizonItemUpgradeLeft += 2 * lgnPtsSvcs[cmd].price;
		SendNotifyMsg(NULL, clientH, NOTIFY_GIZONITEMUPGRADELEFT, player->m_iGizonItemUpgradeLeft, 1, NULL, NULL);
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;

	case CMD_LGNSVC_REP10:
	case CMD_LGNSVC_REP100:
		player->m_reputation += 10 * lgnPtsSvcs[cmd].price;
		LegionCash(player->m_cAccountName, lgnPtsSvcs[i].cmd, true);
		break;

	default:
		return;
	}

	bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, clientH);
}

void CGame::LegionCash(char * account, uint16 cmd, bool Type)
{
	char data[20];
	uint16 * wp; char * cp;

	cp = (char *)data;
	memcpy(cp, account, 10);
	cp += 10;

	wp = (uint16*)cp;
	*wp = cmd;

	if(!Type) 
		bSendMsgToLS(MSGID_ADDCASH, NULL, NULL, data);
	else if(Type)
		bSendMsgToLS(MSGID_SUBCASH, NULL, NULL, data);
}

bool CGame::GetLegionPoints(int clientH, uint16 cmd)
{
	char  cItemName[21];

	assert(cmd >= CMD_LGNSVC_TRADETOKEN1 && cmd <= CMD_LGNSVC_TRADETOKEN100);
	
	wsprintf(cItemName, "LegionTokens");
	uint32 count = dwGetItemCount(clientH, cItemName);
	
	if (lgnPtsSvcs[cmd].price <= count) {
		if(SetItemCount(clientH, cItemName, count - lgnPtsSvcs[cmd].price) != -1) return true;
	}


	wsprintf(cItemName, "LegionDonateTokens");
	count = dwGetItemCount(clientH, cItemName);
	
	if (lgnPtsSvcs[cmd].price <= count) {
		if(SetItemCount(clientH, cItemName, count - lgnPtsSvcs[cmd].price) != -1) return true;
	}

	return false;
}

bool CGame::GetSpellBack(int clientH, uint16 cmd)
{
	class CItem * pItem;
	int   iEraseReq;
	char  cItemName[21], cMagicName[31];
	uint32 attr = 0;
	int    i, unused, magicID;
	CMagic * spell;

	ZeroMemory(cItemName, sizeof(cItemName));
	ZeroMemory(cMagicName, sizeof(cMagicName));

	CClient * player = m_pClientList[clientH];

	if (_iGetItemSpaceLeft(clientH) == 0) 
	{
		SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return false;
	}

	switch (cmd) 
	{
	case CMD_LGNSVC_TRADECANCEL:
		wsprintf(cMagicName, "Cancellation");
		magicID = _iGetMagicNumber(cMagicName, &unused, &unused);

		if ((magicID > -1) && (player->m_cMagicMastery[magicID] == 1)) {
			player->m_cMagicMastery[magicID] = 0;	
			wsprintf(cItemName, "CancelManual");
		}else if (magicID == -1) return false;
		break;

	case CMD_LGNSVC_TRADEIMC:
		wsprintf(cMagicName, "Inhibition-Casting");
		magicID = _iGetMagicNumber(cMagicName, &unused, &unused);

		if ((magicID > -1) && (player->m_cMagicMastery[magicID] == 1)) {
			player->m_cMagicMastery[magicID] = 0;	
			wsprintf(cItemName, "I.M.CManual");
		}else if (magicID == -1) return false;
		break;

	case CMD_LGNSVC_TRADEICESTORM:
		wsprintf(cMagicName, "Ice-Storm");
		magicID = _iGetMagicNumber(cMagicName, &unused, &unused);

		if ((magicID > -1) && (player->m_cMagicMastery[magicID] == 1)) {
			player->m_cMagicMastery[magicID] = 0;	
			wsprintf(cItemName, "IceStormManual");
		}else if (magicID == -1) return false;
		break;

	case CMD_LGNSVC_TRADEMFS:
		wsprintf(cMagicName, "Mass-Fire-Strike");
		magicID = _iGetMagicNumber(cMagicName, &unused, &unused);

		if ((magicID > -1) && (player->m_cMagicMastery[magicID] == 1)) {
			player->m_cMagicMastery[magicID] = 0;	
			wsprintf(cItemName, "MassFireStrikeManual");
		}else if (magicID == -1) return false;
		break;

	case CMD_LGNSVC_TRADEBS:
		wsprintf(cMagicName, "Bloody-Shock-Wave");
		magicID = _iGetMagicNumber(cMagicName, &unused, &unused);

		if ((magicID > -1) && (player->m_cMagicMastery[magicID] == 1)) {
			player->m_cMagicMastery[magicID] = 0;	
			wsprintf(cItemName, "BloodyShockW.Manual");
		}else if (magicID == -1) return false;
		break;

	case CMD_LGNSVC_TRADEESW:
		wsprintf(cMagicName, "Earth-Shock-Wave");
		magicID = _iGetMagicNumber(cMagicName, &unused, &unused);

		if ((magicID > -1) && (player->m_cMagicMastery[magicID] == 1)) {
			player->m_cMagicMastery[magicID] = 0;	
			wsprintf(cItemName, "E.S.W.Manual");
		}else if (magicID == -1) return false;
		break;

	default:
		return false;
	}

	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return false;

	if(pItem->InitItemAttr(cItemName)) 
	{
		pItem->m_sTouchEffectType   = ITET_ID;
		pItem->m_sTouchEffectValue1 = dice(1,100000);
		pItem->m_sTouchEffectValue2 = dice(1,100000);
		pItem->m_sTouchEffectValue3 = (short)timeGetTime();

		if (_bAddClientItemList(clientH, pItem, &iEraseReq) == true) 
		{
			SendNotifyMsg(NULL, clientH, NOTIFY_SPELL_SKILL, NULL, NULL, NULL, NULL);
			SendItemNotifyMsg(clientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
			if (iEraseReq == 1) delete pItem;
			_bItemLog(ITEMLOG_GET, clientH, -1, pItem);
			return true;
		}
		else 
		{
			delete pItem;
			SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
			return false;
		}
	}
	else 
	{
		delete pItem;
		return false;
	}
	return false;
}

bool CGame::GetLegionItemCount(int clientH, char * cItemName, long count)
{
	int iEraseReq;
	class CItem * pItem;

	pItem = new class CItem;
	pItem->InitItemAttr(cItemName);
	pItem->m_dwCount = count;

	if (_bAddClientItemList(clientH, pItem, &iEraseReq)) 
	{
		SendItemNotifyMsg(clientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
		if (iEraseReq == 1) delete pItem;
		return true;
	}
	else {
		delete pItem;
		SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return false;
	}
	return false;
}

bool CGame::GetLegionItem(int clientH, uint16 cmd)
{
	class CItem * pItem;
	int   iEraseReq;
	char  cItemName[21];
	uint32 attr = 0;

	CClient * player = m_pClientList[clientH];

	if (_iGetItemSpaceLeft(clientH) == 0) 
	{
		SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
		return false;
	}

	switch (cmd) 
	{
	case CMD_LGNSVC_MAGEHAT:
	case CMD_LGNSVC_BMAGEHAT:
		if (player->m_cSex == MALE) wsprintf(cItemName, "LegionHat(M)");
		else if (player->m_cSex == FEMALE) wsprintf(cItemName, "LegionHat(W)");
		if(cmd == CMD_LGNSVC_MAGEHAT)
			attr = 0x6200; // mp14
		else if(cmd == CMD_LGNSVC_BMAGEHAT)
			attr = 0x4200; // hp14
		break;
	case CMD_LGNSVC_WARRIORHELM:
	case CMD_LGNSVC_BMAGEHELM:
		if (player->m_cSex == MALE) wsprintf(cItemName, "LegionHelm(M)");
		else if (player->m_cSex == FEMALE) wsprintf(cItemName, "LegionHelm(W)");
		if(cmd == CMD_LGNSVC_WARRIORHELM)
			attr = 0x4200; // hp14
		else if(cmd == CMD_LGNSVC_BMAGEHELM)
			attr = 0x6200; // mp14
		break;
	case CMD_LGNSVC_XPSLATE:
	case CMD_LGNSVC_ZERKSLATE:
	case CMD_LGNSVC_MPSLATE:
	case CMD_LGNSVC_HPSLATE:
		wsprintf(cItemName, "AcientTablet");
		break;
	case CMD_LGNSVC_ZEM:
		wsprintf(cItemName, "ZemstoneofSacrifice");
		break;
	case CMD_LGNSVC_SOM:
		wsprintf(cItemName, "StoneOfMerien");
		break;
	case CMD_LGNSVC_SOX:
		wsprintf(cItemName, "StoneOfXelima");
		break;
	default:
		return false;
	}

	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return false;

	pItem->m_dwAttribute = attr;

	if(pItem->InitItemAttr(cItemName)) 
	{
		if(strcmp(cItemName, "AcientTablet") == 0)
		{
			int iSlateType = 0;
			char cSlateColour = 0;

			switch(cmd)
			{
			case CMD_LGNSVC_XPSLATE:
				iSlateType = 4;
				cSlateColour = 7;
				break;
			case CMD_LGNSVC_ZERKSLATE:
				iSlateType = 2;
				cSlateColour = 3;
				break;
			case CMD_LGNSVC_MPSLATE:
				iSlateType = 3;
				cSlateColour = 37;
				break;
			case CMD_LGNSVC_HPSLATE:
				iSlateType = 1;
				cSlateColour = 32;
				break;
			}

			pItem->m_sItemSpecEffectValue2 = iSlateType;
			pItem->m_cItemColor = cSlateColour;
		}
		else if(memcmp(cItemName, "Legion", 6) == 0)
		{
			pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
			pItem->m_sTouchEffectValue1 = player->m_sCharIDnum1;
			pItem->m_sTouchEffectValue2 = player->m_sCharIDnum2;
			pItem->m_sTouchEffectValue3 = player->m_sCharIDnum3;
		}
		else
		{
			pItem->m_sTouchEffectType   = ITET_ID;
			pItem->m_sTouchEffectValue1 = dice(1,100000);
			pItem->m_sTouchEffectValue2 = dice(1,100000);
			pItem->m_sTouchEffectValue3 = (short)timeGetTime();
		}


		if (_bAddClientItemList(clientH, pItem, &iEraseReq) == true) 
		{
			SendItemNotifyMsg(clientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
			if (iEraseReq == 1) delete pItem;
			_bItemLog(ITEMLOG_GET, clientH, -1, pItem);
			return true;
		}
		else 
		{
			delete pItem;
			SendItemNotifyMsg(clientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);
			return false;
		}
	}
	else 
	{
		delete pItem;
		return false;
	}
	return false;
}

bool CGame::ChangeNation(int clientH, Side side)
{
	char cData[20];
	uint32 * dwp; uint16 * wp; char * cp;
	CClient * player = m_pClientList[clientH];

	if(player->m_side == side || m_bIsCrusadeMode) return false;

	player->m_side = side;
	ZeroMemory(player->m_cLocation, sizeof(player->m_cLocation));
	strcpy(player->m_cLocation, sideMap[side]);
	player->SetSideFlag(side);

	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = NOTIFY_RESPONSE_HUNTMODE;

	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	memcpy(cp, player->m_cLocation, 10);
	cp += 10;

	switch (player->m_pXSock->iSendMsg(cData, 16)) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(clientH, true, true);
		return false;
	}

	SendEventToNearClient_TypeA(clientH, OWNERTYPE_PLAYER, MSGID_MOTION_NULL, NULL, NULL, NULL);

	player->WithdrawFromGuild();

	if(player->GetParty()) 
		partyMgr.RemoveFromParty( player );
	
	RequestTeleportHandler(player->m_handle, 0);

	return true;
}

uint32 CGame::FindNPC(const string npcName)
{
	for (uint32 i = 0; i < MAXNPCTYPES; i++) 
	{
		if (g_npcConfigList[i] && 
			npcName == g_npcConfigList[i]->m_cNpcName) 
		{
			return g_npcConfigList[i]->m_sType;
		}
	}
	return NPC_INVALID;
}

uint32 CGame::FindItem(const string itemName)
{
	for (uint32 i = 0; i < MAXITEMTYPES; i++) 
	{
		if (m_pItemConfigList[i] && 
			itemName == m_pItemConfigList[i]->m_cName) 
		{
			return m_pItemConfigList[i]->m_sIDnum;
		}
	}
	return ITEM_INVALID;
}

void CGame::EventStart(EventType eType)
{
	switch(eType)
	{
	case ET_CAPTURE:
	case ET_DESTROY_SHIELD:
		m_astoria.reset();
		m_astoria.reset(new CAstoria(eType));
		break;
	default:
		return;
	}

	int shortCutIndex = 0;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		SendNotifyMsg(NULL, index, NOTIFY_EVENTSTART, eType, NULL, NULL, NULL);

		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex && !m_pClientList[index]->IsGM())
		{
			SendNotifyMsg(NULL, index, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
			RequestTeleportHandler(index, 0);
		}
	}
}

void CGame::EventEnd()
{
	Side winner = m_astoria->GetVictoriousSide();
	m_eventWinner[ m_astoria->GetEventType() ] = winner;

	char c[5];
	ZeroMemory(c, sizeof(winner));
	_itoa(winner, c, 10);

	sstream evType;
	evType << (int)m_astoria->GetEventType();
	m_eventsIni->WriteInteger(evType.str().c_str(), winner);

	int shortCutIndex = 0;
	CClient * client;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		SendNotifyMsg(NULL, index, NOTIFY_EVENTWINNER, m_astoria->GetEventType(), winner, NULL, NULL, NULL);
		client = m_pClientList[index];
		if(client->m_cMapIndex == m_iAstoriaMapIndex && client->m_side == winner)
		{
			client->m_iContribution += 30;
	}
	}

	for (int i = 0; i < MAXNPCS; i++)
	{
		if (m_pNpcList[i] && m_pNpcList[i]->m_cMapIndex == m_iAstoriaMapIndex){
			switch (m_pNpcList[i]->m_sType) 
			{
			case NPC_AGT:
			case NPC_CGT:
			case NPC_DT:
				DeleteNpc(i);
				break;
			}
		}
	}

	m_astoria.reset();
}

void CGame::NotifyEventStats(const Casualties * stats) const
{
	int shortCutIndex = 0;
	CClient * ipClient;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
			SendNotifyMsg(NULL, index, NOTIFY_CASUALTIES, 
			stats[ARESDEN].deaths, stats[ELVINE].deaths, stats[ISTRIA].deaths, NULL, 
			stats[ARESDEN].kills, stats[ELVINE].kills, stats[ISTRIA].kills);
	}
}

void CGame::NotifyRelicInAltar(const Side altarSide) const
{
	int shortCutIndex = 0;
	CClient * ipClient;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
			SendNotifyMsg(NULL, index, NOTIFY_RELICINALTAR, altarSide, NULL, NULL, NULL);
	}
}

void CGame::NotifyRelicGrabbed(const CClient * picker) const
{
	int shortCutIndex = 0;
	CClient * ipClient;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
			SendNotifyMsg(NULL, index, NOTIFY_RELICGRABBED, NULL, NULL, NULL, picker->m_cCharName);
	}
}

void CGame::ShuffleAstoriaBasePos()
{
	Side sides[MAXALTARS] = {ARESDEN, ELVINE/*, ISTRIA*/};

	for(int i=0; i < MAXALTARS; i++)
	{
		int pos = rand()%(MAXALTARS-i);
		m_astoriaBasePos[i] = sides[pos];
		if(pos != MAXALTARS-i)
			sides[pos] = sides[MAXALTARS-i-1];
	}
}

void CGame::CreateAstoriaFlags()
{
	uint32 dynObj;

	for(int i=0; i < MAXALTARS; i++)
	{
		switch(m_astoriaBasePos[i])
		{
		case ARESDEN:
			dynObj = DYNAMICOBJECT_ARESDENFLAG;
			break;
		case ELVINE:
			dynObj = DYNAMICOBJECT_ELVINEFLAG;
			break;
		}

		int j=0;
		while(astoriaFlagsPos[i][j].x != -1)
		{
			iAddDynamicObjectList(NULL, NULL, dynObj, m_iAstoriaMapIndex, 
				astoriaFlagsPos[i][j].x, astoriaFlagsPos[i][j].y, NULL);
			j++;
		}
	}
}

void CGame::UpdateWebsiteStats()
{
	if(strlen(m_websiteScriptAddr) != 0 && strlen(m_websiteAddr) != 0 && m_websitePort != 0){
		m_webSocket = new XSocket(m_hWnd, SERVERSOCKETBLOCKLIMIT);
		m_webSocket->bConnect(m_websiteAddr, m_websitePort, WM_ONWEBSOCKETEVENT, true);
		m_webSocket->bInitBufferSize(MSGBUFFERSIZE);
	}
}

void CGame::OnWebSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	int iRet;
	char data[50], datalen[5], postInfo[400];
		
	if (m_webSocket == NULL) return;

	iRet = m_webSocket->iOnSocketEvent(wParam, lParam);

	if (iRet == XSOCKEVENT_CONNECTIONESTABLISH){
		ZeroMemory(postInfo, sizeof(postInfo));

		wsprintf(data, "code=L58sk2hK29dks&online=%d", m_iTotalGameServerClients + m_onlineCntAdd);
		wsprintf(datalen, "%d", strlen(data));

		wsprintf(postInfo, "POST %s HTTP/1.1\r\nHost: %s\r\n", m_websiteScriptAddr, m_websiteAddr); 
		strcat(postInfo, "Connection: close\r\n");
		strcat(postInfo, "Content-type: application/x-www-form-urlencoded\r\n");
		strcat(postInfo, "Content-length: ");
		strcat(postInfo, datalen);
		strcat(postInfo, "\r\n\r\n");
		strcat(postInfo, data);

		m_webSocket->SendRawMsg(postInfo, strlen(postInfo));
	}

	delete m_webSocket;
	m_webSocket = NULL;
}

void CGame::UpdateRelicPos(int iClientH)
{
	int shortCutIndex = 0;
	Point relicPos;
	CClient * ipClient;

	if (m_astoria.get()) {
		if((ipClient = m_astoria->GetRelicHolder()) != NULL){
			relicPos.x = ipClient->m_sX;
			relicPos.y = ipClient->m_sY;
		} 
		else {
			relicPos = m_astoria->GetRelicPos();
		}

		if(iClientH){
			SendNotifyMsg(NULL, iClientH, NOTIFY_RELICPOSITION, relicPos.x, relicPos.y, NULL, NULL);
		}else {
			while(int index = m_iClientShortCut[shortCutIndex++])
			{
				if(m_pClientList[index]->m_cMapIndex == m_iAstoriaMapIndex)
					SendNotifyMsg(NULL, index, NOTIFY_RELICPOSITION, relicPos.x, relicPos.y, NULL, NULL);
			}
		}
	}
}

void CGame::RequestSetRecallPoint(int iClientH, char * pData, uint32 dwMsgSize)
{
	int recallPoint;

	if (dwMsgSize <= 0) return;
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	recallPoint = *((char *)(pData + INDEX2_MSGTYPE + 2));

	if (recallPoint < 1 && recallPoint > 5) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pInitialPoint[recallPoint].x == -1 || 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pInitialPoint[recallPoint].y == -1) return;

	m_pClientList[iClientH]->m_nextRecallPoint = recallPoint;
}

bool CGame::WriteTileData(char * buffer, int & sizeWritten, int iClientH, CTile * srcTile, int ix, int iy)
{
	unsigned char ucHeader;
	uint16  * wp;
	short * sp;
	char * cp = buffer;
	int *ip;
	bool dataWritten = false;

	CTile * pTile = (class CTile *)(srcTile + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
		(pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			dataWritten = true;
			sp = (short *)cp;
			*sp = (short)ix;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)iy;
			cp += 2;
			sizeWritten += 4;

			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {

				if (pTile->m_cOwnerClass == OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else {
						// ###debugcode
						wsprintf(g_cTxt, "Empty player handle: %d", pTile->m_sOwner);
						//PutLogFileList(g_cTxt);
						//
						pTile->m_sOwner = NULL;
					}
				}

				if (pTile->m_cOwnerClass == OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			sizeWritten++;

			if ((ucHeader & 0x01) != 0) {

				switch (pTile->m_cOwnerClass) {
					case OWNERTYPE_PLAYER:
						// Object ID number(Player) : 1~10000
						sp  = (short *)cp;
						*sp	= pTile->m_sOwner;
						cp += 2;
						sizeWritten += 2;
						// object type
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
						cp += 2;
						sizeWritten += 2;
						// dir
						*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
						cp++;
						sizeWritten++;
						// Appearance1
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
						cp += 2;
						sizeWritten += 2;
						// Appearance2
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						sizeWritten += 2;
						// Appearance3
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
						cp += 2;
						sizeWritten += 2;
						// Appearance4
						sp  = (short *)cp;
						*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
						cp += 2;
						sizeWritten += 2;

						ip = (int *)cp;
						*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
						cp += 4;
						sizeWritten += 4;

						// Status
						ip  = (int *)cp;

						if(_bGetIsPlayerHostile(iClientH,pTile->m_sOwner) && pTile->m_sOwner != iClientH && m_pClientList[iClientH]->m_iAdminUserLevel == 0)
							*ip = STATUS_ENEMYFLAGS & m_pClientList[pTile->m_sOwner]->m_iStatus;
						else 
							*ip = m_pClientList[pTile->m_sOwner]->m_iStatus;

						cp += 4;
						sizeWritten += 4;
						// Name
						memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
						cp    += 10;
						sizeWritten += 10;
						break;

					case OWNERTYPE_NPC:
						// Object ID number(NPC) : 10000	~
						sp  = (short *)cp;
						*sp	= pTile->m_sOwner + 10000;
						cp += 2;
						sizeWritten += 2;
						// object type
						sp  = (short *)cp;
						*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
						cp += 2;
						sizeWritten += 2;
						// dir
						*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
						cp++;
						sizeWritten++;
						// Appearance2
						sp  = (short *)cp;
						*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
						cp += 2;
						sizeWritten += 2;
						// Status
						ip  = (int *)cp;

						*ip = m_pNpcList[pTile->m_sOwner]->m_iStatus;
						cp += 4;
						sizeWritten += 4;
						break;
				}
			}

			if ((ucHeader & 0x02) != 0) {

				switch (pTile->m_cDeadOwnerClass) 
				{
				case OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					sizeWritten += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					sizeWritten += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					sizeWritten++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					sizeWritten += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					sizeWritten += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					sizeWritten += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					sizeWritten += 2;

					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					sizeWritten += 4;

					// Status
					ip  = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					cp += 4;
					sizeWritten += 4;

					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					sizeWritten += 10;
					break;

				case OWNERTYPE_NPC:
					// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					sizeWritten += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					sizeWritten += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					sizeWritten++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					sizeWritten += 2;
					// Status
					ip  = (int *)cp;

					*ip = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					cp += 4;
					sizeWritten += 4;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {

				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				sizeWritten += 2;
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				sizeWritten += 2;
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				sizeWritten++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				wp  = (uint16 *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				sizeWritten += 2;

				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				sizeWritten += 2;
			}
	}

	return dataWritten;
}


void CGame::LocalStartApocalypse()
{ 
	int i;
	char cTxt[120];
	if (m_bIsApocalypseMode) return;
	uint32 dwTime = timeGetTime();

	m_bIsApocalypseMode = true;
	m_bIsApocalypseGateOpen	= true;

	for (i = 1; i < MAXCLIENTS; i++) 
	{	
		if (m_pClientList[i] != NULL) 
		{	
			SendNotifyMsg(NULL, i, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);	
		}	
	}

	int iShortCutIndex = 0;
	while(int i = m_iClientShortCut[iShortCutIndex++])
	{
		Notify_ApocalypseGateState(i);		
	} 
	wsprintf(cTxt,"(_)Apocalypse Mode ON.");
	PutLogList(cTxt);				
}


void CGame::Notify_ApocalypseGateState(int iClientH)
{	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (!m_bIsApocalypseMode) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	bool notifyOfStart = false;

	int gX = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2)/2;
	int gY = (m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)/2;
	
	switch (m_pMapList[iMapIndex]->m_cDynamicGateType){
	case 0:	// No gate on current map		
		if(m_bIsApocalypseGateOpen == true) 
		{	
			notifyOfStart = true;
		}else{
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, 0, 0, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 1:	// Initial Dynamic gates (toh, IB, D4...)
		if(m_bIsApocalypseGateOpen == true) 
		{	
			notifyOfStart = true;
		}else{	
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
		break;
	case 2: // Empty maps Dynamic gates (inferniaA, inferniaB, procella...)
		if (m_pMapList[iMapIndex]->m_iTotalActiveObject == 0)
		{	
			notifyOfStart = true;
		}else {	
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, gX, gY , NULL, m_pClientList[iClientH]->m_cMapName);
		}
		break;
	case 3: 
		SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATECLOSE, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		break;	
	case 4: // Show the gate on abaddon map..when Abaddon spawning.
		notifyOfStart = true;
		break;
	case 5:	// GM command Dynamic gates (even not in apocalypse mode)
		gX = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 + 1;
		gY = m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 + 1;
		notifyOfStart = true;
		break;
	}

	if (notifyOfStart) {
		if (m_pClientList[iClientH]->m_notifedOfApoc == false) {
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_notifedOfApoc = true;
		}
		if (gX > 0 && gY > 0)
		{
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, NOTIFY_APOCGATEOPEN, gX, gY, NULL, m_pClientList[iClientH]->m_cMapName);
		}
	}

}


void CGame::Use_ApocalypseGate(int iClientH)
{	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (!m_bIsApocalypseMode) return;
	int iMapIndex = m_pClientList[iClientH]->m_cMapIndex;
	if(m_pClientList[iClientH]->m_sX >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 &&
		m_pClientList[iClientH]->m_sX <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 &&
		m_pClientList[iClientH]->m_sY >= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 &&
		m_pClientList[iClientH]->m_sY <= m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2)
	{	
		switch(m_pMapList[iMapIndex]->m_cDynamicGateType)
		{
		case 0: // No Dynamic Gate on this map
			return;
		case 1: // Apocalypse normal gate
			if(!m_bIsApocalypseGateOpen || m_bIsCrusadeMode)	return; 
			break;
		case 2: // Apocalypse gate opened when map empty
			if (m_pMapList[iMapIndex]->m_iTotalActiveObject != 0) return; 
			break;
		case 3: // Apocalypse gate back to town closed
			return;
		case 4: // Apocalypse gate back to town open when Abaddon has died
			RequestTeleportHandler(iClientH, 0);
			return;
		case 5: // Admin created gate
			break;
		}
		RequestTeleportHandler(iClientH, 2, m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap,
			m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX, m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY);	
	}
}

void CGame::GlobalStartApocalypseMode(int iClientH)
{	char * cp, cData[120], cString[200], cTxt[120];
	ZeroMemory(cString, sizeof(cString));
	if ((iClientH != 0) && (m_pClientList[iClientH]->m_iAdminUserLevel < 3)) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	if (m_bIsApocalypseMode) return;
	if (m_bIsCrusadeMode) return;	

	if (iClientH !=0)
		{	wsprintf(cTxt, "Admin Order(%s): /beginapocalypse \tAdminIP(%s)"
				, m_pClientList[iClientH]->m_cCharName
				, m_pClientList[iClientH]->m_cIPaddress);
			wsprintf(cString, "Apocalypse starting in progress.");
		}else
		{	wsprintf(cTxt, "Local command: beginapocalypse");
		}	
		_bCrusadeLog(CRUSADELOG_APOCALYPSE, NULL, 0, "Begin Apocalypse.");	
		PutLogList(cTxt);	
	if (iClientH !=0)
	{	SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINAPOCALYPSE;
	cp++;
	bStockMsgToGateServer(cData, 5);
	LocalStartApocalypse();
}





void CGame::GlobalEndApocalypseMode(int iClientH)
{	char * cp, cData[120], cString[200], cTxt[120];
	if (!m_bIsApocalypseMode) return;
	if (iClientH > 0)	
	{	wsprintf(cTxt, "Admin Order(%s): /endapocalypse \tAdminIP(%s)"
			, m_pClientList[iClientH]->m_cCharName
			, m_pClientList[iClientH]->m_cIPaddress);
		ZeroMemory(cString, sizeof(cString));
		wsprintf(cString, "Apocalypse ending in progress.");
		SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}else
	{	wsprintf(cTxt, "Automated: endapocalypse");
	}
	_bCrusadeLog(CRUSADELOG_APOCALYPSE, NULL, 0, "End Apocalypse.");	
	PutLogList(cTxt);	
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;	
	bStockMsgToGateServer(cData, 5);
	LocalEndApocalypse();
}

void CGame::LocalEndApocalypse()
{	char cTxt[120];
	if (!m_bIsApocalypseMode) return;
	m_bIsApocalypseMode = false;
	m_bIsApocalypseGateOpen	= false; 


	for (int i = 1; i < MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL)
		{	SendNotifyMsg(NULL, i, NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
			if ((m_pClientList[i]->m_iAdminUserLevel == 0) && (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == true)) 
			{	SendNotifyMsg(NULL, i, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
				RequestTeleportHandler(i, 0);
	}	}	}	
	// restore normal spawn on apoc maps
	for (int i = 0; i < MAXMAPS; i++)
	{	
		if (m_pMapList[i] != NULL) 
		{	
			if (m_pMapList[i]->m_cDynamicGateType == 4 )
			{	
				m_pMapList[i]->m_cDynamicGateType = 3;
			}
			if (m_pMapList[i]->m_cDynamicGateType == 2)
			{	
				GenerateSlime(i);	// to force the gate to close		
			}

			int iShortCutIndex = 0;
			while(int i = m_iClientShortCut[iShortCutIndex++])
			{
				Notify_ApocalypseGateState(i);		
			} 
		}	
	}
	wsprintf(cTxt,"(_) Apocalypse Mode OFF.");
	PutLogList(cTxt);
}
void CGame::GenerateApocalypseBoss(int MapIndex)
{	
	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	if (!m_bIsApocalypseMode) return;

	char cNpcName[21], cNpcWaypoint[11], cTxt[120];
	int x;
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	ZeroMemory(cNpcName, sizeof(cNpcName));
	switch (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID)
	{
	case 0: return; break;
	case 49: strcpy(cNpcName, "Hellclaw");break;
	case 50: strcpy(cNpcName, "Tigerworm");break;	
	case 66: strcpy(cNpcName, "Wyvern");break;	
	case 73: strcpy(cNpcName, "Fire-Wyvern");break;	
	case 81: strcpy(cNpcName, "Abaddon");break;	
	default: strcpy(cNpcName, "Demon");break;	
	}

	CNpc * boss = CreateNpc(cNpcName, MapIndex, 0, MOVETYPE_RANDOMAREA, NULL, NULL, (Side)-1, 
		cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect,	NULL, false, false, false, true);

	if(!boss) 
		return;

	wsprintf(cTxt, "%s has spawned in %s", cNpcName, m_pMapList[MapIndex]->m_cName);
	PutLogList(cTxt);	

	_bCrusadeLog(CRUSADELOG_APOCALYPSE, NULL, 0, cTxt);	

	// Show Spawns on minimap, and tell everybody on Apocalypse server.				

	int iShortCutIndex = 0;
	while(int i = m_iClientShortCut[iShortCutIndex++])
	{
		CClient * player = m_pClientList[i];
		if(player->m_bIsInitComplete)
		{	
			if(strcmp(m_pMapList[MapIndex]->m_cName, m_pMapList[player->m_cMapIndex]->m_cName) == 0)
			{	
				player->Notify(NULL, NOTIFY_MONSTEREVENT_POSITION, boss->m_sX, boss->m_sY, m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID, NULL);
			}

			// Tell everybody on this server that Abaddon has appeared
			if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == NPC_ABADDON) 
			{	
				char cInfoString[100];
				ZeroMemory(cInfoString,  sizeof(cInfoString));
				wsprintf(cInfoString, "Abbadon has appeared ...");
				player->Notify(NULL, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
			}	
		}
	}

	if (m_pMapList[MapIndex]->m_iApocalypseBossMobNpcID == NPC_ABADDON)
	{	
		// Abaddon should die by himself		
		//uint32 dwTime = timeGetTime();
		//dwTime += 5 _m;
		//RegisterDelayEvent(DELAYEVENTTYPE_KILL_ABADDON, 0, dwTime, i5, OWNERTYPE_NPC, MapIndex, 0, 0, 0, 0, 0);
	}
}

void CGame::GenerateSlime(int MapIndex)
{	
	if (m_pMapList[MapIndex]->m_iTotalActiveObject != 0) return;
	if (!m_bIsApocalypseMode) return;

	char cNpcWaypoint[11];	
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

	CreateNpc("Slime", MapIndex, 0, MOVETYPE_RANDOMAREA, NULL, NULL,
			NEUTRAL, cNpcWaypoint, &m_pMapList[MapIndex]->m_sApocalypseBossMobRect, NULL);
}

void CGame::SendThunder(int iClient, short sX, short sY, short sV3, short sV4)
{	char  * cp, cData[100];
	uint32 * dwp;
	uint16 * wp;
	short * sp;
	int iRet;
	ZeroMemory(cData, sizeof(cData));	
	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_EVENT_COMMON;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = COMMONTYPE_MAGIC;	
	cp = (char *)(cData + INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sX;
	cp += 2;
	sp  = (short *)cp;
	*sp = sY;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;
	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;
	iRet = m_pClientList[iClient]->m_pXSock->iSendMsg(cData, 18);
}
void CGame::DoAbaddonThunderDamageHandler(char cMapIndex)
{	
	int iResult;
	int i;
	if (!m_bIsApocalypseMode) return;

	uint32 dwTime = timeGetTime();
	for (i = 0; i < MAXCLIENTS; i++) 
	{	if (m_pClientList[i] != NULL) 
		{	//if (m_pClientList[i]->m_iAdminUserLevel > 0) return;
			if ((memcmp(m_pClientList[i]->m_cMapName, "abaddon", 7) == 0) 
				|| (m_pClientList[i]->m_cMapIndex == cMapIndex))
			{	switch (dice(1,4)) {
				case 1:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 203, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX-dice(1,7), m_pClientList[i]->m_sY+dice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 2:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 202, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+dice(1,7), m_pClientList[i]->m_sY-dice(1,5), 161, m_pClientList[i]->m_sType);
					break;
				case 3:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 201, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+dice(1,7), m_pClientList[i]->m_sY+5-dice(1,9), 161, m_pClientList[i]->m_sType);
					break;
				case 4:
					SendThunder(i, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 200, m_pClientList[i]->m_sType);
					SendThunder(i, m_pClientList[i]->m_sX+5-dice(1,9), m_pClientList[i]->m_sY+7-dice(1,4), 161, m_pClientList[i]->m_sType);
					break;
				}				
				if (m_pClientList[i]->IsInvincible()) return;	
				iResult = dice(1,20) + 100;
				 if (  (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == 2)
					|| (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_PROTECT] == 5)) 
				{   iResult /= 2;
				}
				// Not for v3.51: SendNotifyMsg(NULL, i, NOTIFY_0BE5, NULL, NULL, NULL, NULL);
				m_pClientList[i]->m_iHP -= iResult;
				if (m_pClientList[i]->m_iHP <= 0) 
				{	m_pClientList[i]->KilledHandler(i, NULL, iResult);
				}else if (iResult > 0) 
				{	SendNotifyMsg(NULL, i, NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendEventToNearClient_TypeA(i, OWNERTYPE_PLAYER, MSGID_MOTION_DAMAGE, iResult, NULL, NULL);
					if (m_pClientList[i]->m_bSkillUsingStatus[19] != true) 
					{	m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}
					if (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_HOLDOBJECT] == 1)	// Hold person
					{   SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, 1, NULL, NULL);
						RemoveFromDelayEventList(i, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
					}else if (m_pClientList[i]->m_cMagicEffectStatus[MAGICTYPE_HOLDOBJECT] != 0)	// Para entangle
					{   SendNotifyMsg(NULL, i, NOTIFY_MAGICEFFECTOFF, MAGICTYPE_HOLDOBJECT, 2, NULL, NULL);
						RemoveFromDelayEventList(i, OWNERTYPE_PLAYER, MAGICTYPE_HOLDOBJECT);						
						m_pClientList[i]->m_cMagicEffectStatus[ MAGICTYPE_HOLDOBJECT ] = NULL;
	}	}	}	}	}
}






void CGame::_CreateHeldenianGUID(uint32 m_dwHeldenianGUID, int m_iHeldenianType1Winner, int m_iHeldenianType2Winner, int m_iHeldenianType) const
{	
	char * cp, cTxt[120], cFn[256], cTemp[1024];
	FILE * pFile;

	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));

	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"HeldenianGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) 
	{
		wsprintf(cTxt, "(!) Cannot create Heldenian-GUID(%d) file", m_dwHeldenianGUID);
		PutLogList(cTxt);
	} else {
		ZeroMemory(cTemp, sizeof(cTemp));
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Heldenian-GUID = %d\n", m_dwHeldenianGUID);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Heldenian-Type1-Winner = %d\n", m_iHeldenianType1Winner);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Heldenian-Type2-Winner = %d\n", m_iHeldenianType2Winner);
		strcat(cTemp, cTxt);
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "Heldenian-LastType = %d\n", m_iHeldenianType);
		strcat(cTemp, cTxt);
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		wsprintf(cTxt, "(O) HeldenianGUID(%d) file created", m_dwHeldenianGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);

	switch (m_iHeldenianType1Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian Type 1.");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian Type 1.");
		break;		
	default: PutLogList("(!!) Nobody Owned Heldenian Type 1.");
		break;
	} 

	switch (m_iHeldenianType2Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian Type 2.");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian Type 2.");
		break;		
	default: PutLogList("(!!) Nobody Owned Heldenian Type 2.");
		break;
	} 

	switch (m_iHeldenianType) 
	{
	case 1:	PutLogList("(!!) Heldenian Type 1.");
		break;
	case 2: PutLogList("(!!) Heldenian Type 2.");
		break;	
	} 
}

bool CGame::bReadHeldenianGUIDFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	uint32  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120];
	char seps[] = "= \t\n";
	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) 
	{
		PutLogList("(!) Cannot open Heldenian-GUID file.");
		return false;
	} else {
		PutLogList("(!) Reading Heldenian-GUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		StrTok pStrTok(new CStrTok(cp, seps));
		token = pStrTok->pGet();
		while( token != NULL )   
		{
			if (cReadMode != 0) 
			{
				switch (cReadMode) 
				{
				case 1:
					m_dwHeldenianGUID = atoi(token);
					wsprintf(cTxt, "Heldenian-GUID = %d", m_dwHeldenianGUID);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 2:
					m_iHeldenianType1Winner = atoi(token);
					wsprintf(cTxt, "Heldenian-Type1-Winner = %d", m_iHeldenianType1Winner);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 3:
					m_iHeldenianType2Winner = atoi(token);
					wsprintf(cTxt, "Heldenian-Type2-Winner = %d", m_iHeldenianType2Winner);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 4:
					m_iLastHeldenianType = atoi(token);
					wsprintf(cTxt, "Heldenian-LastType = %d", m_iLastHeldenianType);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			} else {
				if (memcmp(token, "Heldenian-GUID", 14) == 0) cReadMode = 1;
				if (memcmp(token, "Heldenian-Type1-Winner", 22) == 0) cReadMode = 2;
				if (memcmp(token, "Heldenian-Type2-Winner", 22) == 0) cReadMode = 3;
				if (memcmp(token, "Heldenian-LastType", 16) == 0) cReadMode = 4;
			}
			token = pStrTok->pGet();
		}
		delete[] cp;
	}
	if (pFile != NULL) fclose(pFile);
	switch (m_iHeldenianType1Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian In Last Type (1).");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian In Last Type (1).");
		break;		
	default: PutLogList("(!!) Nobody Owned Heldenian In Last Type (1).");
		break;
	} 
	switch (m_iHeldenianType2Winner) 
	{
	case 1:	PutLogList("(!!) Aresden Owned Heldenian In Last Type (2).");
		break;
	case 2: PutLogList("(!!) Elvine Owned Heldenian In Last Type (2).");
		break;		
	default:PutLogList("(!!) Nobody Owned Heldenian In Last Type (2).");
		break;
	} 
	switch (m_iLastHeldenianType) 
	{
	case 1:	PutLogList("(!!) Last Heldenian Type (1).");
		break;
	case 2: PutLogList("(!!) Last Heldenian Type (2).");
		break;	
	default: PutLogList("(!!) Last Heldenian Type (No Last Type).");
		break;
	}
	return true;
}
void CGame::StartHeldenianMode(int iClientH)
{
	char cData[120], * cp, cBuff[256], * token, seps[] = "= \t\n", cTxt[120], cString[120];
	uint32 *dwp;
	uint16 * wp;
	class CStrTok * pStrTok;
	int i, x, n;
	char cTmp[21], cNpcWaypointIndex[10], cOwnerType;
	Side side;
	short sOwnerH;
	bool bRet;
	int dX, dY;
	int tempwin;

	if (m_bHeldenianMode) return;
	if (m_bIsApocalypseMode) return;
	if (m_bIsCrusadeMode) return;
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");	
	m_iHeldenianType = (m_iLastHeldenianType % 2) +1;

	if (iClientH != -1) 
	{
		CClient * player = m_pClientList[iClientH];
		wsprintf(cTxt, "Admin Order(%s): /beginheld \tAdminIP(%s)", player->m_cCharName, player->m_cIPaddress);
		wsprintf(cString, "Heldenian starting in progress.");
	} else { 
		wsprintf(cTxt, "Local command: beginHeldenian");
	}	
	PutLogList(cTxt);	
	if (iClientH != -1) 
	{	
		SendNotifyMsg(NULL, iClientH, NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cString);
	}
	for (i = 0; i < MAXCLIENTS; i++) 
	{	
		CClient * player = m_pClientList[i];
		if ((player != NULL) && (player->m_bIsInitComplete == true))
		{	
			player->m_iSpecialEventID = 1;
			SendNotifyMsg(NULL, i, NOTIFY_HELDENIANSTART,  NULL , NULL, NULL, NULL); // You can now, fight on the battle field
			player->m_iWarContribution   = 0;
			player->m_iConstructionPoint = 10000 + (player->m_iCharisma * 100);
			if (player->m_iConstructionPoint > MAXHELDENIANSUMMONPOINT) player->m_iConstructionPoint = MAXHELDENIANSUMMONPOINT;
			SendNotifyMsg(NULL, i, NOTIFY_CONSTRUCTIONPOINT, player->m_iConstructionPoint, player->m_iWarContribution, 0, NULL); //0: Tell player of acquired points
		}	
	}

	CMap * map;
	for (x = 0; x < MAXMAPS; x++) 
	{	
		map = m_pMapList[x];
		if (!map) break;
		if (map->m_bIsHeldenianMap) 
		{	
			DeleteOccupyFlags(x);
			for (i = 0; i < MAXCLIENTS; i++) 
			{	
				CClient * player = m_pClientList[i];
				if (player && player->m_bIsInitComplete && player->m_cMapIndex == x && player->m_iAdminUserLevel == 0)
				{	
					RequestTeleportHandler(i, 1, NULL, -1, -1);
				} 
			} 
			for (n = 0; n < MAXNPCS; n++) 
			{	
				if ( (m_pNpcList[n] != NULL) && (m_pNpcList[n]->m_bIsKilled == false) && (m_pNpcList[n]->m_cMapIndex == x))
				{	
					NpcKilledHandler(NULL, NULL, n, NULL);
				}	
			}	
			if (m_iHeldenianType == 1) 
			{
				if (strcmp(map->m_cName, "BtField") == 0) 
				{
					for (i = 0; i < MAX_HELDENIANTOWER; i++) 
					{	
						if (map->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (map->m_stHeldenianTower[i].sTypeID > MAXNPCTYPES) break;

						dX = map->m_stHeldenianTower[i].dX;
						dY = map->m_stHeldenianTower[i].dY;
						side = (Side)map->m_stHeldenianTower[i].cSide;
						ZeroMemory(cTmp, sizeof(cTmp));
						if ((map->m_stHeldenianTower[i].sTypeID == 87)&& side == ARESDEN) strcpy(cTmp, "CT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 87)&& side == ELVINE) strcpy(cTmp, "CT-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 89)&& side == ARESDEN) strcpy(cTmp, "AGC-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 89)&& side == ELVINE) strcpy(cTmp, "AGC-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 36)&& side == ARESDEN) strcpy(cTmp, "AGT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 36)&& side == ELVINE) strcpy(cTmp, "AGT-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 37)&& side == ARESDEN) strcpy(cTmp, "CGT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 37)&& side == ELVINE) strcpy(cTmp, "CGT-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 39)&& side == ARESDEN) strcpy(cTmp, "DT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 39)&& side == ELVINE) strcpy(cTmp, "DT-Elvine"); 

						CNpc * tower = CreateNpc(cTmp, x, 0, MOVETYPE_RANDOM, &dX, &dY, side, cNpcWaypointIndex, NULL, NULL, false, false, false, true);

						if(tower) 
						{	
							tower->m_iBuildCount = 0;								
							tower->m_sAppr2 = 0;
							tower->m_side = side;

							if(side == ARESDEN)
								m_iHeldenianAresdenLeftTower += 1;
							else if(side == ELVINE) m_iHeldenianElvineLeftTower += 1;
						}	
					}

					wsprintf(cTxt,"Towers Created on (%s) For Event Type %d HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", map->m_cName, m_iHeldenianType, m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogList(cTxt);
				}
			}
			else if (m_iHeldenianType == 2) 
			{	
				if (strcmp(map->m_cName, "GodH") == 0) 
				{	
					SetHeldenianFlag(x, map->m_sHeldenianWinningZoneX, map->m_sHeldenianWinningZoneY, m_iHeldenianType1Winner, 616, -1, 2); 
				}
				// Possibilty to set towers, detectors etc....
				if (strcmp(map->m_cName, "HRampart") == 0) 
				{	
					for (i = 0; i < MAX_HELDENIANTOWER; i++) 
					{	
						if (map->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (map->m_stHeldenianTower[i].sTypeID > MAXNPCTYPES) break;

						dX = map->m_stHeldenianTower[i].dX;
						dY = map->m_stHeldenianTower[i].dY;
						side = (Side)m_iHeldenianType2Winner;
						ZeroMemory(cTmp, sizeof(cTmp));
						if ((map->m_stHeldenianTower[i].sTypeID == 87)&& side == ARESDEN) strcpy(cTmp, "CT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 87)&& side == ELVINE) strcpy(cTmp, "CT-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 89)&& side == ARESDEN) strcpy(cTmp, "AGC-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 89)&& side == ELVINE) strcpy(cTmp, "AGC-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 36)&& side == ARESDEN) strcpy(cTmp, "AGT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 36)&& side == ELVINE) strcpy(cTmp, "AGT-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 37)&& side == ARESDEN) strcpy(cTmp, "CGT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 37)&& side == ELVINE) strcpy(cTmp, "CGT-Elvine"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 39)&& side == ARESDEN) strcpy(cTmp, "DT-Aresden"); 
						if ((map->m_stHeldenianTower[i].sTypeID == 39)&& side == ELVINE) strcpy(cTmp, "DT-Elvine"); 

						CNpc * tower = CreateNpc(cTmp, x, 0, MOVETYPE_RANDOM, &dX, &dY, side, cNpcWaypointIndex, NULL, NULL, false, false, false, true);
						if(tower) 
						{
							tower->m_iBuildCount = 0;							
							tower->m_sAppr2 = 0;
							tower->m_side = side;
						}	
					}	
				}

				if (strcmp(map->m_cName, "HRampart") == 0) 
				{	
					for (i = 0; i < MAXHELDENIANDOOR; i++) 
					{	
						if (map->m_stHeldenianGateDoor[i].dX < 1)  break;

						dX = map->m_stHeldenianGateDoor[i].dX;
						dY = map->m_stHeldenianGateDoor[i].dY;
						ZeroMemory(cTmp, sizeof(cTmp));
						if (m_iHeldenianType2Winner == 1) strcpy(cTmp, "gate-a"); 
						else							 strcpy(cTmp, "gate-e"); 
						side = (Side)m_iHeldenianType2Winner;

						CNpc * tower = CreateNpc(cTmp, x, 0, MOVETYPE_RANDOM, &dX, &dY, side, 
							cNpcWaypointIndex, NULL, NULL, false, false, false, true);

						if(tower) 
						{
							tower->m_iBuildCount = 0;
							tower->m_side = side;
							tower->m_cDir = map->m_stHeldenianGateDoor[i].cDir;
							wsprintf(cTxt,"(_) Gate installed at %d,%d", dX, dY);
							PutLogList(cTxt);
						}	
					}	
				}	
			}	
		}	
	}
	if (m_iHeldenianType == 1) tempwin = m_iHeldenianType1Winner;
	else tempwin = m_iHeldenianType2Winner;
	m_bHeldenianMode = true;
	UpdateHeldenianStatus();
	wsprintf(cTxt,"(_) Heldenian mode ON. (type %d, last winner:%d)", m_iHeldenianType, tempwin);
	PutLogList(cTxt);
}

void CGame::UpdateHeldenianStatus() const
{	
	int shortCutIndex = 0;
	while(int index = m_iClientShortCut[shortCutIndex++])
	{
		SendNotifyMsg(NULL, index, NOTIFY_HELDENIANCOUNT, 
			m_iHeldenianAresdenLeftTower, m_iHeldenianAresdenFlags, m_iHeldenianAresdenKill, NULL, 
			m_iHeldenianAresdenDead, m_iHeldenianElvineLeftTower, m_iHeldenianElvineFlags, m_iHeldenianElvineKill, m_iHeldenianElvineDead);
	}
}

bool CGame::SetHeldenianFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, int code)
{ 
	int ix, iy;
	char cTxt[120];
	int   iDynamicObjectIndex, iIndex;
	class CTile * pTile;
	uint32 dwTime = timeGetTime();

	CClient * player = m_pClientList[iClientH];
	CMap * map = m_pMapList[cMapIndex];

	if (map == NULL)									return false;
	pTile = (class CTile *)(map->m_pTile + dX + dY*map->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != NULL)								return false;
	if (pTile->m_bIsMoveAllowed == false)								return false;
	if (map->m_iTotalOccupyFlags >= MAXOCCUPYFLAG)	return false;

	if (code == 1) // Flag set by a character
	{	 
		if ((m_bHeldenianMode) && (m_iHeldenianType == 1) && (map->m_bIsHeldenianMap == true) && (player->m_iGuildRank == GUILDRANK_MASTER)) 
		{	
			if (player == NULL) return false;
			switch (player->m_side) 
			{
			case ARESDEN:// Aresden:
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);
				m_iHeldenianAresdenFlags++;
				break;
			case ELVINE:// Elvine	
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	
				m_iHeldenianElvineFlags++;
				break;
			default:// Others
				return false;
				break;
			}
			iIndex = map->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
			if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
			for (ix = dX-20; ix <= dX+35; ix++) 
				for (iy = dY-20; iy <= dY+25; iy++) 
				{	
					if ((ix == dX) && (iy == dY)) 
					{ 
					} else {	
						pTile = (class CTile *)(map->m_pTile + ix + iy*map->m_sSizeY);			
						if (pTile->m_iOccupyFlagIndex == NULL) 
						{	
							switch (player->m_side) 
							{
							case ARESDEN:// Aresden 
								break;
							case ELVINE: // Elvine	
								break;
							default:
								break;
							}	
						}	
					}	
				}	
				wsprintf(cTxt, "Player(%s) Placed Flag On (%s) Cords(%d/%d) Type (%d) (Ares Flag ++ %d Elvine Flag ++ %d", player->m_cCharName, player->m_cMapName, dX, dY, m_iHeldenianType, m_iHeldenianAresdenFlags, m_iHeldenianElvineFlags);
				PutLogList(cTxt);
		}
		else if ((m_bHeldenianMode) && (m_iHeldenianType == 2) && (cMapIndex == m_iGodHMapIndex) && (player->m_iGuildRank == GUILDRANK_MASTER) && (player->m_side != m_iHeldenianType1Winner)) 
		{
			if (player == NULL) return false;
			if ((abs(map->m_sHeldenianWinningZoneX - dX) > 1) || (abs(map->m_sHeldenianWinningZoneY - dY) > 1)) return false;
			switch (player->m_side) 
			{
			case ARESDEN:	// Aresden:
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			case ELVINE: // Elvine	
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			default: // Others
				return false;
				break;
			}
			iIndex = map->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
			if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
			for (ix = dX-20; ix <= dX+35; ix++) 
				for (iy = dY-20; iy <= dY+25; iy++) 
				{	
					if ((ix == dX) && (iy == dY)) 
					{
					} else {	
						pTile = (class CTile *)(map->m_pTile + ix + iy*map->m_sSizeY);			
						if (pTile->m_iOccupyFlagIndex == NULL) 
						{	
							switch (player->m_side) 
							{
							case ARESDEN:	// Aresden 
								break;
							case ELVINE: // Elvine	
								break;
							default:
								break;
							}	
						}	
					}	
				}	
				wsprintf(cTxt, "Player(%s) Placed Flag %s Cords(%d/%d)", player->m_cCharName, player->m_cMapName, dX, dY);
				PutLogList(cTxt);	
				HeldenianEndWarNow(m_iHeldenianType, (Side)player->m_side);
				player->m_iConstructionPoint += (1000 * iEKNum);
				player->m_iWarContribution   += (100 * iEKNum);
				if (player->m_iConstructionPoint > MAXHELDENIANSUMMONPOINT) player->m_iConstructionPoint = MAXHELDENIANSUMMONPOINT;
		}
	}	
	else if (code == 2) 
	{  
		if ((m_bHeldenianMode) && (m_iHeldenianType == 2) && (cMapIndex == m_iGodHMapIndex)) 
		{
			switch (m_iHeldenianType1Winner) 
			{
			case ARESDEN:// Aresden:
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ARESDENFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			case ELVINE:// Elvine	
				iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DYNAMICOBJECT_ELVINEFLAG, cMapIndex, dX, dY, NULL, NULL);	
				break;
			default:// Others
				return false;
				break;
			}
			if (iDynamicObjectIndex == NULL) return false;
			iIndex = map->iRegisterOccupyFlag(dX, dY, iSide, 615, iDynamicObjectIndex);
			if (iIndex == -1) PutLogList("Error registering MasterOccupyFlag.");	
			for (ix = dX-20; ix <= dX+35; ix++) 
				for (iy = dY-20; iy <= dY+25; iy++) 
				{	
					if ((ix == dX) && (iy == dY)) 
					{
					} else {	
						pTile = (class CTile *)(map->m_pTile + ix + iy*map->m_sSizeY);			
						if (pTile->m_iOccupyFlagIndex == NULL) 
						{	
							switch (m_iHeldenianType1Winner) 
							{
							case ARESDEN:	// Aresden 
								break;
							case ELVINE: // Elvine	
								break;
							default:
								break;
							}	
						}	
					}	
				}	
				wsprintf(cTxt, "Server Set Defending Flag On(%s) Cords(%d/%d) Type(%d)", player->m_cMapName, dX, dY, m_iHeldenianType);
				PutLogList(cTxt);	
		}
	}
	UpdateHeldenianStatus();
	return true;
}

void CGame::HeldenianEndWarNow(int m_iHeldenianType, Side side)
{	
	char cTxt[120];
	if (!m_bHeldenianMode) return;
	m_iHeldenianAresdenLeftTower	= 0;
	m_iHeldenianElvineLeftTower		= 0;
	m_iHeldenianAresdenFlags		= 0;
	m_iHeldenianElvineFlags			= 0;
	m_iHeldenianAresdenDead			= 0;
	m_iHeldenianElvineDead			= 0;
	m_iHeldenianAresdenKill			= 0;
	m_iHeldenianElvineKill			= 0;

	if (m_iHeldenianType == 1) 
	{	
		if (m_iBtFieldMapIndex == -1) return;

		if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) 
			m_iHeldenianType1Winner = 1;
		else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) 
			m_iHeldenianType1Winner = 2;

		switch(m_iHeldenianType1Winner) 
		{
		case 1: 
			wsprintf(cTxt, "Heldenian Type 1 Finished. Aresden won.");
			break;
		case 2: 
			wsprintf(cTxt, "Heldenian Type 1 Finished. Elvine won.");
			break;
		default: 
			wsprintf(cTxt, "Heldenian Type 1 Finished. Draw.");
			break;
		}
	}
	if (m_iHeldenianType == 2) 
	{ 
		switch(side) 
		{
		case ARESDEN: 
			wsprintf(cTxt, "Heldenian Type 2 Finished. Aresden won.");
			m_iHeldenianType2Winner = 1;
			break;
		case ELVINE: 
			wsprintf(cTxt, "Heldenian Type 2 Finished. Elvine won.");
			m_iHeldenianType2Winner = 2;
			break;
		default: 
			wsprintf(cTxt, "Heldenian Type 2 Finished. Draw.");
			break;
		}
	}

	CMap * map;
	for (int m = 0; m < MAXMAPS; m++) 
	{	
		map = m_pMapList[m];

		if (!map) break;
		if (map->m_bIsHeldenianMap) 
		{	
			DeleteOccupyFlags(m);
			for (int n = 0; n < MAXNPCS; n++) 
			{	
				if ( (m_pNpcList[n] != NULL) && (m_pNpcList[n]->m_bIsKilled == false) && (m_pNpcList[n]->m_cMapIndex == m))
				{	
					NpcKilledHandler(NULL, NULL, n, NULL);
				}	
			}	
			for (int j = 0; j < MAXCLIENTS; j++)
			{	
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == true) && (m_pClientList[j]->m_cMapIndex == m))
				{	
					if (m_iHeldenianType == 1) 
					{
						SendNotifyMsg(NULL, j, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType1Winner, NULL, NULL, NULL); 
					} else {
						SendNotifyMsg(NULL, j, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType2Winner, NULL, NULL, NULL); 
					}
					SendNotifyMsg(NULL, j, NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
					m_pClientList[j]->m_iSpecialEventID = 2;
					if ((m_pClientList[j]->m_side != side) && (m_pClientList[j]->m_iAdminUserLevel == 0))
					{	
						SendNotifyMsg(NULL, j, NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						m_pClientList[j]->m_bIsWarLocation = true;
						m_pClientList[j]->m_iTimeLeft_ForceRecall = 300;
						RequestTeleportHandler(j, 0);
					}	
				}	
			}
		}
	}
	PutLogList(cTxt);
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_iHeldenianType1Winner, m_iHeldenianType2Winner, m_iHeldenianType);
	m_bHeldenianMode		 = false;
	UpdateHeldenianStatus();
	PutLogList("(!!) Heldenian Mode OFF.");

}
void CGame::HeldenianPlayerKill(CClient * killer, CClient * victim)
{	
	if(victim->m_side == 1) 
	{
		m_iHeldenianAresdenDead++;
		m_iHeldenianElvineKill++;
	} else {
		m_iHeldenianElvineDead++;
		m_iHeldenianAresdenKill++;
	}
	UpdateHeldenianStatus();
}
void CGame::CheckHeldenianResultCalculation(int iClientH) const
{	
	char cTxt[120];
	CClient * player = m_pClientList[iClientH];
	if (player == NULL) return;
	if (player->m_iSpecialEventID == 0) return; 
	if ((!m_bHeldenianMode) && (player->m_iSpecialEventID > 0) && (player->m_iWarContribution > 0))
	{	
		if (player->m_iWarContribution > 100*1000) player->m_iWarContribution = 100*1000;		
		SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, 0, 0, 1, NULL); 
		if (player->m_iSpecialEventID > 0) 
		{	
			if (m_iHeldenianType == 1) 
			{
				SendNotifyMsg(NULL, iClientH, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType1Winner, NULL, NULL, NULL); 
			} else {
				SendNotifyMsg(NULL, iClientH, NOTIFY_HELDENIANVICTORY,  m_iHeldenianType2Winner, NULL, NULL, NULL); 
			}
			if (player->m_iLevel < MAXLEVEL)
			{	
				player->m_iWarContribution += (200 - player->m_iLevel)*100;
			}else player->m_iWarContribution += 2000; 
			if (m_iHeldenianType == 1) 
			{
				if (m_iHeldenianType1Winner == player->m_side) 
				{	
					player->m_iExpStock += player->m_iWarContribution*50;
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*50);	
					PutLogList(cTxt);

				}else if (m_iHeldenianType1Winner != player->m_side)
				{	
					player->m_iExpStock += player->m_iWarContribution*25;							
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*25);	
					PutLogList(cTxt);
				}	
			} else {
				if (m_iHeldenianType2Winner == player->m_side) 
				{	
					player->m_iExpStock += player->m_iWarContribution*50;
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*50);	
					PutLogList(cTxt);

				}else if (m_iHeldenianType2Winner != player->m_side)
				{	
					player->m_iExpStock += player->m_iWarContribution*25;							
					wsprintf(cTxt, "Heldenian Exp:     PC(%s) Got %d xp.", player->m_cCharName, player->m_iWarContribution*25);	
					PutLogList(cTxt);
				}	
			}
		}		
		player->m_iSpecialEventID    = 0;
		player->m_iWarContribution   = 0;
		player->m_iConstructionPoint = 0;
	}
}

void CGame::RequestHeldenianScroll(int iClientH, char * pData, uint32 dwMsgSize)
{
	char  *cp, cData[256], cTmpName[21];
	int   iItemNbe;
	class CItem * pItem;
	int   iRet, iEraseReq, iNeededPts;
	short * sp;
	uint16  * wp;
	uint32 * dwp;
	char cTxt[120];
	CClient * player = m_pClientList[iClientH];
	if (player == NULL)					 return;
	if (player->m_bIsInitComplete == false) return;
	if (!m_bHeldenianMode)						 return;
	if (player->m_iGuildRank != GUILDRANK_MASTER)			 return;

	if (_iGetItemSpaceLeft(iClientH) == 0) 
	{	
		SendItemNotifyMsg(iClientH, NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, true);
		return;
	}
	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	cp += 20;
	wp = (uint16 *)cp;
	iItemNbe = (int) *wp; 
	cp += 2;
	wsprintf(cTxt, "PC(%s) obtained a summon scroll (%d).   %s(%d %d)", player->m_cCharName, iItemNbe, player->m_cMapName, player->m_sX, player->m_sY);	
	PutLogList(cTxt);	
	switch (iItemNbe)
	{
	case 875: // Sorceress
		iNeededPts = 2000;
		break;
	case 876: // Ancient Temple Knight
		iNeededPts = 3000;
		break;
	case 877: // Elf Master
		iNeededPts = 1500;
		break;
	case 878: // DarkShadow Knight
		iNeededPts = 3000;
		break;
	case 879: // Heavy Battle Tank
		iNeededPts = 4000;
		break;
	case 880: // Barbarian
		iNeededPts = 3000;
		break;
	default:
		iNeededPts = 999999;
		PutLogList("Gail asked to create a wrong item!");	
		break;
	}
	if (player->m_iConstructionPoint < iNeededPts)
	{	// Unable to get item...
	}else
	{	// Get the scroll
		player->m_iConstructionPoint -= iNeededPts;
		SendNotifyMsg(NULL, iClientH, NOTIFY_CONSTRUCTIONPOINT, player->m_iConstructionPoint, player->m_iWarContribution, 0, NULL); // 0:tell client
	}
	pItem = NULL;
	pItem = new class CItem;
	if (pItem == NULL) return;
	if ((pItem->InitItemAttr(iItemNbe) == true)) 
	{	
		pItem->m_sTouchEffectType = ITET_UNIQUE_OWNER;
		pItem->m_sTouchEffectValue1 = player->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = player->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = player->m_sCharIDnum3;
		memcpy(&pItem->m_sItemSpecEffectValue1, &m_dwHeldenianGUID, 4);
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == true) 
		{	
			SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, pItem, NULL, true);
			if (iEraseReq == 1) delete pItem;				
			iRet = player->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		break;
			}
		} else {	
			m_pMapList[ player->m_cMapIndex ]->bSetItem(player->m_sX, player->m_sY, pItem);			
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, COMMONTYPE_ITEMDROP, player->m_cMapIndex, player->m_sX, player->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); 		
			dwp  = (uint32 *)(cData + INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
			*wp  = NOTIFY_CANNOTCARRYMOREITEM;				
			iRet = player->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		break;
			}	
		}
	} else {	
		delete pItem;
		pItem = NULL;
	}
}
void CGame::Apocalypse_MonsterCount(int iClientH)
{
	CClient * player = m_pClientList[iClientH];
	CMap * map = m_pMapList[player->m_cMapIndex];
	if (player == NULL || !player->IsGM()) return;

	CNpc * npc = NULL;
	for(int i = 0; i < MAXNPCS; i++)
	{
		if(m_pNpcList[i] && m_pNpcList[i]->m_cMapIndex == player->m_cMapIndex && !m_pNpcList[i]->IsDead())
		{
			npc = m_pNpcList[i];
			break;
		}
	}

	player->Notify(NULL, NOTIFY_MONSTERCOUNT, map->m_iTotalActiveObject, (uint32)npc, NULL, NULL);
}

char CGame::CheckHeroItemEquipped(int iClientH)
{
	short sLeggings, sHauberk, sArmor, sHelm;

	if (m_pClientList[iClientH] == NULL) return 0;

	sHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_HEAD];
	sArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_BODY];
	sHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_ARMS];
	sLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[EQUIPPOS_PANTS];

	if ((sHelm < 0) || (sLeggings < 0) || (sArmor < 0) || (sHauberk < 0)) return 0; 

	if(m_pClientList[iClientH]->m_pItemList[sHelm] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sLeggings] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sArmor] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHauberk] == NULL) return 0;

	sHelm = m_pClientList[iClientH]->m_pItemList[sHelm]->m_sIDnum;
	sArmor = m_pClientList[iClientH]->m_pItemList[sArmor]->m_sIDnum;
	sHauberk = m_pClientList[iClientH]->m_pItemList[sHauberk]->m_sIDnum;
	sLeggings = m_pClientList[iClientH]->m_pItemList[sLeggings]->m_sIDnum;

	if ((sHelm == ITEM_EHEROHELM_M) &&
		(sArmor == ITEM_EHEROARMOR_M) &&
		(sHauberk == ITEM_EHEROHAUBERK_M) &&
		(sLeggings == ITEM_EHEROLEGGINGS_M)) return 1; //Elv male war

	if ((sHelm == ITEM_EHEROCAP_M) &&
		(sArmor == ITEM_EHEROROBE_M) &&
		(sHauberk == ITEM_EHEROHAUBERK_M) &&
		(sLeggings == ITEM_EHEROLEGGINGS_M)) return 2; //Elv male mage

	if ((sHelm == ITEM_AHEROHELM_M) &&
		(sArmor == ITEM_AHEROARMOR_M) &&
		(sHauberk == ITEM_AHEROHAUBERK_M) &&
		(sLeggings == ITEM_AHEROLEGGINGS_M)) return 1; //Ares male war

	if ((sHelm == ITEM_AHEROCAP_M) &&
		(sArmor == ITEM_AHEROROBE_M) &&
		(sHauberk == ITEM_AHEROHAUBERK_M) &&
		(sLeggings == ITEM_AHEROLEGGINGS_M)) return 2; //Ares male mage

	if ((sHelm == ITEM_EHEROHELM_W) &&
		(sArmor == ITEM_EHEROARMOR_W) &&
		(sHauberk == ITEM_EHEROHAUBERK_W) &&
		(sLeggings == ITEM_EHEROLEGGINGS_W)) return 1; //Elv female war

	if ((sHelm == ITEM_EHEROCAP_W) &&
		(sArmor == ITEM_EHEROROBE_W) &&
		(sHauberk == ITEM_EHEROHAUBERK_W) &&
		(sLeggings == ITEM_EHEROLEGGINGS_W)) return 2; //Elv female mage

	if ((sHelm == ITEM_AHEROHELM_W) &&
		(sArmor == ITEM_AHEROARMOR_W) &&
		(sHauberk == ITEM_AHEROHAUBERK_W) &&
		(sLeggings == ITEM_AHEROLEGGINGS_W)) return 1; //Ares female war

	if ((sHelm == ITEM_AHEROCAP_W) &&
		(sArmor == ITEM_AHEROROBE_W) &&
		(sHauberk == ITEM_AHEROHAUBERK_W) &&
		(sLeggings == ITEM_AHEROLEGGINGS_W)) return 2; //Ares female mage

	return 0;
}

void CGame::ReqRepairAll(int iClientH)
{
	uint32 price = 0;
	char itemCategory;
	CItem * item;
	double d1, d2;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	
	for (int i = 0; i < MAXITEMS; i++) {
		item = m_pClientList[iClientH]->m_pItemList[i];
		if (!item) continue;

		itemCategory = item->m_cCategory;

		if(itemCategory < 1 || itemCategory > 50 || (itemCategory > 13 && itemCategory < 43)) continue; 

		if(item->m_wMaxLifeSpan == 0 || item->m_wCurLifeSpan == item->m_wMaxLifeSpan) continue;

		if (item->m_wCurLifeSpan == 0) {
			price += item->m_wPrice / 2;
		}
		else {
			d1 = item->m_wMaxLifeSpan - item->m_wCurLifeSpan;
			d2 = (d1 / item->m_wMaxLifeSpan) * 0.5f;
			price += d2 * item->m_wPrice;
		}
	}

	SendNotifyMsg(NULL, iClientH, NOTIFY_REPAIRALLPRICE, price);
}

void CGame::ReqRepairAllConfirmHandler(int iClientH, int quotedPrice)
{
	uint32 goldCount, startGoldCount, price, i;
	char itemCategory;
	CItem * item;
	double d1, d2;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	goldCount = startGoldCount = dwGetItemCount(iClientH, "Gold");
	if (goldCount == 0) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_NOTENOUGHGOLD);
		return;
	}

	price = 0;
	for (i = 0; i < MAXITEMS; i++) {
		item = m_pClientList[iClientH]->m_pItemList[i];
		if (!item) continue;

		itemCategory = item->m_cCategory;

		if(itemCategory < 1 || itemCategory > 50 || (itemCategory > 13 && itemCategory < 43)) continue; 

		if(item->m_wMaxLifeSpan == 0 || item->m_wCurLifeSpan == item->m_wMaxLifeSpan) continue;

		if (item->m_wCurLifeSpan == 0) {
			price += item->m_wPrice / 2;
		}
		else {
			d1 = item->m_wMaxLifeSpan - item->m_wCurLifeSpan;
			d2 = (d1 / item->m_wMaxLifeSpan) * 0.5f;
			price += d2 * item->m_wPrice; 
		}
	}

	if (price != quotedPrice) {
		SendNotifyMsg(NULL, iClientH, NOTIFY_REPAIRALLPRICE, price);
	}
	else {
		for (i = 0; i < MAXITEMS && goldCount != 0; i++) {
			item = m_pClientList[iClientH]->m_pItemList[i];
			if (!item) continue;

			itemCategory = item->m_cCategory;

			if(itemCategory < 1 || itemCategory > 50 || (itemCategory > 13 && itemCategory < 43)) continue; 

			if(item->m_wMaxLifeSpan == 0 || item->m_wCurLifeSpan == item->m_wMaxLifeSpan) continue;

			if (item->m_wCurLifeSpan == 0) {
				price = item->m_wPrice / 2;
			}
			else {
				d1 = item->m_wMaxLifeSpan - item->m_wCurLifeSpan;
				d2 = (d1 / item->m_wMaxLifeSpan) * 0.5f;
				price = d2 * item->m_wPrice;
			}

			if (price < goldCount) {
				item->m_wCurLifeSpan = item->m_wMaxLifeSpan;
				goldCount -= price;
			} 
			else {
				d1 = item->m_wMaxLifeSpan * goldCount;
				d2 = item->m_wPrice / 2;
				item->m_wCurLifeSpan += d1/d2;
				goldCount = 0;
			}
			SendNotifyMsg(NULL, iClientH, NOTIFY_ITEMREPAIRED, i, item->m_wCurLifeSpan, NULL, NULL);
		}
		m_stCityStatus[m_pClientList[iClientH]->m_side].iFunds += (startGoldCount - goldCount);
		SetItemCount(iClientH, "Gold", goldCount);
		iCalcTotalWeight(iClientH);
	}
}

void CGame::RequestQuestListHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled == true) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == true) return;

	char	* cp, cData[5210], cNpcName[21];
	int		*ip, iRet, *listCount;
	uint32	*dwp;
	uint16	*wp;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strncpy(cNpcName, cp, 20);
	cp += 20;

	ZeroMemory(cData, sizeof(cData));
	dwp  = (uint32 *)(cData + INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_QUEST_LIST;
	wp   = (uint16 *)(cData + INDEX2_MSGTYPE);
	*wp  = MSGTYPE_CONFIRM;

	cp = cData + 6;

	listCount = (int*) cp; 
	*listCount = 0;
	cp += 4; 

	for(int i = 0; i < MAXQUESTTYPE; i++)
	{
		if( m_pQuestConfigList[i] == NULL ) continue;

		if (m_pQuestConfigList[i]->m_side != m_pClientList[iClientH]->m_side) continue; 
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) continue;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) continue;
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) continue;
		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) continue;

		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) continue;
		}

		ip = (int*) cp;
		*ip = i;
		cp += 4;

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_iType;
		cp += 4;

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_iTargetType;
		cp += 4;

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_iMaxCount;
		cp += 4;

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_iRewardAmount[dice(1,3)];
		cp += 8;

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_iContribution;
		cp += 4;

		memcpy(cp, m_pQuestConfigList[i]->m_cTargetName, 20);
		cp += 20;	

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_sX;
		cp += 4;

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_sY;
		cp += 4;

		ip = (int*) cp;
		*ip = m_pQuestConfigList[i]->m_iRange;
		cp += 4;

		(*listCount) ++;
	} 

	if ( (listCount) == 0 )
		*wp  = MSGTYPE_REJECT;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10 + (*listCount) *60);

	switch (iRet) {
	case XSOCKEVENT_QUENEFULL:
	case XSOCKEVENT_SOCKETERROR:
	case XSOCKEVENT_CRITICALERROR:
	case XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
}

void CGame::RequestAcceptQuestHandler(int iClientH, char * pData, uint32 dwMsgSize)
{
	char * cp;
	uint8 index;
	int iEraseReq;

	CClient * player = m_pClientList[iClientH];
	if (!player) return;
	if (player->m_bIsInitComplete == false) return;
	if (player->m_bIsKilled == true) return;
	if (player->m_bIsOnWaitingProcess == true) return;

	cp = (char *)(pData + INDEX2_MSGTYPE + 2);

	index = (int) (* cp);
	cp += 4;

	if(player->m_bIsQuestCompleted)
	{
		if(player->m_iQuestRewardType > 0 && m_pItemConfigList[player->m_iQuestRewardType])
		{
			CItem * item = new class CItem;
			item->InitItemAttr(m_pItemConfigList[player->m_iQuestRewardType]->m_cName);
			item->m_dwCount = player->m_iQuestRewardAmount;
			if(_bCheckItemReceiveCondition(iClientH, item))
			{
				_bAddClientItemList(iClientH, item, &iEraseReq);
				SendItemNotifyMsg(iClientH, NOTIFY_ITEMOBTAINED, item, NULL, false);
				if (iEraseReq == 1) {
					delete item;
					item = NULL;
				}

				player->m_iContribution += m_pQuestConfigList[player->m_iQuest]->m_iContribution;

				player->Notify(NULL, NOTIFY_QUESTREWARD, 4, 1, player->m_iQuestRewardAmount, 
					m_pItemConfigList[player->m_iQuestRewardType]->m_cName, player->m_iContribution);

				_ClearQuestStatus(iClientH);
			} 
			else {
				delete item;
				item = NULL;

				SendItemNotifyMsg(iClientH,	NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL, false);

				player->Notify(NULL, NOTIFY_QUESTREWARD, 4, 0, player->m_iQuestRewardAmount, 
					m_pItemConfigList[player->m_iQuestRewardType]->m_cName, player->m_iContribution);
			}
		}
		else if (player->m_iQuestRewardType == -2) 
		{
			player->m_iExpStock += player->m_iQuestRewardAmount * 5 * player->m_iLevel;
			player->m_iContribution += m_pQuestConfigList[player->m_iQuest]->m_iContribution;
			SendNotifyMsg(NULL, iClientH, NOTIFY_QUESTREWARD, 4, 1, player->m_iQuestRewardAmount, "exp", player->m_iContribution);
			_ClearQuestStatus(iClientH);
		}
		else if (player->m_iQuestRewardType == -1) 
		{
			player->m_iExpStock += player->m_iQuestRewardAmount;
			player->m_iContribution += m_pQuestConfigList[player->m_iQuest]->m_iContribution;
			player->Notify(NULL, NOTIFY_QUESTREWARD, 4, 1, player->m_iQuestRewardAmount, "exp", player->m_iContribution);
			_ClearQuestStatus(iClientH);
		}
		else {
			m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[player->m_iQuest]->m_iContribution;

			player->Notify(NULL, NOTIFY_QUESTREWARD, 4, 1, 0, "                     ", m_pClientList[iClientH]->m_iContribution);

			_ClearQuestStatus(iClientH);
		}
	} else {
		_ClearQuestStatus(iClientH);

		if( m_pQuestConfigList[index] == NULL )
			return;

		player->m_iQuest = index;
		player->m_iQuestID = m_pQuestConfigList[index]->m_iQuestID;
		player->m_iCurQuestCount    = 0;
		player->m_bIsQuestCompleted = false;

		int reward = dice(1,3);
		player->m_iQuestRewardType = m_pQuestConfigList[index]->m_iRewardType[reward];
		player->m_iQuestRewardAmount = m_pQuestConfigList[index]->m_iRewardAmount[reward];

		_CheckQuestEnvironment(iClientH);
		_SendQuestContents(iClientH);
	}
} 

